/*!
  Density-Weighted k-Nearest Neighbors Gradient Flow Algorithm (DW-kNN-GFA)

  Local (kNN) response rate of change weighted estimation of gradient flow

  Using response variable's rate of change and data density to estimat the gradient direction
*/

#include <R.h>
#include <Rinternals.h>

// Undefine conflicting macros after including R headers
#undef length

#include <ANN/ANN.h>  // ANN library header
#include <vector>
#include <algorithm>
#include <memory>

#include "msr2.h"

/*! The function computes the maximal cosine of the angle between the unit
  gradient vector, grady, and the unit vectors associated with the difference
  vectors x_i - x, where x_0, x_1, ... , x_{k-1} are k nearest neighbors of x.

  \param grady  The unit vector estimate, grady, of the direction of the gradient of a response variable y.
  \param x      A point at which grady is estimated. nn_i are indices of the k NN's of x.
  \param X      A pointer to the data matrix.
  \param nrX    The number of rows of X.
  \param ncX    The number of columns of X.
  \param nn_i   An integer vector of length k of the indices of the k NN's of x.
  \param nn_d   A double vector of length k of the distances of the k NN's to x.
  \param k      The number of nearest neighbors.

*/
double max_cos_angle_bw_grady_and_kNNs(std::vector<double> &grady,
                                       ANNpoint x,
                                       double *X,
                                       int nrX,
                                       int ncX,
                                       ANNidxArray nn_i,
                                       ANNdistArray nn_d,
                                       int k) {

    #define DEBUG_max_cos_angle_bw_grady_and_kNNs 0

    double L2norm = 0; // for debugging only
    const double TOLERANCE = 1e-6;

    // For each NN, x_j, of newx computing the cosine of angle between x_j:newx and prev_grady
    double cos_angle = 0; // variable holding the cosine of the angle between nnu and prev_grady
    double max_cos_angle = -1.0;
    std::vector<double> nnu(ncX);
    for (int j = 0; j < k; j++) {

        if ( nn_d[j] == 0 )
            continue;

        // Computing unit vector associated with the j-th NN of newx
        for (int l = 0; l < ncX; l++) {
            nnu[l] = (X[nn_i[j] + nrX * l] - x[l]) / nn_d[j];
        }

        // Checking if nnu is a unit vector
        L2norm = 0;
        for (int l = 0; l < ncX; l++)
            L2norm += nnu[l] * nnu[l];
        L2norm = sqrt(L2norm);
        if (std::abs(L2norm - 1.0) > TOLERANCE) {
            Rprintf("j: %d\tnnu is not sufficiently close to a unit vector in max_cos_angle_bw_grady_and_kNNs().\n", j);
        }

        // Checking if grady is a unit vector
        L2norm = 0;
        for (int l = 0; l < ncX; l++)
            L2norm += grady[l] * grady[l];
        L2norm = sqrt(L2norm);
        if (std::abs(L2norm - 1.0) > TOLERANCE) {
            Rprintf("j: %d\tgrady is not sufficiently close to a unit vector in max_cos_angle_bw_grady_and_kNNs().\n", j);
        }


        #if DEBUG_max_cos_angle_bw_grady_and_kNNs
        Rprintf("Checking if nnu is a unit vector in max_cos_angle_bw_grady_and_kNNs()\n");
        double L2norm = 0;
        for (int l = 0; l < ncX; l++)
            L2norm += nnu[l] * nnu[l];
        L2norm = sqrt(L2norm);
        Rprintf("L2norm(nuu): %.6f\n", L2norm);

        Rprintf("Checking if grady is a unit vector in max_cos_angle_bw_grady_and_kNNs()\n");
        L2norm = 0;
        for (int l = 0; l < ncX; l++)
            L2norm += grady[l] * grady[l];
        L2norm = sqrt(L2norm);
        Rprintf("L2norm(grady): %.6f\n", L2norm);

        error("Stopping function execution for debugging purposes in max_cos_angle_bw_grady_and_kNNs()");
        #endif

        // Computing the cosine angle between nnu and prev_grady
        cos_angle = 0;
        for ( int l = 0; l < ncX; l++ )
            cos_angle += grady[l] * nnu[l];

        if ( cos_angle > max_cos_angle )
            max_cos_angle = cos_angle;
    }

    return max_cos_angle;
}


typedef struct {
    std::vector<double> trajectory;
    std::vector<double> lmax; // Assuming lmax is also a vector of doubles
} trajectory_t;


/*!
  Estimates gradient flow trajectory using response variables' rate of change and data density weighted mean of kNN directions

  \param pti             The index, 0-based, of the point in a neighborhood of which the linear model is to be fit to the kNN data of that point.
  \param kdTree          The kd-tree of X generated by ANN pkg.
  \param RX              The data matrix.
  \param Ry              The response variable.
  \param Rrho            The density of X.
  \param Rk              The number of nearest neighbors to use for the estimate of the trajectory.
  \param Rscalef         The scaling factor for the step in the mean shift algorithm.
  \param Rdiv_thld       The number of times the step in the mean shift algorithm is scaled. The algorithm terminates after that many scaling events.
  \param Rcos_angle_thld The threshold of the cosine of the angle between the current gradient of y and the direction vectors of then kNN's of the candidate trajectory point. The cosine of the angle between the current gradient of y and the direction vector of one of the kNN's of newx has to be greater than the given threshold.
  \param Rn_itrs         The maximal number of iterations = the maximal number of points within the trajectory.

  The Algorithm:

  1. Initialize the starting point \(x = X[pti,]\) and compute the next point \(x_{\text{next}}\) of the gradient flow trajectory as:
  \[
  x_{\text{next}} = x + s \cdot u\nabla y
  \]
  where \(s\) is the step size and \(u\nabla y\) is a unit vector pointing in the direction of the gradient of \(E(D|X)\) at \(x\).

  2. Find the \(k\) nearest neighbors of \(x\) in \(X\): \(x_{1}, x_{2}, \ldots,
  x_{k}\), and their corresponding \(y\) values \(y_{1}, y_{2}, \ldots, y_{k}\).
  Let \(y_{0}\) be the value of \(y\) at \(x\). Compute the distances \(d_{1},
  d_{2}, \ldots, d_{k}\) between \(x\) and its \(k\) nearest neighbors, and the
  density values \(\rho_{1}, \rho_{2}, \ldots, \rho_{k}\) at these neighbors.

  3. Calculate the rate of change \(dy_{i}\) of \(y\) along the vector \(x_{i} -
  x\) and the unit vector \(\vec{u}_{i}\) of \(x_{i} - x\). Estimate the
  direction of the maximal growth of \(y\) at \(x\) as:
  \[
  u\nabla y = \sum_{i = 1}^{k} \rho_{i} dy_{i} \vec{u}_{i}
  \]
  and normalize \(u\nabla y\) to unit length.

  4. Set the step size \(s = d_{k}\) and initialize the step multiplier constant
  \(C_{\text{step}} = 1\), the counter for scaling events \(n_{\text{div}} =
  0\), and the previous gradient direction \(u\nabla y_{\text{prev}} = u\nabla
  y\).

  5. Compute the next point \(x_{\text{next}}\) and estimate the value of \(y\) at \(x_{\text{next}}\) as the weighted mean
  \[
  y_{\text{next}} = \sum_{i = 1}^{k} \frac{\rho_{i}}{d_{i}} y_{i} / \sum_{i = 1}^{k} \frac{\rho_{i}}{d_{i}}
  \]

  6. Initialize the iteration index \(i_{\text{itr}} = 0\).

  7. \textbf{Inductive step:} Update \(x = x_{\text{next}}\), \(y_{0} = y_{\text{next}}\), and \(i_{\text{itr}} = i_{\text{itr}} + 1\). Repeat steps 2-5 to compute the new \(u\nabla y\) and \(x_{\text{next}}\).

  8. Compute the inner product \(\text{ipr}\) between \(u\nabla y_{\text{prev}}\) and \(u\nabla y\). If \(\text{ipr} < 0\), update \(C_{\text{step}} = \text{scalef} \cdot C_{\text{step}}\) and \(n_{\text{div}} = n_{\text{div}} + 1\).

  9. Set \(u\nabla y_{\text{prev}} = u\nabla y\) and iterate the inductive step as long as \(i_{\text{itr}} < n_{\text{itr}}\) and \(n_{\text{div}} < \text{divthld}\).


  \return Returns a struc with two components: 1) std::vector<double> trajectory 2) the final point of the trajectory located in a vicinity of a local maximum of y.
*/
std::unique_ptr<trajectory_t> dw_knn_gf_trajectory(int pti,
                                                   ANNkd_tree *kd_tree,
                                                   ANNpointArray &data_pts,
                                                   SEXP RX,
                                                   SEXP Ry,
                                                   SEXP Rrho,
                                                   SEXP Rk, // change to RnNNs
                                                   SEXP Rscalef,
                                                   SEXP Rdiv_thld,
                                                   //SEXP Rcos_angle_thld,
                                                   SEXP Rn_itrs) {
    #define DEBUG_dw_knn_gf_trajectory 0
    #define DEBUG_dw_knn_gf_trajectory_L2 0

    int nprot = 0;
    PROTECT(RX = coerceVector(RX, REALSXP)); nprot++;
    PROTECT(Ry = coerceVector(Ry, REALSXP)); nprot++;
    PROTECT(Rrho = coerceVector(Rrho, REALSXP)); nprot++;
    PROTECT(Rk = coerceVector(Rk, INTSXP)); nprot++;
    PROTECT(Rn_itrs = coerceVector(Rn_itrs, INTSXP)); nprot++;
    PROTECT(Rscalef = coerceVector(Rscalef, REALSXP)); nprot++;
    PROTECT(Rdiv_thld = coerceVector(Rdiv_thld, REALSXP)); nprot++;
    //PROTECT(Rcos_angle_thld = coerceVector(Rcos_angle_thld, REALSXP)); nprot++;

    double *y = REAL(Ry);
    double *rho = REAL(Rrho);
    double *X = REAL(RX);
    int k = INTEGER(Rk)[0];
    int n_itrs = INTEGER(Rn_itrs)[0];
    int *dimX = INTEGER(getAttrib(RX, R_DimSymbol));
    int nrX = dimX[0];
    int ncX = dimX[1];
    double scalef = REAL(Rscalef)[0];
    double div_thld = REAL(Rdiv_thld)[0];
    //double cos_angle_thld = REAL(Rcos_angle_thld)[0];

    // Allocate memory for nearest neighbor indices and distances
    ANNidxArray nn_i  = new ANNidx[k];
    ANNdistArray nn_d = new ANNdist[k];

    ANNpoint newx = annAllocPt(ncX);    // new point of the trajectory
    double newy   = 0;                  // the value of y at the new point of the trajectory

    std::vector<double> nny(k);          // values of y over N(x,k)
    std::vector<double> nnrho(k);        // values of rho over N(x,k)
    std::vector<double> nnu(ncX);        // unit vector associated with a given NN of newx
    std::vector<double> grady(ncX);      // unit vector of the current gradient of y estimate
    std::vector<double> prev_grady(ncX); // unit vector of the previously estimated gradient of y

    // Perform k-NN search for each point
    std::vector<double> trajectory; // the j-th coordinate of the i-th point of the trajectory is trajectory[i * ncX + j]
    trajectory.reserve(n_itrs);  // Reserve enough space initially to avoid frequent allocations

    // Initialization of x and trajectory
    // The first point of the trajectory is the point whose gradient flow trajectory we are estimating
    for ( int l = 0; l < ncX; l++ ) {
        newx[l] = X[pti + nrX * l];
        trajectory.push_back(newx[l]);
    }

    auto res = std::make_unique<trajectory_t>(); // return object
    res->lmax.resize(ncX); // Ensure lmax has the correct size

    // -------------------------------------------------------------------------
    //
    // Finding the first point of the trajectory after the initial point
    //
    // -------------------------------------------------------------------------

    #if DEBUG_dw_knn_gf_trajectory
    Rprintf("In dw_knn_gf_trajectory(): pti=%d\n", pti);
    Rprintf("First 10 rows of X:\n");
    print_2d_double_array_first_n(X, nrX, ncX, 10, 8);
    #endif

    //  Finding indices, nn_i, and distances, nn_d, of the \(k\) nearest neighbors of \(x\) in \(X\):
    kd_tree->annkSearch(data_pts[pti], k, nn_i, nn_d, 0); // Identifying kNN's of data_pts[i], including the point data_pts[pti].

    for (int j = 1; j < k; j++)
        nn_d[j] = sqrt(nn_d[j]);

    #if DEBUG_dw_knn_gf_trajectory
    Rprintf("nn_i:\n");
    print_int_array(nn_i, k);

    Rprintf("nn_d:\n");
    print_double_array(nn_d, k);

    //error("Stopping function execution for debugging purposes.");
    #endif

    // Check if x is a local maximum of y
    // Finding the values \(y_{0}, y_{1}, \ldots, y_{k-1}\)  of \(y\) at the k-1 NNs. \(y_{0}\) is the value of \(y\) at \(x\).
    nny[0] = y[nn_i[0]];

    int x_lmax = 1; // "Is x a local max of y?" indicator variable
    for (int j = 1; j < k; j++) {
        nny[j] = y[nn_i[j]];
        if ( nny[j] > nny[0] ) {
            x_lmax = 0;
            break;
        }
    }

    if ( x_lmax == 1 ) { // x is a local max of y

        #if DEBUG_dw_knn_gf_trajectory
        Rprintf("x is a local maximum of y - exiting\n");
        #endif

        delete[] nn_i;
        delete[] nn_d;

        res->trajectory = std::move(trajectory);
        res->trajectory.shrink_to_fit();  // Request to reduce capacity to size

        // Copying newx to res->lmax
        for (int l = 0; l < ncX; l++) {
            res->lmax[l] = newx[l];
        }

        annDeallocPt(newx);

        UNPROTECT(nprot);

        return res;
    }

    // Finding the direction of the gradient of y
    for ( int l = 0; l < ncX; l++ )
        grady[l] = 0;

    double delta_y = 0;
    double w = 0;

    #if DEBUG_dw_knn_gf_trajectory
    double L2norm = 0;
    #endif

    // double weighted_step = 0;
    // int n_steps = 0;
    for (int j = 1; j < k; j++) { // we are starting from j = 1 as j = 0 corresponds to newx

        if ( nn_d[j] == 0 )
            continue;

        // computing the rate of change of y
        delta_y = (nny[j] - nny[0]) / nn_d[j];

        // Only averaging over NN's directions where the rate of change is positive
        if ( delta_y <= 0 )
            continue;

        // Computing unit vector associated with the j-th NN of newx
        for (int l = 0; l < ncX; l++)
            nnu[l] = (X[nn_i[j] + nrX * l] - newx[l]) / nn_d[j];

        //#if DEBUG_dw_knn_gf_trajectory
        #if 0
        Rprintf("j: %d\tTesting if nnu is a unit vector\n", j);
        for (int l = 0; l < ncX; l++)
            L2norm += nnu[l] * nnu[l];
        L2norm = sqrt(L2norm);
        Rprintf("L2norm(nuu): %.6f\n", L2norm);

        Rprintf("j: %d\tTesting if nn_d[j] is the norm of x_j - newx\n",j);
        L2norm = 0;
        for (int l = 0; l < ncX; l++) {
            nnu[l] = X[nn_i[j] + nrX * l] - newx[l];
            L2norm += nnu[l] * nnu[l];
        }
        L2norm = sqrt(L2norm);
        Rprintf("L2norm(nuu): %.6f\t nn_d[j]: %.6f\n", L2norm, nn_d[j]);

        error("Stopping function execution for debugging purposes in dw_knn_gf_trajectory()");
        #endif


        nnrho[j] = rho[nn_i[j]]; // Computing the density values \(\rho_{0}, \rho_{1}, \ldots, \rho_{k-1}\) at these neighbors.
        w = nnrho[j] * delta_y; // the weight of nnu

        // weighted_step += nnrho[j] * nn_d[j];
        // n_steps += 1;

        for ( int l = 0; l < ncX; l++ )
            grady[l] += w * nnu[l];
    }

    //weighted_step /= (double)n_steps;

    // Normalizing the estimated gradient direction vector to have length 1
    double L2norm = 0;
    //L2norm = 0;
    for (int l = 0; l < ncX; l++)
        L2norm += grady[l] * grady[l];
    L2norm = sqrt(L2norm);
    for (int l = 0; l < ncX; l++)
        grady[l] /= L2norm;

    // Testing if the the maximal cosine of the angle between the unit gradient
    // vector, grady, and the unit vectors associated with the difference
    // vectors x_i - newx, where x_0, x_1, ... , x_{k-1} are k nearest neighbors of
    // newx, is above the cos_angle_thld.
    #if 0
    double max_cos_angle = max_cos_angle_bw_grady_and_kNNs(grady, newx, X, nrX, ncX, nn_i, nn_d, k);

    if ( max_cos_angle < cos_angle_thld ) {

        #if DEBUG_dw_knn_gf_trajectory
        Rprintf("max_cos_angle < cos_angle_thld - exiting\n");
        #endif

        delete[] nn_i;
        delete[] nn_d;

        res->trajectory = std::move(trajectory);
        res->trajectory.shrink_to_fit();  // Request to reduce capacity to size

        // Copying newx to res->lmax
        for (int l = 0; l < ncX; l++) {
            res->lmax[l] = newx[l];
        }

        annDeallocPt(newx);

        UNPROTECT(nprot);

        return res;
    }
    #endif

    // Copying the content of the unit grady to prev_grady
    std::copy(grady.data(), grady.data() + ncX, prev_grady.begin());

    // Setting the norm of grady to be nn_d[k-1] / step_division_factor. This is the step size in the gradient trajectory construct.
    double step_division_factor = 2.5;
    L2norm = nn_d[k-1] / step_division_factor;
    for ( int l = 0; l < ncX; l++ ) {
        newx[l] += L2norm * grady[l];
        trajectory.push_back(newx[l]);
    }

    // -------------------------------------------------------------------------
    //
    // Finding the remaining points of the trajectory
    //
    // -------------------------------------------------------------------------

    double inner_product = 0;
    double step_scale = 1.0;
    int itr = 0;
    int ndiv = 0;
    double total_w = 0;
    while ( itr < n_itrs && ndiv < div_thld ) {

        itr++;

        #if DEBUG_dw_knn_gf_trajectory_L2
        Rprintf("itr: %d\n", itr);
        //if ( itr > 100 )
        //    error("Stopping function execution for debugging purposes.");
        #endif

        // Finding kNN of newx among the points of X
        kd_tree->annkSearch(newx, k, nn_i, nn_d, 0);

        // Q: What is the first element of nn_i when x is not a point of X ???
        // A: nn_i[0] is the index of the closest to x element of X and nn_d[0] is the distance between x and this first NN of x

        #if DEBUG_dw_knn_gf_trajectory
        Rprintf("itr: %d\n", itr);

        Rprintf("nn_i: ");
        print_int_array(nn_i, k);

        Rprintf("nn_d: ");
        print_double_array(nn_d, k);
        #endif

        // Evaluating y and rho over kNN's and estimating y at x
        newy = 0;
        total_w = 0;
        w = 0;
        for (int j = 0; j < k; j++) {
            nn_d[j] = sqrt(nn_d[j]);
            nny[j] = y[nn_i[j]];
            nnrho[j] = rho[nn_i[j]];
            // newy estimate
            if ( nn_d[j] > 0 ) {
                w = nnrho[j] / nn_d[j]; /// <<--- this is an ad hoc weight construct
                total_w += w;
                newy += w * nny[j];
            }
        }
        newy /= total_w;

        nny[0] = newy;
        // x is not a local maximum of y, so we continue our search for one.
         // weighted_step = 0;
         // n_steps = 0;
        for (int j = 0; j < k; j++) { // we are starting from j = 1 as j = 0 corresponds to newx

            if ( nn_d[j] == 0 )
                continue;

            // computing the rate of change of y
            delta_y = (nny[j] - nny[0]) / nn_d[j];

            // Only averaging over NN's directions where the rate of change is positive
            if ( delta_y <= 0 )
                continue;

            // Computing unit vector associated with the j-th NN of newx
            L2norm = 0;
            for (int l = 0; l < ncX; l++)
                nnu[l] = (X[nn_i[j] + nrX * l] - newx[l]) / nn_d[j];

            w = nnrho[j] * delta_y; // the weight of nnu

            // weighted_step += nnrho[j] * nn_d[j];
            // n_steps += 1;

            for ( int l = 0; l < ncX; l++ )
                grady[l] += w * nnu[l];

        } // END OF for (int j = 1; j < k; j++)

        //weighted_step /= (double)n_steps;

        // Normalizing the estimated gradient direction vector to have length 1
        L2norm = 0;
        for (int l = 0; l < ncX; l++)
            L2norm += grady[l] * grady[l];
        L2norm = sqrt(L2norm);

        for (int l = 0; l < ncX; l++)
            grady[l] /= L2norm;

        // Testing if the the maximal cosine of the angle between the unit gradient
        // vector, grady, and the unit vectors associated with the difference
        // vectors x_i - newx, where x_0, x_1, ... , x_{k-1} are k nearest neighbors of
        // newx, is above the cos_angle_thld.
        #if 0
        max_cos_angle = max_cos_angle_bw_grady_and_kNNs(grady, newx, X, nrX, ncX, nn_i, nn_d, k);

#if DEBUG_dw_knn_gf_trajectory
        Rprintf("itr: %d\tmax_cos_angle: %.6f\n", itr, max_cos_angle);
#endif

        if ( max_cos_angle < cos_angle_thld ) {

            #if DEBUG_dw_knn_gf_trajectory
            Rprintf("max_cos_angle < cos_angle_thld at itr %d - exiting\n", itr);
            #endif

            delete[] nn_i;
            delete[] nn_d;

            res->trajectory = std::move(trajectory);
            res->trajectory.shrink_to_fit();  // Request to reduce capacity to size

            // Copying newx to res->lmax
            for (int l = 0; l < ncX; l++) {
                res->lmax[l] = newx[l];
            }

            annDeallocPt(newx);

            UNPROTECT(nprot);

            return res;
        }
        #endif

        // Computing the inner product between the current and previews
        // grady to check if the new grady points in the same direction
        // as the previous one
        inner_product = 0;
        for ( int l = 0; l < ncX; l++ )
            inner_product += prev_grady[l] * grady[l];

#if DEBUG_dw_knn_gf_trajectory
        Rprintf("itr: %d\tinner_product: %.6f\n", itr, inner_product);
#endif

        // Copying the content of the unit grady to prev_grady
        std::copy(grady.data(), grady.data() + ncX, prev_grady.begin());

        if ( inner_product < 0 ) { // detected a change in the direction of the gradient vector, so we decrease the step size by a factor of step_scalef
            step_scale *= scalef;
            ndiv++;
#if DEBUG_dw_knn_gf_trajectory
            Rprintf("itr: %d\tIn if ( inner_product < 0 ) ndiv: %d\n", itr, ndiv);
#endif
        }

        // Turning grady into a step vector defined to be the grady
        // normalized to have the length equal to the distance to the k-th nearest neighbor
        w = step_scale * nn_d[k-1] / step_division_factor;
        //w = step_scale * weighted_step;
        for ( int l = 0; l < ncX; l++ )
            grady[l] *= w;

        for ( int l = 0; l < ncX; l++ ) {
            newx[l] += grady[l];

            #if DEBUG_dw_knn_gf_trajectory_L2
            Rprintf("newx[%d]: %.5f\n", l, newx[l]);
            #endif

            trajectory.push_back(newx[l]);
        }

    } // END OF while ( ndiv < div_thld )

    delete[] nn_i;
    delete[] nn_d;

    res->trajectory = std::move(trajectory);
    res->trajectory.shrink_to_fit();

    // Copying newx to res->lmax
    for (int l = 0; l < ncX; l++) {
        res->lmax[l] = newx[l];
    }

    annDeallocPt(newx);

    UNPROTECT(nprot);

    return res;
}

extern "C" {

    /*!
       Estimates gradient flow trajectories for all points of the given state space; A version with Rsubset parameter !!!

       \param RX              The data matrix.
       \param Ry              The response variable.
       \param Rrho            The density of X.
       \param Rk              The number of nearest neighbors to use for the estimate of the trajectory.
       \param Rscalef         The scaling factor for the step in the mean shift algorithm.
       \param Rdiv_thld       The number of times the step in the mean shift algorithm is scaled. The algorithm terminates after that many scaling events.
       \param Rcos_angle_thld The threshold of the cosine of the angle between the current gradient of y and the direction vectors of then kNN's of the candidate trajectory point. The cosine of the angle between the current gradient of y and the direction vector of one of the kNN's of newx has to be greater than the given threshold.
       \param Rsubset         A vector of indices of X for which the trajectories are to be found.
       \param Rn_itrs         The maximal number of iterations = the maximal number of points within the trajectory.

       \return Returns a list with two components 1) a list of trajectoris for all points of X 2) A matrix local maximum associated with all point of X
    */
    SEXP S_dw_knn_gf_trajectories(SEXP RX,
                                  SEXP Ry,
                                  SEXP Rrho,
                                  SEXP Rk,
                                  SEXP Rscalef,
                                  SEXP Rdiv_thld,
                                  //SEXP Rcos_angle_thld,
                                  SEXP Rsubset,
                                  SEXP Rn_itrs) {

        int nprot = 0;
        PROTECT(RX = coerceVector(RX, REALSXP)); ++nprot;
        PROTECT(Ry = coerceVector(Ry, REALSXP)); ++nprot;
        PROTECT(Rk = coerceVector(Rk, INTSXP)); ++nprot;
        PROTECT(Rscalef = coerceVector(Rscalef, REALSXP)); ++nprot;
        PROTECT(Rdiv_thld = coerceVector(Rdiv_thld, REALSXP)); ++nprot;

        // Check if Rsubset is provided and coerce it to integer vector
        int *subset = NULL;
        int subset_len = 0;
        if (Rsubset != R_NilValue) {
            PROTECT(Rsubset = coerceVector(Rsubset, INTSXP)); ++nprot;
            subset = INTEGER(Rsubset);
            subset_len = LENGTH(Rsubset);
        }

        double *X = REAL(RX);
        int *dimX = INTEGER(getAttrib(RX, R_DimSymbol));
        int nrX = dimX[0];
        int ncX = dimX[1];

        ANNpointArray data_pts = annAllocPts(nrX, ncX);
        for (int i = 0; i < nrX; i++) {
            for (int j = 0; j < ncX; j++) {
                data_pts[i][j] = X[i + nrX * j];
            }
        }

        ANNkd_tree *kd_tree = new ANNkd_tree(data_pts, nrX, ncX);

        int n_trajectories = (subset != NULL) ? subset_len : nrX;
        SEXP trajectories_list = PROTECT(allocVector(VECSXP, n_trajectories)); ++nprot;
        SEXP lmax_matrix = PROTECT(allocMatrix(REALSXP, n_trajectories, ncX)); ++nprot;

        // main loop
        for (int i = 0; i < n_trajectories; i++) {
            int index = (subset != NULL) ? subset[i] - 1 : i;

            // Check if the index is within valid range
            if (index < 0 || index >= nrX) {
                error("Invalid index in Rsubset");
            }

            std::unique_ptr<trajectory_t> tr_res = dw_knn_gf_trajectory(index,
                                                                        kd_tree,
                                                                        data_pts,
                                                                        RX,
                                                                        Ry,
                                                                        Rrho,
                                                                        Rk,
                                                                        Rscalef,
                                                                        Rdiv_thld,
                                                                        //Rcos_angle_thld,
                                                                        Rn_itrs);

            // Extracting 'trajectory' and 'lmax' components from the trajectory_t pointer returned by dw_knn_gf_trajectory()
            const std::vector<double>& trajectory = tr_res->trajectory;
            const std::vector<double>& lmax = tr_res->lmax;

            // Creating a trajectory matrix
            size_t n = trajectory.size() / ncX; // Number of points in the trajectory
            SEXP trajectory_matrix = PROTECT(allocMatrix(REALSXP, n, ncX)); // n-by-ncX matrix
            for (size_t row = 0; row < n; row++) {
                for (int col = 0; col < ncX; col++) {
                    // Fill the matrix; note the 1D indexing of tr_res->trajectory
                    REAL(trajectory_matrix)[row + n * col] = trajectory[row * ncX + col];
                }
            }

            // Set the corresponding element of trajectories_list
            SET_VECTOR_ELT(trajectories_list, i, trajectory_matrix);
            UNPROTECT(1); // Unprotect trajectory_matrix

            for (int j = 0; j < ncX; j++) {
                REAL(lmax_matrix)[i + n_trajectories * j] = lmax[j]; 
            }
        }


        // Free memory allocated by ANN
        annDeallocPts(data_pts);
        delete kd_tree;

        SEXP result = PROTECT(allocVector(VECSXP, 2)); ++nprot;
        SET_VECTOR_ELT(result, 0, trajectories_list);
        SET_VECTOR_ELT(result, 1, lmax_matrix);

        SEXP names = PROTECT(allocVector(STRSXP, 2)); ++nprot;
        SET_STRING_ELT(names, 0, mkChar("trajectories"));
        SET_STRING_ELT(names, 1, mkChar("lmax_matrix"));
        setAttrib(result, R_NamesSymbol, names);

        UNPROTECT(nprot);

        return result;
    }
}
