/*!
  Methods for local (kNN) linear model estimation of gradient flow

  The main issue: Gradient direction as estimated by a linear model may be pointing away from data
*/

#include <R.h>
#include <Rinternals.h>

// Undefine conflicting macros after including R headers
#undef length

#include <ANN/ANN.h>  // ANN library header
#include <vector>
#include <algorithm>
#include <memory>

#include "msr2.h"

struct TrajectoryResult {
    std::vector<double> trajectory;
    std::vector<double> lmax; // Assuming lmax is also a vector of doubles
};

/*!
  Estimates gradient flow trajectory using a series of linear models

  \param i              The index, 0-based, of the point in a neighborhood of which the linear model is to be fit to the kNN data of that point.
  \param kdTree         The kd-tree of X generated by ANN pkg.
  \param RX             The data matrix.
  \param Ry             The response variable.
  \param Rk             The number of nearest neighbors to use for the estimate of the trajectory.
  \param Rscalef        The scaling factor for the step in the mean shift algorithm.
  \param Rdivthld       The number of times the step in the mean shift algorithm is scaled. The algorithm terminates after that many scaling events.
  \param RcosAngleThld  The threshold of the cosine of the angle between the current gradient of y and the direction vectors of then kNN's of the candidate trajectory point. The cosine of the angle between the current gradient of y and the direction vector of one of the kNN's of newx has to be greater than the given threshold.

  \return Returns a list with two components: 1) std::vector<double> trajectory 2) the local maximum point which is the final point of the trajectory.
*/
std::unique_ptr<TrajectoryResult> S_gf_lm_trajectory(int i,
                                                     ANNkd_tree *kdTree,
                                                     ANNpointArray &dataPts,
                                                     SEXP RX,
                                                     SEXP Ry,
                                                     SEXP Rk,
                                                     SEXP Rscalef,
                                                     SEXP RdivThld,
                                                     SEXP RcosAngleThld) {
    #define DEBUG_S_gf_lm_trajectory 0

    int nprot = 0;
    PROTECT(RX = coerceVector(RX, REALSXP)); nprot++;
    PROTECT(Ry = coerceVector(Ry, REALSXP)); nprot++;
    PROTECT(Rk = coerceVector(Rk, INTSXP)); nprot++;
    PROTECT(Rscalef = coerceVector(Rscalef, REALSXP)); nprot++;
    PROTECT(RdivThld = coerceVector(RdivThld, REALSXP)); nprot++;
    PROTECT(RcosAngleThld = coerceVector(RcosAngleThld, REALSXP)); nprot++;

    double *y = REAL(Ry);
    double *X = REAL(RX);
    int k = INTEGER(Rk)[0];
    int *dimX = INTEGER(getAttrib(RX, R_DimSymbol));
    int nrX = dimX[0];
    int ncX = dimX[1];
    double div_thld = REAL(RdivThld)[0];
    double cos_angle_thld = REAL(RcosAngleThld)[0];
    double scalef = REAL(Rscalef)[0];

    // Allocate memory for nearest neighbor indices and distances
    ANNidxArray nnIdx = new ANNidx[k];
    ANNdistArray nnDist = new ANNdist[k];
    ANNidxArray x_nnIdx = new ANNidx[k];
    ANNdistArray x_nnDist = new ANNdist[k];

    double *beta = (double*)malloc((ncX + 1) * sizeof(double)); // coefficients of the linear model defined over the set, N(x,k), of kNN of x, including x.
    CHECK_PTR( beta );

    double *nnX = (double*)malloc(k * ncX * sizeof(double)); // values of X over N(x,k) - it represents a matrix with k rows and ncX columns;
    CHECK_PTR( nnX );

    double *nny = (double*)malloc(k * sizeof(double)); // values of y over N(x,k)
    CHECK_PTR( nny );

    double *nnu = (double*)malloc(ncX * sizeof(double)); // A unit vector associated with a given NN of newx
    CHECK_PTR( nnu );

    // Perform k-NN search for each point
    std::vector<double> trajectory; // the j-th coordinate of the i-th point of the trajectory is trajectory[i * ncX + j]
    trajectory.resize(ncX);

    // The first point of the trajectory is the point whose gradient flow trajectory we are estimating
    for ( int l = 0; l < ncX; l++ )
        trajectory[l] = X[i + nrX * l];

    std::vector<double> prev_grady; // previous gradient of y vector
    prev_grady.reserve(ncX);
    prev_grady.resize(ncX); // Adjust the size of prev_grady to hold ncX elements

    ANNpoint x = annAllocPt(ncX);
    ANNpoint newx = annAllocPt(ncX);

    auto res = std::make_unique<TrajectoryResult>(); // return object
    res->lmax.resize(ncX); // Ensure lmax has the correct size


    // -------------------------------------------------------------------------
    //
    // Finding the first point of the trajectory after the initial point
    //
    // -------------------------------------------------------------------------

    #if DEBUG_S_gf_lm_trajectory
    Rprintf("In S_gf_lm_trajectory(): i=%d\n",i);
    Rprintf("First 10 rows of X:\n");
    print_2d_double_array_first_n(X, nrX, ncX, 10, 8);
    #endif

    kdTree->annkSearch(dataPts[i], k, nnIdx, nnDist, 0); // Identifying kNN's of dataPts[i], including the point dataPts[i].

    // Copy nnIdx to x_nnIdx
    std::copy(nnIdx, nnIdx + k, x_nnIdx);
    // Copy nnDist to x_nnDist
    std::copy(nnDist, nnDist + k, x_nnDist);

    #if DEBUG_S_gf_lm_trajectory
    Rprintf("nnIdx:\n");
    print_int_array(nnIdx, k);

    Rprintf("nnDist:\n");
    print_double_array(nnDist, k);
    #endif

    // Restricting X and y to the k-NN's of the given point - the i-th point of X
    for (int j = 0; j < k; j++) {
        nny[j] = y[nnIdx[j]];
        for (int l = 0; l < ncX; l++) {
            nnX[j + k * l] = X[nnIdx[j] + nrX * l];
        }
    }

    #if DEBUG_S_gf_lm_trajectory
    Rprintf("nny:\n");
    print_double_array(nny, k);

    Rprintf("nnX:\n");
    print_2d_double_array_first_n(nnX, k, ncX, k, 8);
    #endif

    // Finding coordinates (beta) of a Solving nny ~ nnX linear equation
    C_flm(nnX, nny, &k, &ncX, beta);

    #if DEBUG_S_gf_lm_trajectory
    Rprintf("beta:\n");
    print_double_array(beta, ncX + 1);
    #endif

    // Gradient estimate of y at the current point are the coefficients of the model excluding the y-intercept
    double *grady = beta + 1;

    // Computing L2 norm of grady
    double L2norm = 0;
    for ( int l = 0; l < ncX; l++ )
        L2norm += grady[l] * grady[l];
    L2norm = sqrt(L2norm);

    int ndiv = 0; // The number of divisions of the step size
    if (L2norm == 0) {
        ndiv = div_thld; // it looks like the point is a local maximum; no need to look for points of the gradient flow trajectory - we have already arrived at the local maximum
    } else {
        // Normalizing grad(y) making it a unit vector
        for ( int l = 0; l < ncX; l++ )
            grady[l] /= L2norm;
    }

    // Copying the content of the unit grady to prev_grady
    std::copy(grady, grady + ncX, prev_grady.begin());

    #if DEBUG_S_gf_lm_trajectory
    Rprintf("normalized grady:\n");
    print_double_array(grady, ncX);

    Rprintf("prev_grady:\n");
    print_double_array(prev_grady.data(), ncX);
    #endif

    // Turning grady into a step vector defined to be the grady
    // normalized to have the length equal to the distance to the k-th
    // nearest neighbor
    for ( int l = 0; l < ncX; l++ )
        grady[l] *= sqrt(nnDist[k-1]);

    // The first point of the trajectory after the initial point is (initial point) + grady
    for ( int l = 0; l < ncX; l++ ) {
        x[l] = trajectory[l];
        newx[l] = trajectory[l] + grady[l];
    }

    // In order for newx to be accepted as a new point of the trajectory, at
    // least one of the kNN's of newx has to be pointing approximately in
    // the same direction as grady

    // Finding kNN of newx
    kdTree->annkSearch(newx, k, nnIdx, nnDist, 0);

    // For each NN, x_j, of newx computing the cosine of angle between x_j:newx and prev_grady
    double cos_angle = 0; // variable holding the cosine of the angle between nnu and prev_grady
    int found_nn_pointing_in_dir_ugrady = 0;
    nny[0] = y[nnIdx[0]];
    for (int j = 1; j < k; j++) { // we are starting from j = 1 as j = 0 corresponds to newx

        nny[j] = y[nnIdx[j]];

        // Computing unit vector associated with the j-th NN of newx
        L2norm = 0;
        for (int l = 0; l < ncX; l++) {
            nnu[l] = X[nnIdx[j] + nrX * l] - newx[l];
            L2norm += nnu[l] * nnu[l];
        }
        L2norm = sqrt(L2norm);

        if ( L2norm == 0 )
            continue;

        for (int l = 0; l < ncX; l++)
            nnu[l] /= L2norm;

        // Computing the cosine angle between nnu and prev_grady
        cos_angle = 0;
        for ( int l = 0; l < ncX; l++ )
            cos_angle += prev_grady[l] * nnu[l];

        if ( cos_angle > cos_angle_thld && nny[j] > nny[0]) {
            found_nn_pointing_in_dir_ugrady = 1;
            for ( int l = 0; l < ncX; l++ )
                trajectory.push_back(newx[l]);
            break;
        }
    }

    if ( found_nn_pointing_in_dir_ugrady == 0 ) {

        for ( int l = 0; l < ncX; l++ )
            newx[l] = x[l];

        // Finding NN whose nnu unit vector has the smallest angle  with prev_grady <=> the largest cosine of the angle
        double max_cos_angle = -1;
        int i_max_cos_angle = 0;
        for (int j = 1; j < k; j++) { // we are starting from j = 1 as j = 0 corresponds to newx

            // Computing unit vector associated with the j-th NN of newx
            L2norm = 0;
            for (int l = 0; l < ncX; l++) {
                nnu[l] = X[x_nnIdx[j] + nrX * l] - newx[l];
                L2norm += nnu[l] * nnu[l];
            }
            L2norm = sqrt(L2norm);

            if ( L2norm == 0 )
                continue;

            for (int l = 0; l < ncX; l++)
                nnu[l] /= L2norm;

            // Computing the cosine angle between nnu and prev_grady
            cos_angle = 0;
            for ( int l = 0; l < ncX; l++ )
                cos_angle += prev_grady[l] * nnu[l];

            if ( cos_angle > max_cos_angle ) {
                max_cos_angle = cos_angle;
                i_max_cos_angle = j;
            }
        }

        // Settting newx to be the NN with max cos angle with prev_grady
        for ( int l = 0; l < ncX; l++ ) {
            newx[l] = X[x_nnIdx[i_max_cos_angle] + nrX * l];
            trajectory.push_back(newx[l]);
        }

        kdTree->annkSearch(newx, k, nnIdx, nnDist, 0);

        found_nn_pointing_in_dir_ugrady = 1;
    }

    #if DEBUG_S_gf_lm_trajectory
    Rprintf("found_nn_pointing_in_dir_ugrady: %d\n", found_nn_pointing_in_dir_ugrady);

    Rprintf("dist normalized grady:\n");
    print_double_array_with_precision(grady, ncX, 8);

    Rprintf("newx:\n");
    print_double_array_with_precision(newx, ncX, 8);

    //error("Stopping function execution for debugging purposes.");
    #endif


    // -------------------------------------------------------------------------
    //
    // Finding the remaining points of the trajectory
    //
    // -------------------------------------------------------------------------

    double ipr = 0;
    double scale = 1;
    #if DEBUG_S_gf_lm_trajectory
    int itr = 0;
    #endif
    while ( found_nn_pointing_in_dir_ugrady && ndiv < div_thld ) {

        #if DEBUG_S_gf_lm_trajectory
        Rprintf("itr: %d\n", itr);
        itr++;
        //if ( itr > 100 )
        //    error("Stopping function execution for debugging purposes.");
        #endif

        // Finding kNN of newx among the points of X
        // kdTree->annkSearch(newx, k, nnIdx, nnDist, 0);

        // Fitting a linear model, nny ~ nnX, where nny and nnX are restrictions of y and X to these kNN's
        // Restricting X and y to the k-NN's of the given point - the i-th point of X
        for (int j = 0; j < k; j++) {
            nny[j] = y[nnIdx[j]];
            for (int l = 0; l < ncX; l++) {
                nnX[j + k * l] = X[nnIdx[j] + nrX * l];
            }
        }

        // Finding coordinates (beta) of a Solving nny ~ nnX linear equation
        C_flm(nnX, nny, &k, &ncX, beta);

        // Gradient estimate of y at the current point are the coefficients of the model excluding the y-intercept
        grady = beta + 1;

        // Computing L2 norm of grady
        L2norm = 0;
        for ( int l = 0; l < ncX; l++ )
            L2norm += grady[l] * grady[l];
        L2norm = sqrt(L2norm);

        if (L2norm == 0) {
            ndiv = div_thld; // it looks like the point is a local maximum; no need to look for points of the gradient flow trajectory - we have already arrived at the local maximum
            break;
        } else {
            // Normalizing grad(y) making it a unit vector
            for ( int l = 0; l < ncX; l++ )
                grady[l] /= L2norm;
        }

        // Computing the inner product between the current and previews
        // grady to check if the new grady points in the same direction
        // as the previous one
        ipr = 0;
        for ( int l = 0; l < ncX; l++ )
            ipr += prev_grady[l] * grady[l];

        if ( ipr < 0 ) { // detected a change in the direction of the gradient vector, so we decrease the step size by a factor of scalef
            scale *= scalef;
            //Rprintf("i: %d  ndiv: %d\n", i, ndiv);
            ndiv++;
        }

        // Copying the content of unit grady to prev_grady
        std::copy(grady, grady + ncX, prev_grady.begin());

        // Turning grady into a step vector defined to be the grady
        // normalized to have the length equal to the distance to the k-th nearest neighbor
        for ( int l = 0; l < ncX; l++ )
            grady[l] *= scale * sqrt(nnDist[k-1]);

        // The first point of the trajectory after the initial point is (initial point) + grady
        for ( int l = 0; l < ncX; l++ ) {
            x[l] = newx[l];
            newx[l] += grady[l];
        }

        // Copy nnIdx to x_nnIdx
        std::copy(nnIdx, nnIdx + k, x_nnIdx);
        // Copy nnDist to x_nnDist
        std::copy(nnDist, nnDist + k, x_nnDist);

        // In order for newx to be accepted as a new point of the trajectory, at
        // least one of the kNN's of newx has to be pointing approximately in
        // the same direction as grady

        // Finding kNN of newx
        kdTree->annkSearch(newx, k, nnIdx, nnDist, 0);

        // For each NN, x_j, of newx computing the cosine of angle between x_j:newx and prev_grady
        found_nn_pointing_in_dir_ugrady = 0;
        for (int j = 1; j < k; j++) { // we are starting from j = 1 as j = 0 corresponds to newx

            // Computing unit vector associated with the j-th NN of newx
            L2norm = 0;
            for (int l = 0; l < ncX; l++) {
                nnu[l] = X[nnIdx[j] + nrX * l] - newx[l];
                L2norm += nnu[l] * nnu[l];
            }
            L2norm = sqrt(L2norm);

            if ( L2norm == 0 )
                continue;

            for (int l = 0; l < ncX; l++)
                nnu[l] /= L2norm;

            // Computing the cosine angle between nnu and prev_grady
            cos_angle = 0;
            for ( int l = 0; l < ncX; l++ )
                cos_angle += prev_grady[l] * nnu[l];

            if ( cos_angle > cos_angle_thld ) {
                found_nn_pointing_in_dir_ugrady = 1;
                for ( int l = 0; l < ncX; l++ )
                    trajectory.push_back(newx[l]);
                break;
            }
        }

        if ( found_nn_pointing_in_dir_ugrady == 0 ) {
            for ( int l = 0; l < ncX; l++ )
                newx[l] = x[l];

            // Finding NN whose nnu unit vector has the smallest angle  with prev_grady <=> the largest cosine of the angle
            double max_cos_angle = -1;
            int i_max_cos_angle = 0;
            for (int j = 1; j < k; j++) { // we are starting from j = 1 as j = 0 corresponds to newx

                // Computing unit vector associated with the j-th NN of newx
                L2norm = 0;
                for (int l = 0; l < ncX; l++) {
                    nnu[l] = X[x_nnIdx[j] + nrX * l] - newx[l];
                    L2norm += nnu[l] * nnu[l];
                }
                L2norm = sqrt(L2norm);

                if ( L2norm == 0 )
                    continue;

                for (int l = 0; l < ncX; l++)
                    nnu[l] /= L2norm;

                // Computing the cosine angle between nnu and prev_grady
                cos_angle = 0;
                for ( int l = 0; l < ncX; l++ )
                    cos_angle += prev_grady[l] * nnu[l];

                if ( cos_angle > max_cos_angle ) {
                    max_cos_angle = cos_angle;
                    i_max_cos_angle = j;
                }
            }

            // Settting newx to be the NN with max cos angle with prev_grady
            for ( int l = 0; l < ncX; l++ ) {
                newx[l] = X[x_nnIdx[i_max_cos_angle] + nrX * l];
                trajectory.push_back(newx[l]);
            }

            kdTree->annkSearch(newx, k, nnIdx, nnDist, 0);

            found_nn_pointing_in_dir_ugrady = 1;
        }

    } // END OF while ( ndiv < div_thld )

    free(nnX);
    free(nny);
    free(nnu);
    free(beta);

    delete[] nnIdx;
    delete[] nnDist;
    delete[] x_nnIdx;
    delete[] x_nnDist;

    res->trajectory = std::move(trajectory);
    // Copying newx to res->lmax
    for (int l = 0; l < ncX; l++) {
        res->lmax[l] = newx[l];
    }

    annDeallocPt(x);
    annDeallocPt(newx);

    UNPROTECT(nprot);

    return res;
}

extern "C" {

    /*!
       Estimates gradient flow trajectories for all points of the given state space; A version with Rsubset parameter !!!

       \param RX             The data matrix.
       \param Ry             The response variable.
       \param Rk             The number of nearest neighbors to use for the estimate of the trajectory.
       \param Rscalef        The scaling factor for the step in the mean shift algorithm.
       \param RdivThld       The number of times the step in the mean shift algorithm is scaled. The algorithm terminates after that many scaling events.
       \param RcosAngleThld  The threshold of the cosine of the angle between the current gradient and then direction vectors of then kNN's of the candidate trajectory point.
       \param Rsubset        A vector of indices of X for which the trajectories are to be found.

       \return Returns a list with two components 1) a list of trajectoris for all points of X 2) A matrix local maximum associated with all point of X
    */
    SEXP S_gf_lm_trajs(SEXP RX,
                       SEXP Ry,
                       SEXP Rk,
                       SEXP Rscalef,
                       SEXP RdivThld,
                       SEXP RcosAngleThld,
                       SEXP Rsubset) {

        #define DEBUG_S_gf_lm_trajs 0

        int nprot = 0;
        PROTECT(RX = coerceVector(RX, REALSXP)); ++nprot;
        PROTECT(Ry = coerceVector(Ry, REALSXP)); ++nprot;
        PROTECT(Rk = coerceVector(Rk, INTSXP)); ++nprot;
        PROTECT(Rscalef = coerceVector(Rscalef, REALSXP)); ++nprot;
        PROTECT(RdivThld = coerceVector(RdivThld, REALSXP)); ++nprot;

        // Check if Rsubset is provided and coerce it to integer vector
        int *subset = NULL;
        int subsetLength = 0;
        if (Rsubset != R_NilValue) {
            PROTECT(Rsubset = coerceVector(Rsubset, INTSXP)); ++nprot;
            subset = INTEGER(Rsubset);
            subsetLength = LENGTH(Rsubset);
        }

        double *X = REAL(RX);
        int *dimX = INTEGER(getAttrib(RX, R_DimSymbol));
        int nrX = dimX[0];
        int ncX = dimX[1];

        ANNpointArray dataPts = annAllocPts(nrX, ncX);
        for (int i = 0; i < nrX; i++) {
            for (int j = 0; j < ncX; j++) {
                dataPts[i][j] = X[i + nrX * j];
            }
        }

        #if DEBUG_S_gf_lm_trajs
        Rprintf("S_gf_lm_trajs(): nrX: %d  ncX: %d\n", nrX, ncX);
        #endif

        ANNkd_tree *kdTree = new ANNkd_tree(dataPts, nrX, ncX);

        // Determine the size of the trajectory list based on Rsubset
        int n_trajectories = (subset != NULL) ? subsetLength : nrX;
        SEXP trajectories_Rlist = PROTECT(allocVector(VECSXP, n_trajectories)); ++nprot;
        SEXP lmax_Rmatrix = PROTECT(allocMatrix(REALSXP, n_trajectories, ncX)); ++nprot;

        #if DEBUG_S_gf_lm_trajs
        Rprintf("n_trajectories: %d\n", n_trajectories);
        #endif

        for (int i = 0; i < n_trajectories; i++) {
            int index = (subset != NULL) ? subset[i] - 1 : i;

            // Check if the index is within valid range
            if (index < 0 || index >= nrX) {
                error("Invalid index in Rsubset");
            }

            #if DEBUG_S_gf_lm_trajs
            Rprintf("i: %d  index: %d\n", i, index);
            #endif

            std::unique_ptr<TrajectoryResult> tr_res = S_gf_lm_trajectory(index,
                                                                          kdTree,
                                                                          dataPts,
                                                                          RX,
                                                                          Ry,
                                                                          Rk,
                                                                          Rscalef,
                                                                          RdivThld,
                                                                          RcosAngleThld);

            // Calculate dimensions for trajectory matrix
            size_t n_pts_in_trajectory = tr_res->trajectory.size() / ncX;                      // number of points in trajectory
            SEXP trajectory_Rmatrix = PROTECT(allocMatrix(REALSXP, n_pts_in_trajectory, ncX)); // n_pts_in_trajectory-by-ncX matrix
            for (size_t row = 0; row < n_pts_in_trajectory; row++) {
                for (int col = 0; col < ncX; col++) {
                    // Fill the matrix; note the 1D indexing of tr_res->trajectory
                    REAL(trajectory_Rmatrix)[row + n_pts_in_trajectory * col] = tr_res->trajectory[row * ncX + col];
                }
            }

            SET_VECTOR_ELT(trajectories_Rlist, i, trajectory_Rmatrix);
            UNPROTECT(1); // Unprotect trajectory_Rmatrix

            for (int j = 0; j < ncX; j++) {
                REAL(lmax_Rmatrix)[i + n_trajectories * j] = tr_res->lmax[j];
            }
        }

        // Free memory allocated by ANN
        delete kdTree;
        annDeallocPts(dataPts);

        SEXP result = PROTECT(allocVector(VECSXP, 2)); ++nprot;
        SET_VECTOR_ELT(result, 0, trajectories_Rlist);
        SET_VECTOR_ELT(result, 1, lmax_Rmatrix);

        SEXP names = PROTECT(allocVector(STRSXP, 2)); ++nprot;
        SET_STRING_ELT(names, 0, mkChar("trajectories"));
        SET_STRING_ELT(names, 1, mkChar("lmax"));
        setAttrib(result, R_NamesSymbol, names);

        UNPROTECT(nprot);

        return result;
    }
}
