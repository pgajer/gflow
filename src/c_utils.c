
#include <R.h>
#include <Rinternals.h>
#include <Rdefines.h>
#include <Rmath.h>

#include <stdlib.h>
#include <math.h>

#include "msr2.h"

/*!
  Converts a double to a string representation with a given number of significant digits.

  \param x      The double value to convert.
  \param digits The number of significant digits to keep.
  \param x_str  The output string. The caller is responsible for freeing this memory.
*/
void signif(double x, int digits, char **x_str) {
    // Special case for zero
    if (x == 0.0) {
        *x_str = (char*) malloc(2 * sizeof(char));
        (*x_str)[0] = '0';
        (*x_str)[1] = '\0';
        return;
    }

    // Calculate the exponent for scientific notation
    int exponent = (int) floor(log10(fabs(x)));

    // Calculate the number of decimal places needed
    int decimal_places = digits - exponent - 1;

    // Special handling for numbers that don't need a decimal part
    if (decimal_places <= 0) {
        decimal_places = 0;
    }

    // Allocate memory for the output string
    // Maximum needed length = digits + 1 for '.' + 1 for 'e' + 1 for sign + 4 for exponent + 1 for null terminator
    *x_str = (char*) malloc((digits + 7) * sizeof(char));

    // Generate the formatted string
    snprintf(*x_str, digits + 7, "%.*e", decimal_places, x);
}

/*!
  Allocates memory for a double array of length n.

  \param n    The number of elements the array suppose to hold.
  \param type A character indicating whether to call malloc or calloc.
*/
double* create_double_array(int n, const char *type) {
  double *x;

  if (strcmp(type, "m") == 0) {
    x = malloc(n * sizeof(double));
  } else {
    x = calloc(n, sizeof(double));
  }

  // Check if the memory allocation succeeded
  CHECK_PTR(x);

  return x;
}

/*!
  Allocates memory for an int array of length n.

  \param n    The number of elements the array suppose to hold.
  \param type A character indicating whether to call malloc or calloc.
*/
int* create_int_array(int n, const char *type) {
  int *x;

  // Using strcmp for string comparison
  if (strcmp(type, "m") == 0) {
    x = malloc(n * sizeof(int));
  } else {
    x = calloc(n, sizeof(int));
  }

  // Check if the memory allocation succeeded
  CHECK_PTR(x);

  return x;
}

/*
  Testing the code for counting the number of unique elements in a double array

  Code generated by chatGTP

  \param arr   A double array.
  \param size  The size of the array.
*/
int unique_count(const double *arr, int size)
{
    int unique_count = 0;
    for (int i = 0; i < size; i++)
      {
        int unique = 1;
        for (int j = i + 1; j < size; j++)
          {
            if (arr[i] == arr[j])
              {
                unique = 0;
                break;
            }
        }
        if (unique) unique_count++;
    }
    return unique_count;
}

/*
  Min-Max normalization of a double array

  \param x   A double array of size n.
  \param n   The size of x.
  \param xmm Min-max normalized x.

  The routine returns the min max normalized x.
*/
void min_max_norm(const double *x, const int n, double *xmm)
{
    // finding the minimum and maximum of x
    double xmin = x[0], xmax = x[0];
    for ( int i = 1; i < n; i++ )
    {
      if ( x[i] < xmin ) xmin = x[i];
      else if ( x[i] > xmax ) xmax = x[i];
    }

    xmax -= xmin;
    for ( int i = 0; i < n; i++ )
      xmm[i] = (x[i] - xmin) / xmax;
}

/*
  Box-Cox tranform

  \param x       A double array of size n.
  \param rn      A reference to the size of x.
  \param rlambda A reference to the lambda parameter of the Box-Cox transform. If lambda is set
                 to any number less than 0, lambda will be determined as 1 over -log(x[x>0]).
  \param bcx     The Box-Cox transform of x.
*/
void C_BoxCox(const double *x, const int *rn, double *rlambda, double *bcx)
{
    double lambda = rlambda[0];
    int n = rn[0];

    if ( lambda < 0 )
    {
      double min_logx = 0;
      for ( int i = 0; i < n; i++ )
      {
        if ( x[i] > 0 && log(x[i]) < min_logx )
          min_logx = log(x[i]);
      }

      lambda = -1.0 / min_logx;
      *rlambda = lambda;
    }

    double inv_lambda = 1 / lambda;
    for ( int i = 0; i < n; i++ )
    {
      if ( x[i] > 0 )
        bcx[i] = inv_lambda * ( pow(x[i], lambda) - 1 );
      else
        bcx[i] = 0;
    }
}


/* Helper function to sort int arrays */
int cmp_int(const void *a, const void *b) {
    int int_a = *((int*)a);
    int int_b = *((int*)b);

    if (int_a < int_b) return -1;
    if (int_a > int_b) return 1;
    return 0;
}

/* Helper function to sort double arrays */
void sort_int_array(int *arr, int len) {
    qsort(arr, len, sizeof(int), cmp_int);
}


/**
 * @brief Comparison function for sorting double values.
 *
 * This function is designed to be used with qsort() for sorting an array of doubles
 * in ascending order. It compares two double values pointed to by the input parameters.
 *
 * @param a Pointer to the first double to compare.
 * @param b Pointer to the second double to compare.
 * @return int
 *         -1 if *a is less than *b,
 *          0 if *a is equal to *b,
 *          1 if *a is greater than *b.
 *
 * @note This function uses a small epsilon value to handle potential floating-point
 *       precision issues when comparing doubles.
 */
int cmp_double(const void *a, const void *b) {
    const double epsilon = 1e-8;  // Small value to account for floating-point precision
    double diff = *(const double *)a - *(const double *)b;
    if (fabs(diff) < epsilon) return 0;  // Consider very small differences as equal
    return (diff < 0) ? -1 : 1;
}

// old version
#if 0
int cmp_double(const void *a, const void *b) {
    double diff = *(double *)a - *(double *)b;
    if (diff < 0) return -1;
    if (diff > 0) return 1;
    return 0;
}
#endif

/* Helper function to sort double arrays */
void sort_double_array(double *arr, int len) {
    qsort(arr, len, sizeof(double), cmp_double);
}

/*!
  \brief Implementation of binary search to find the index `i` in a sorted
  array `x`. It finds the index `i` in a sorted array such that `x[i] <= L` and
  `L < x[i+1]`.

  Given a sorted double array `x` of length `n` and a double value `L`, this function
  returns the index `i` such that `x[i] <= L` and `L < x[i+1]`. If `L` is less than
  the first element of `x`, the function returns `-1`. If `L` is greater than or
  equal to the last element of `x`, it returns `n`. In the case where multiple
  consecutive elements have the same value as `L` (i.e., `x[i] = x[i + 1] = L`),
  the function returns the largest index among them.

  The function leverages a binary search algorithm, making it efficient for
  large arrays with a worst-case time complexity of O(log n).

  \param [in] x Pointer to the sorted double array.
  \param [in] n Integer representing the length of the array `x`.
  \param [in] L Double value to compare against elements in `x`.

  \return Index `i` in the array `x` that meets the conditions. Returns `-1` if `L` is
  less than the first element and `n` if `L` is greater than or equal to the last element.
*/
int find_index(const double* x, int n, double L) {

    int left = 0, right = n - 1;

    // Check edge cases
    if (L < x[0]) return -1;
    if (L > x[n - 1]) return n;

    while (left <= right) {
        int mid = left + (right - left) / 2;

        if (x[mid] <= L) {
            // Check the equality scenario for x[mid] = x[mid+1]
            if (x[mid] == L && mid < n - 1 && x[mid + 1] == L) {
                while (mid < n - 1 && x[mid + 1] == L) {
                    mid++;
                }
                return mid;
            }
            // Standard binary search continuation
            if (L < x[mid + 1]) return mid;
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return -1;  // Shouldn't reach this point given the input conditions, but added for completeness.
}
