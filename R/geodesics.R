##
## Geodesics-related functions
##

#' Computes the inverse of a permutation vector generated by order()
#'
#' @param o A permutation vector generated by order().
#'
#' @return A numeric vector representing the inverse permutation, where element i
#'   contains the position of i in the original ordering vector o.
#'
#' @examples
#' x <- c(3, 1, 4, 2)
#' o <- order(x)  # Returns c(2, 4, 1, 3)
#' o.inv <- o.inv.fn(o)  # Returns c(3, 1, 4, 2)
#' # Verify: x[o][o.inv] equals x
#'
#' @export
o.inv.fn <- function(o)
{
    n <- length(o)
    o.inv <- numeric(n)
    for ( i in seq(n) )
    {
        o.inv[o[i]] <- i
    }

    o.inv
}

#' Produces k-NN distance and index matrices associated with a distance matrix.
#'
#' @param d   A distance matrix.
#' @param k   The number of nearest neighbors.
#'
#' @return A list containing two matrices:
#'   \item{nn.i}{An n x k matrix where element \code{[i,j]} contains the index of the j-th
#'               nearest neighbor of point i.}
#'   \item{nn.d}{An n x k matrix where element \code{[i,j]} contains the distance to the j-th
#'               nearest neighbor of point i.}
#'
#' @details
#' For each point (row) in the distance matrix, this function identifies the k nearest
#' neighbors and their corresponding distances. The neighbors are ordered from closest
#' to farthest.
#'
#' @examples
#' # Create a simple distance matrix
#' d <- as.matrix(dist(matrix(rnorm(20), ncol=2)))
#' knn_result <- dist.to.knn(d, k=3)
#' # knn_result$nn.i contains indices of 3 nearest neighbors for each point
#' # knn_result$nn.d contains distances to those neighbors
#'
#' @export
dist.to.knn <- function(d, k)
{
    stopifnot(isSymmetric(d))

    n <- nrow(d)
    nn.i <- matrix(0,nrow=n, ncol=k)
    nn.d <- matrix(0,nrow=n, ncol=k)
    for ( i in seq(n) )
    {
        x <- as.numeric(d[i,])
        o <- order(x)
        nn.i[i,] <- o[seq(k)]
        nn.d[i,] <- x[o[seq(k)]]
    }

    list(nn.i=nn.i,
         nn.d=nn.d)
}

#' Distances from the first vertex of a path to each consecutive vertex along
#' the given path normalized so that the total distance is 1.
#'
#' @param s        A sequences of vertex indices of the graph - the path.
#' @param V        A vertex positions matrix.
#' @param edge.col A color of the edges.
#'
#' @return A numeric vector of length equal to the path length, containing the
#'     cumulative distances from the first vertex to each vertex along the path,
#'     normalized to the range \eqn{[0, 1]}. The first element is always 0 and
#'     the last element is always 1.
#'
#' @details
#' This function calculates the cumulative Euclidean distances along a path defined
#' by a sequence of vertex indices. The distances are then normalized by the total
#' path length so that the result represents relative positions along the path.
#'
#' @note The parameter edge.col is currently not used in the function implementation.
#'
#' @examples
#' # Create a simple vertex matrix
#' V <- matrix(c(0,0, 1,0, 1,1, 0,1), ncol=2, byrow=TRUE)
#' path <- c(1, 2, 3, 4)
#' distances <- path.dist(path, V)
#' # distances will be c(0.0, 0.333..., 0.666..., 1.0)
#'
#' @export
path.dist <- function(s, V, edge.col="gray")
{
    n <- length(s)
    d <- numeric(n)
    for ( i in 2:n )
    {
        M <- rbind(V[s[i-1],], V[s[i],])
        # Convert dist object to numeric vector and extract the single distance value
        d[i] <- d[i - 1] + as.numeric(dist(M))
    }
    d / d[n]
}

#' Computes the length of a path specified by a matrix X.
#'
#' @param X A matrix of points along a path.
#'
#' @return A numeric value representing the total Euclidean length of the path
#'   defined by consecutive points in X.
#'
#' @details
#' This function calculates the total path length by summing the Euclidean distances
#' between consecutive points (rows) in the matrix X. Each row of X represents a
#' point in the path, and columns represent dimensions.
#'
#' @examples
#' # Create a simple path in 2D
#' path_points <- matrix(c(0,0, 1,0, 1,1, 0,1), ncol=2, byrow=TRUE)
#' length <- path.length(path_points)
#' # length will be 3 (three unit-length segments)
#'
#' # 3D path example
#' path_3d <- matrix(c(0,0,0, 1,0,0, 1,1,0, 1,1,1), ncol=3, byrow=TRUE)
#' length_3d <- path.length(path_3d)
#'
#' @export
path.length <- function(X)
{
    stopifnot(is.numeric(X))
    stopifnot(is.finite(X))
    nrX <- nrow(X)

    path.len <- 0
    for ( i in 2:nrX ) {
        path.len <- path.len + sqrt( sum ( (X[i,] - X[i-1,])^2 ) )
    }

    path.len
}

#' Smooths a piece-wise linear (PL) geodesic path
#'
#' @param S          A state space.
#' @param path.vs    A vector of indices of S constituting an geodesic path.
#' @param min.vs     The minimum number of vertices in path.vs for which a smoothing can be done. If |path.vs| < min.vs, then approx() is used to generate adj.n.vs vertices.
#' @param adj.n.vs   The number of vertices that is being created as the input for fb.magelo() in case |path.vs| < min.vs.
#' @param grid.size  The number of grid points; A parameter passed to magelo().
#' @param bw         The bandwidth of fb.magelo().
#' @param fb.C       The number of bw's away from the boundary points of the domain of x that the adjusting of Eyg will take place, so that Eyg satisfies the boundary condition.
#'
#' @return A matrix representing the smoothed geodesic path with grid.size rows and
#'   the same number of columns as the state space S. Each row contains the coordinates
#'   of a point along the smoothed path.
#'
#' @details
#' This function takes a piecewise linear geodesic path defined by vertex indices and
#' produces a smooth version using local linear regression. If the input path has fewer
#' than min.vs vertices, it first interpolates to create adj.n.vs points before smoothing.
#' The smoothing is performed separately for each dimension of the state space.
#'
#' @export
smooth.PL.geodesic <- function(S,
                              path.vs,
                              min.vs = 10,
                              adj.n.vs = 50,
                              grid.size = 200,
                              bw = grid.size * 3/200,
                              fb.C = 3)
{
    Epath <- c()
    X <- S[path.vs,]
    nrX <- nrow(X)

    if ( nrX < min.vs )
    {
        t <- seq(0, 1, length.out = nrX)
        x <- seq(0, 1, length.out = adj.n.vs)
        Y <- matrix(nrow = adj.n.vs, ncol = ncol(S))
        for ( i in seq(ncol(S)) ) {
            Y[,i] <- approx(t, X[,i], xout = x)$y
        }

        smooth.PL.geodesic(S, as.numeric(rownames(Y)), min.vs = min.vs, adj.n.vs = adj.n.vs, grid.size = grid.size, bw = bw, fb.C = fb.C)
    }
    else
    {
        t <- seq(0,1,length.out=nrX)
        xg <- seq(0,1,length.out=grid.size)
        for ( i in seq(ncol(S)) )
        {
            y <- X[,i]
            res <- fb.magelo(x = t, y = y, bw = bw, C = fb.C)
            Epath <- cbind(Epath, res$Eyg)
        }

        ##t <- seq(0,1,length.out=nrX)
        ##xg <- seq(0,1,length.out=grid.size)
        ##for ( i in seq(ncol(S)) )
        ##{
        ##    y <- X[,i]
        ##    res <- smooth.spline(x=t, y=y, df=NULL, spar=NULL, cv=NA, all.knots=FALSE, nknots=NULL)
        ##    fitted.y <- predict(res, xg)$y
        ##    Epath <- cbind(Epath, fitted.y)
        ##}

        Epath
    }
}

#' Function to calculate the Euclidean distance between two points
#'
#' @param p1 First point.
#' @param p2 Second point.
#'
#' @return A numeric value representing the Euclidean distance between p1 and p2.
#'
#' @details This function computes the Euclidean distance between two points in
#'     n-dimensional space using the formula: \eqn{\sqrt(\sum((p1 - p2)^2))}.
#'     The points \eqn{p1} and \eqn{p2} should be numeric vectors of the same
#'     length.
#'
#' @examples
#' # Distance between two 2D points
#' point1 <- c(0, 0)
#' point2 <- c(3, 4)
#' euclidean.distance(point1, point2)  # Returns 5
#'
#' # Distance between two 3D points
#' point1 <- c(1, 2, 3)
#' point2 <- c(4, 6, 8)
#' euclidean.distance(point1, point2)  # Returns sqrt(50)
#'
#' @export
euclidean.distance <- function(p1, p2)
{
  return(sqrt(sum((p1 - p2) ^ 2)))
}

#' Subdivides a path of points in \eqn{R^n} into a uniform grid of points along
#' the path.
#'
#' @param path               A matrix of consecutive path points in some state space.
#' @param n.subdivision.pts  The number of points in the grid.
#'
#' @return A matrix with n.subdivision.pts rows and the same number of columns as the
#'   input path. Each row represents a point along the subdivided path, with points
#'   evenly spaced according to the path's arc length.
#'
#' @details
#' This function takes a path defined by consecutive points and creates a new set of
#' points that are uniformly distributed along the path's arc length. The subdivision
#' is based on the cumulative Euclidean distances between consecutive points, ensuring
#' that the output points are evenly spaced along the actual path length rather than
#' just parametrically.
#'
#' The first point of the output will be the first point of the input path, and the
#' last point of the output will be the last point of the input path.
#'
#' @examples
#' # Create a simple 2D path
#' path <- matrix(c(0,0, 1,0, 2,1, 3,1), ncol=2, byrow=TRUE)
#' # Subdivide into 10 evenly spaced points
#' subdivided <- subdivide.path(path, 10)
#'
#' @export
subdivide.path <- function(path, n.subdivision.pts)
{
    n.pts <- dim(path)[1]
    edge.lengths <- sapply(seq(n.pts - 1), function(i) euclidean.distance(path[i,], path[i + 1,]))
    total.length <- sum(edge.lengths)
    subdiv.dist <- total.length / (n.subdivision.pts - 1)

    subdivision.pts <- matrix(nrow = n.subdivision.pts, ncol = ncol(path))

    start.offset <- 0           # When we reach edge.subdivision.dist:
                               # edge.subdivision.dist >= edge.length:
                               # start.offset <- edge.subdivision.dist - edge.length. Thus, start.offset is the distance from path[path.pt,], along the edge, of the first point on the new edge
                               # from which we start the process; Thus,
                               # path[path.pt,] is set to the points
                               # start.offset away from path[path.pt,] along he
                               # edge.
    edge.subdivision.dist <- start.offset
    subdivision.ix <- 1
    path.pt <- 1

    # This is the loop over edges of the path. If path.pt < (n.pts - 1), we
    # haven't reached the last edge (path.pt = n.pts - 1).
    while ( path.pt < n.pts )
    {
        edge.subdivision.dist <- edge.subdivision.dist + subdiv.dist

        while ( edge.subdivision.dist <= edge.lengths[path.pt] )
        {
            # If the subdivision point is within the current edge, we find the appropriate point along the edge
            if ( edge.subdivision.dist > 0 ) {
                v <- path[path.pt + 1,] - path[path.pt,]
                unit.v <- v / sqrt(sum(v^2))
                subdivision.pts[subdivision.ix,] <- path[path.pt,] + edge.subdivision.dist * unit.v
            } else {
                subdivision.pts[subdivision.ix,] <- path[path.pt,]
            }

            subdivision.ix <- subdivision.ix + 1
            edge.subdivision.dist <- edge.subdivision.dist + subdiv.dist
        }

        # We are past the current edge
        start.offset <- edge.subdivision.dist - edge.lengths[path.pt]
        edge.subdivision.dist <- start.offset
        path.pt <- path.pt + 1
    }

    # Add the last point
    subdivision.pts[n.subdivision.pts,] <- path[n.pts,]

    subdivision.pts
}

#' Subdivides a path of points in \eqn{R^n} into a uniform grid of points along the path.
#'
#' @param path               A matrix of consecutive path points in some state space.
#' @param n.subdivision.pts  The number of points in the grid.
#'
#' @return A matrix with n.subdivision.pts rows and the same number of columns as the
#'   input path. Each row represents a point along the subdivided path, with points
#'   evenly spaced according to the path's arc length.
#'
#' @details
#' This is version 1 of the path subdivision algorithm. Like subdivide.path, it creates
#' a set of points uniformly distributed along the path's arc length. The implementation
#' differs slightly in the algorithm used but produces similar results.
#'
#' @note This appears to be an alternative implementation of subdivide.path. Consider
#'   using subdivide.path unless there's a specific reason to use this version.
#'
#' @seealso \code{\link{subdivide.path}} for the primary implementation
#'
#' @export
subdivide.path.v1 <- function(path, n.subdivision.pts)
{
    n.pts <- dim(path)[1]
    edge.lengths <- sapply(seq(n.pts - 1), function(i) euclidean.distance(path[i,], path[i + 1,]))
    total.length <- sum(edge.lengths)
    subdiv.dist <- total.length / (n.subdivision.pts - 1)

    subdivision.pts <- matrix(nrow = n.subdivision.pts, ncol = ncol(path))

    path.pt <- 1                # the current path pooint
    edge.subdivision.dist <- 0  # the distance from the initial vertex of the given edge to the next subdivision point of the current edge

    start.offset <- 0           # When we reach edge.subdivision.dist:
                               # edge.subdivision.dist >= edge.length:
                               # start.offset <- edge.subdivision.dist - edge.length. Thus, start.offset is the distance from path[path.pt,], along the edge, of the first point on the new edge
                               # from which we start the process; Thus,
                               # path[path.pt,] is set to the points
                               # start.offset away from path[path.pt,] along he
                               # edge.

    for ( subdivision.ix in seq(n.subdivision.pts - 1) )
    {
        edge.subdivision.dist <- edge.subdivision.dist + subdiv.dist

        # If the subdivision point is past the current edge, we switch to the next edge
        while ( path.pt < (n.pts - 1) && edge.subdivision.dist > edge.lengths[path.pt] )
        {
            edge.subdivision.dist <- edge.subdivision.dist - edge.lengths[path.pt]
            path.pt <- path.pt + 1
        }

        # If the subdivision point is within the current edge, we find the appropriate point along the edge
        if ( edge.subdivision.dist > 0 ) {
            v <- path[path.pt + 1,] - path[path.pt,]
            unit.v <- v / sqrt(sum(v^2))
            subdivision.pts[subdivision.ix,] <- path[path.pt,] + edge.subdivision.dist * unit.v
        } else {
            subdivision.pts[subdivision.ix,] <- path[path.pt,]
        }
    }

    subdivision.pts[n.subdivision.pts,] <- path[n.pts,]
    subdivision.pts
}

#' Creates a tubular neighborhood of a geodesic
#'
#' @param smoothed.geodesic   A matrix of smoothed geodesic points in S.
#' @param S                   A 3d model of a state space.
#' @param d.thld              A distance to the geodesic threshold. Set to 'auto' for automatic determination of the threshold.
#' @param dist.to.geodesic.q  The quantile of the distances to the geodesic to which the density function of the distances will be restricted to.
#'
#' @return A list containing:
#'   \item{nn.i}{A vector of indices indicating the nearest point on the geodesic for each point in S.}
#'   \item{dist.to.geodesic}{A vector of distances from each point in S to the geodesic.}
#'   \item{strand.i}{Indices of points in S that are within the tubular neighborhood.}
#'   \item{strand}{The subset of S containing only points within the tubular neighborhood.}
#'   \item{nn.geodesic.vertex.i}{Indices of the nearest geodesic vertices for points in the strand.}
#'   \item{dist.along.strand.geodesic}{Normalized distances along the geodesic for points in the strand.}
#'   \item{d.thld}{The distance threshold used to define the tubular neighborhood.}
#'
#' @details
#' This function creates a tubular neighborhood around a geodesic path by identifying
#' all points in the state space S that are within a specified distance threshold of
#' the geodesic. When d.thld is set to "auto", the threshold is determined based on
#' the distribution of distances to the geodesic.
#'
#' @export
create.tubular.nbhd.of.a.geodesic <- function(smoothed.geodesic,
                                             S,
                                             d.thld="auto",
                                             dist.to.geodesic.q=0.25)
{
    nn <- get.knnx(smoothed.geodesic, S, k=1)
    nn.i <- nn$nn.index[,1]
    names(nn.i) <- rownames(S)

    dist.to.geodesic <- nn$nn.dist[,1]
    names(dist.to.geodesic) <- rownames(S)

    S.quantile.dist <- quantile(dist.to.geodesic, probs=dist.to.geodesic.q)

    if ( d.thld == "auto" ) {
        d.thld <- min(dist.to.geodesic[dist.to.geodesic > quantile(dist.to.geodesic, probs=0.05)])
    }

    strand.i <- which(dist.to.geodesic < d.thld)
    strand.i <- as.numeric(names(strand.i))
    strand <- S[strand.i,]

    nn.geodesic.vertex.i <- nn.i[strand.i]

    # Distance along the geodesic
    dist.along.strand.geodesic <- seq(0, 1, length=nrow(smoothed.geodesic))[nn.geodesic.vertex.i]

    res <- list(nn.i = nn.i,
                dist.to.geodesic = dist.to.geodesic,
                strand.i = strand.i,
                strand = strand,
                nn.geodesic.vertex.i = nn.geodesic.vertex.i,
                dist.along.strand.geodesic = dist.along.strand.geodesic,
                d.thld = d.thld)
    res
}

#' Estimates and the mean prevalence of a factors along a geodesic.
#'
#' Given a list of subject-level factors, subj.factors, and IDs of the given
#' branch, bch.ids, as well as the distance along the geodesic, gamma, vector
#' and a file prefix, this routine estimates the mean prevalence of the given
#' factor, E_gamma_F, along the geodesic and saves the results of the estimates
#' to a file the given prefix and suffix: Fid.rda.
#'
#' @param subj.factors            A list of subject-level factors.
#' @param subjID                  A vector of subject IDs.
#' @param bch.ids                 Branch IDs.
#' @param dist.along.bch.geodesic A distance along the geodesic of the given branch.
#' @param file.prefix             The prefix of an rda file to which the results of E_gamma_F estimates will be save. Example: "~/projects/rllm/projects/ZB/data/asv_branches/Lc2Gv6_".
#'
#' @return A named character vector mapping factor IDs to their corresponding saved
#'   file paths. Each element name is a factor ID and its value is the full path
#'   to the RDA file containing the E_gamma_F estimation results for that factor.
#'
#' @details
#' For each factor in subj.factors, this function:
#' \enumerate{
#'   \item Identifies subjects present in the branch
#'   \item Calculates the mean prevalence along the geodesic distance
#'   \item Saves the results to an RDA file named `{file.prefix}{Fid}.rda`
#' }
#'
#' The saved RDA files contain the E_gamma_F estimates which can be loaded for
#' further analysis or visualization.
#'
#' @export
E.geodesic.F <- function(subj.factors,
                     subjID,
                     bch.ids,
                     dist.along.bch.geodesic,
                     file.prefix)
{
    save.files <- c()
    for ( Fid in names(subj.factors) )
    {
        rg.sample.ids <- bch.ids
        F <- subj.factors[[Fid]]
        F <- F[!is.na(F)]
        subj.ids <- names(F)
        n.subj <- length(subj.ids)
        ## Subjects detected within the given region
        rg.sample.to.subj.ids <- subjID[rg.sample.ids]
        rg.subj.ids <- sort(unique(rg.sample.to.subj.ids))
        n.rg.subj <- length(rg.subj.ids)
        rg.subj.to.sample.ids <- split(names(subjID), subjID)[rg.subj.ids]
        ## Common subjects
        comm.subj.ids <- intersect(subj.ids, rg.subj.ids)
        n.comm.subj <- length(comm.subj.ids)
        ## Take only samples that belong to subjects with the factor
        comm.subj.to.sample.ids <- split(names(subjID), subjID)[comm.subj.ids]

        if ( n.comm.subj < 10 ) {
            next
        }

        save.file <- paste0(file.prefix, Fid, ".rda")
        save.files[Fid] <- save.file
        cat("Generating and saving E_gamma", Fid, "to", save.file, "\n")

        ##
        ## Subjects with factor F
        ##
        subj.EF <- lapply(comm.subj.ids, function(sID)
        {
            sIDs <- unlist(comm.subj.to.sample.ids[sID])
            F.sID <- as.numeric(F[sID])
            list(sIDs = sIDs,
                 F.sID = F.sID,
                 x.sID = dist.along.bch.geodesic[sIDs],
                 y.sID = rep(F.sID, length(sIDs)))
        })
        x <- unlist(sapply(subj.EF, function(r) r$x.sID))
        y <- unlist(sapply(subj.EF, function(r) r$y.sID))
        order.xy <- order(x)
        x <- x[order.xy]
        y <- y[order.xy]

        res <- fb.magelo(x, y, C=3)
        Ex <- res$xg
        Ey <- res$Eyg
        Ey.CI.lwr <- res$llreg$lower
        Ey.CI.upr <- res$llreg$upper

        save(Fid, Ex, Ey, Ey.CI.lwr, Ey.CI.upr, file=save.file)
    }

    save.files
}

#' Generates figures associated with E.geodesic.F estimates.
#'
#' @param save.file.prefix   A prefix of the save() files.
#' @param rlabs              Labels of the subject factors with levels.
#' @param pics.file.prefix   A prefix pdf output files.
#'
#' @return NULL. This function is called for its side effects of generating PDF plots.
#'   One PDF file is created for each factor in rlabs that has a corresponding saved
#'   RDA file.
#'
#' @details
#' This function loads the results from E.geodesic.F estimation (saved as RDA files)
#' and creates visualization plots saved as PDF files. For each factor label in rlabs,
#' it looks for a file named `{save.file.prefix}{lab}.rda` and if found, generates
#' a plot saved as `{pics.file.prefix}{lab}_Exy.pdf`.
#'
#' The plots show the expected values (Ey) along the geodesic distance (Ex) with
#' confidence intervals, providing a visual representation of how the factor varies
#' along the geodesic path.
#'
#' @seealso \code{\link{E.geodesic.F}} for generating the data files used by this function
#'
#' @export
fig.E.geodesic.F <- function(save.file.prefix, rlabs, pics.file.prefix)
{
    for ( lab in rlabs )
    {
        file <- paste0(save.file.prefix,lab,".rda")
        if ( file.exists(file) )
        {
            Ex <- Ey <- Ey.CI.lwr <- Ey.CI.upr <- NULL
            ## save(Fid, Ex, Ey, Ey.CI.lwr, Ey.CI.upr, file=save.file)
            load(file)
            if(!is.null(Ex) && !is.null(Ey) && !is.null(Ey.CI.lwr) && !is.null(Ey.CI.upr)) {
                file <- paste0(pics.file.prefix,lab,"_Exy.pdf")
                tryCatch({
                    grDevices::pdf(file, width=4, height=4)
                    on.exit(grDevices::dev.off(), add = TRUE)

                    plot(Ex, Ey, type='l',
                         ylim=range(c(Ey.CI.lwr, Ey.CI.upr), na.rm=TRUE),
                         xlab=expression(gamma),
                         ylab=expression(E[gamma~F]),
                         xlim=c(0,1))
                    lines(Ex, Ey.CI.lwr, col='gray')
                    lines(Ex, Ey.CI.upr, col='gray')
                    abline(h=0, col='gray', lty=2)

                    cat(file, "\n")
                }, error = function(e) {
                    # This cleanup is now redundant due to on.exit, but keeping it doesn't hurt
                    if (grDevices::dev.cur() != 1) grDevices::dev.off()
                    stop(paste("Error creating PDF:", e$message))
                })
            }
        }
    }
}

#' Sings of the derivatives of the E.geodesic.F profiles.
#'
#' @param save.file.prefix   The prefix of the save() files.
#' @param rlabs              Labels of the subject factors with levels.
#' @param grid.size          Grid size in E.geodesic.F estimates.
#'
#' @return A matrix with dimensions length(rlabs) x (grid.size-1) containing the signs
#'   of the derivatives of the E.geodesic.F profiles. Each row corresponds to a factor
#'   in rlabs, and each column represents the sign of the derivative at consecutive
#'   grid points. Values are 1 for positive derivatives, -1 for negative derivatives,
#'   and NA for factors without corresponding data files.
#'
#' @details
#' This function computes the signs of the derivatives (differences) of the expected
#' value profiles generated by E.geodesic.F. For each factor, it loads the saved
#' results and calculates whether the expected values are increasing (sign = 1) or
#' decreasing (sign = -1) between consecutive grid points along the geodesic.
#'
#' @seealso \code{\link{E.geodesic.F}} for generating the data files used by this function
#'
#' @export
subj.factor.signEy.profs <- function(save.file.prefix, rlabs, grid.size=400)
{
    subj.factor.signEy.profs <- matrix(nrow=length(rlabs), ncol=grid.size-1)
    rownames(subj.factor.signEy.profs) <- rlabs
    for ( lab in rlabs )
    {
        Ey <- NULL
        file <- paste0(save.file.prefix,lab,".rda")
        if ( file.exists(file) )
        {
            load(file)
            signEy <- sign(diff(Ey))
            subj.factor.signEy.profs[lab,] <- signEy
        }
    }

    subj.factor.signEy.profs
}

#' Generates a data frame of proportion plus/minus dE.geodesic.F profiles.
#'
#' @param subj.factor.signEy.profs  An output from subj.factor.signEy.profs().
#' @param rowInd             Row index permutation vector as returned by 'order.dendrogram'.
#' @param rlabs              Labels of the subject factors with levels.
#' @param save.file.prefix   The prefix of the save() files.
#' @param N                  The number of +/0/- symbols in each profile.
#'
#' @return A data frame with rows corresponding to factors (reordered by rowInd) and
#'   columns containing:
#'     \item{Columns 1 to N}{Character columns containing "+", "-", or "0" symbols
#'           representing the discretized derivative profile of each factor.}
#'     \item{pval}{Numeric column containing p-values loaded from the saved files.}
#'     \item{lab}{Character column containing the factor labels.}
#'
#' @details
#' This function creates a visual representation of how factor expected values change
#' along the geodesic by discretizing the derivative signs into N bins. Each row
#' shows whether the factor is increasing (+), decreasing (-), or constant (0) in
#' each bin along the geodesic path.
#'
#' @seealso
#' \code{\link{subj.factor.signEy.profs}} for generating the input derivative signs
#' \code{\link{E.geodesic.F}} for generating the data files containing p-values
#'
#' @export
subj.factor.ppmEy.profs.df <- function(subj.factor.signEy.profs, rowInd, rlabs, save.file.prefix, N=10)
{
    X <- subj.factor.signEy.profs[rev(rowInd),]
    ##rownames(X)

    pval <- c()
    for ( lab in rlabs )
    {
        delta1.res <- NULL
        file <- paste0(save.file.prefix,lab,".rda")
        ## save(delta1.res, file=file)
        if ( file.exists(file) )
        {
            load(file)
            pval[lab] <- delta1.res$p.value
        }
    }

    pval <- pval[rownames(X)]
    ##pval <- -log10(pval)

    profs <- c()
    for ( i in seq(nrow(X)) )
    {
        ##subj.factor.signEy.profs[,1]
        profile.i <- rep("0", N)
        col.split <- split(seq(ncol(X)), rep(1:N, length=ncol(X)))
        ##col.split
        for ( j in seq(N) ) {
            sign.mean <- mean(X[i,col.split[[j]]], na.rm=TRUE)
            if ( sign.mean > 0.66 ) {
                ##if ( sign.mean > 0.9 ) {
                profile.i[j] <- "+"
            } else if ( sign.mean < -0.66 ) {
                ##} else if ( sign.mean < -0.9 ) {
                profile.i[j] <- "-"
            }
        }
        profs <- rbind(profs, profile.i)
    }

    rownames(profs) <- names(pval)
    profs.df <- data.frame(profs, pval=pval, lab=rownames(profs))
    rownames(profs.df) <- rownames(profs)
    ##

    profs.df
}

#' Given TA and TAA from E.geodesic.X(), this routine identifies variables monotonically associated with the distance along the geodesic
#'
#' @param X     A matrix of a data frame with TA and delta1 columns.
#' @param eps   The positive constant specifying the size of a neighborhood around the diagonal and anti-diagonal of the (TA, TAA) graph.
#'
#' @return A logical vector of length equal to the number of rows in X, where TRUE
#'   indicates that the corresponding variable is approximately monotonically associated
#'   with the geodesic distance (either increasing or decreasing).
#'
#' @details
#' This function analyzes the relationship between variables and geodesic distance by
#' examining the TA (turn angle) and TAA (turn angle acceleration) values. Variables
#' are considered monotonically associated if their (TA, TAA) values fall within an
#' epsilon neighborhood of either the diagonal (monotonically increasing) or
#' anti-diagonal (monotonically decreasing) in the unit square.
#'
#' @examples
#' # Assuming X has columns TA and TAA from E.geodesic.X output
#' # monotonic_vars <- vars.approx.monotonically.assoc.with.geodesic(X, eps = 0.4)
#' # X[monotonic_vars, ] # subset to monotonic variables
#'
#' @export
vars.approx.monotonically.assoc.with.geodesic <- function(X, eps = 0.4) {

    if (!is.matrix(X)) {
        X <- try(as.matrix(X), silent = TRUE)
        if (inherits(X, "try-error")) {
            stop("X must be a matrix or coercible to a matrix")
        }
    }

    if (!is.numeric(X)) {
        stop("X must contain numeric values")
    }

    if (any(is.na(X)) || any(is.infinite(X))) {
        stop("X cannot contain NA, NaN, or Inf values")
    }

    TA <- X[, "TA"]
    TAA <- X[, "TAA"]

    # Check that TA and TAA are in [0, 1]
    if (any(TA < 0 | TA > 1) || any(TAA < 0 | TAA > 1)) {
        warning("TA and TAA values should be in the range [0, 1]")
    }

    # Variables near the diagonal (monotonically increasing)
    dist_to_diagonal <- abs(TA - TAA)
    near_diagonal <- dist_to_diagonal < eps

    # Variables near the anti-diagonal (monotonically decreasing)
    dist_to_antidiagonal <- abs(TA + TAA - 1)
    near_antidiagonal <- dist_to_antidiagonal < eps

    # Return TRUE for variables that are near either diagonal
    monotonic <- near_diagonal | near_antidiagonal

    return(monotonic)
}

#' Estimates subject risk of a disease or adverse outcome, D, given the risk D over some state space.
#'
#' @param sID      A subject ID.
#' @param S        A state space.
#' @param G.S      A graph associated with S.
#' @param ED       An estimate of the risk of a disease or adverse outcome, D, over S.
#' @param subjID   A vector of subject IDs.
#' @param visit    A vector of visits.
#'
#' @return A list containing risk estimates for the subject:
#'   \item{subj.ids}{Character vector of subject visit IDs.}
#'   \item{subj.sVisit}{Numeric vector of subject visits.}
#'   \item{E.pred.D}{Predicted risk value interpolated along the geodesic path.}
#'   \item{E.D2}{Risk value at the second visit.}
#'   \item{E.D3}{Risk value at the third visit.}
#'   \item{subj.path12.ED.max}{Maximum risk value along the path from visit 1 to 2.}
#'   \item{subj.path23.ED.max}{Maximum risk value along the path from visit 2 to 3.}
#'
#' @details
#' This function calculates disease risk for a specific subject by:
#' \enumerate{
#'   \item Finding the subject's visit states in the state space
#'   \item Computing geodesic paths between consecutive visits
#'   \item Interpolating risk values along these paths
#'   \item Extracting maximum risk values and predicted risks
#' }
#'
#' The function assumes the subject has at least 3 visits and uses geodesic paths
#' to model the subject's trajectory through the state space between visits.
#'
#' @export
subj.D.risk <- function(sID, S, G.S, ED, subjID, visit)
{
    ##
    ##  Getting subject visit IDs and indices
    ##
    subj.ids.res <- get.subj.ids(sID, S, subjID, visit)

    subj.ids <- subj.ids.res$ids
    subj.ii <- subj.ids.res$ii
    subj.sVisit <- subj.ids.res$sVisit

    ##
    ##  Gettting geodesic paths between visit states
    ##
    path1.vs <- shortest_paths(G.S, from=subj.ii[1], to=c(subj.ii[2]))[[1]][[1]]
    path1.vs <- as.integer(path1.vs)

    path2.vs <- shortest_paths(G.S, from=subj.ii[2], to=c(subj.ii[3]))[[1]][[1]]
    path2.vs <- as.integer(path2.vs)

    ##
    ##  Constructing the combined path from V1 to V3
    ##
    combined.path.vs <- c(path1.vs[1:(length(path1.vs)-1)], path2.vs)

    ##
    ##  Normalizing the distances to the [0,1] interval
    ##
    dist.along.combined.path <- path.dist(combined.path.vs, S)

    ##
    ##  Finding path1.vs and path2.vs along the combined normalized path
    ##
    dist.V2 <- dist.along.combined.path[length(path1.vs)]
    ##dist.V3 <- 1
    ##dist.V1 <- 0

    ##
    ##  delta1 profile for the subject from V1 to V3
    ##
    subj.path.ED <- ED[combined.path.vs]
    ######################################################################

    ##
    ##  Interpolating the delta1 profile at the midway between V1 and V2
    ##
    mid.V1V2.dist <- dist.V2/2
    E.pred.D <- approx(dist.along.combined.path, subj.path.ED, xout=mid.V1V2.dist)$y

    ##
    ##  delta1 at V1, V2, and V3
    ##
    ##E.D1 <- subj.path.ED[1]
    E.D2 <- subj.path.ED[length(path1.vs)]
    E.D3 <- subj.path.ED[length(combined.path.vs)]

    ##
    ##  Finding max of the risk profile along each of the subject's
    ##  geodesic paths
    ##
    subj.path12.ED <- ED[path1.vs]
    subj.path12.ED.max <- max(subj.path12.ED)

    subj.path23.ED <- ED[path2.vs]
    subj.path23.ED.max <- max(subj.path23.ED)

    list(subj.ids=subj.ids,
         subj.sVisit = subj.sVisit,
         E.pred.D = E.pred.D,
         ##E.D1 = E.D1,
         E.D2 = E.D2,
         E.D3 = E.D3,
         subj.path12.ED.max = subj.path12.ED.max,
         subj.path23.ED.max = subj.path23.ED.max)
}

#' Get subject-specific visit information and indices
#'
#' Extracts visit information and corresponding row indices in S.3d for a specific subject.
#'
#' @param sID      A subject ID to search for
#' @param S.3d     A matrix/array with rownames containing subject identifiers
#' @param subjID   A vector of subject IDs corresponding to rows in S.3d
#' @param visit    A vector of visit numbers corresponding to subjID entries
#'
#' @return A list containing:
#'   \item{sVisit}{Named vector of visit numbers for the subject}
#'   \item{ii}{Indices of the subject's rows in S.3d}
#'   \item{ids}{Character vector of row names from S.3d for this subject}
#'
#' @examples
#' # Example usage:
#' # S.3d <- matrix(1:12, nrow=4, dimnames=list(c("s1_v1", "s1_v2", "s2_v1", "s2_v2")))
#' # subjID <- c("s1", "s1", "s2", "s2")
#' # visit <- c(1, 2, 1, 2)
#' # get.subj.ids("s1", S.3d, subjID, visit)
get.subj.ids <- function(sID, S.3d, subjID, visit) {
  # Input validation
  if (is.null(sID) || is.null(S.3d) || is.null(subjID) || is.null(visit)) {
    stop("All arguments must be non-NULL")
  }

  if (length(subjID) != length(visit)) {
    stop("subjID and visit must have the same length")
  }

  # Find all entries for this subject
  subject_mask <- subjID == sID

  if (!any(subject_mask)) {
    warning(paste("No data found for subject ID:", sID))
    return(list(sVisit = numeric(0), ii = integer(0), ids = character(0)))
  }

  # Extract visit information for this subject
  subject_visits <- visit[subject_mask]
  subject_row_names <- rownames(S.3d)[subject_mask]

  # Ensure visits have names (use row names if available)
  if (is.null(names(subject_visits)) && !is.null(subject_row_names)) {
    names(subject_visits) <- subject_row_names
  }

  # Get unique visits and sort them
  unique_visits <- sort(unique(subject_visits))

  # Build ordered vectors of IDs and indices
  ordered_ids <- character()
  ordered_indices <- integer()

  for (v in unique_visits) {
    # Find exact matches for this visit number
    visit_mask <- subject_visits == v
    visit_ids <- names(subject_visits)[visit_mask]

    if (length(visit_ids) > 0) {
      # Match these IDs to row indices in S.3d
      visit_indices <- match(visit_ids, rownames(S.3d))

      # Remove any NA matches
      valid_mask <- !is.na(visit_indices)
      visit_ids <- visit_ids[valid_mask]
      visit_indices <- visit_indices[valid_mask]

      ordered_ids <- c(ordered_ids, visit_ids)
      ordered_indices <- c(ordered_indices, visit_indices)
    }
  }

  # Return results
  list(
    sVisit = subject_visits,
    ii = ordered_indices,
    ids = ordered_ids
  )
}

# Alternative implementation if visits are always 1, 2, 3:
get.subj.ids.fixed3 <- function(sID, S.3d, subjID, visit) {
  # Input validation
  if (is.null(sID) || is.null(S.3d) || is.null(subjID) || is.null(visit)) {
    stop("All arguments must be non-NULL")
  }

  if (length(subjID) != length(visit)) {
    stop("subjID and visit must have the same length")
  }

  # Find all entries for this subject
  subject_mask <- subjID == sID

  if (!any(subject_mask)) {
    warning(paste("No data found for subject ID:", sID))
    return(list(sVisit = numeric(0), ii = integer(0), ids = character(0)))
  }

  # Extract information for this subject
  subject_visits <- visit[subject_mask]
  subject_row_names <- rownames(S.3d)[subject_mask]

  # Ensure visits have names
  if (is.null(names(subject_visits)) && !is.null(subject_row_names)) {
    names(subject_visits) <- subject_row_names
  }

  # Initialize containers for the three visits
  ids <- character()
  indices <- integer()

  # Process each visit (1, 2, 3)
  for (v in 1:3) {
    # Use exact matching instead of grep
    visit_positions <- which(subject_visits == v)

    if (length(visit_positions) > 0) {
      visit_ids <- names(subject_visits)[visit_positions]
      # Use match instead of pmatch for exact matching
      visit_indices <- match(visit_ids, rownames(S.3d))

      # Remove NA matches
      valid_mask <- !is.na(visit_indices)
      visit_ids <- visit_ids[valid_mask]
      visit_indices <- visit_indices[valid_mask]

      ids <- c(ids, visit_ids)
      indices <- c(indices, visit_indices)
    }
  }

  list(
    sVisit = subject_visits,
    ii = indices,
    ids = ids
  )
}

#' Define a function to estimate the density rho_S(X)
#'
#' This is a placeholder for a density estimation function. In practice, this
#' might use methods like kernel density estimation.
#'
#' @param point A numeric vector representing a point in the state space.
#' @param X A matrix where each row represents a point in the state space, used
#'   as the reference dataset for density estimation.
#'
#' @return A numeric value representing the estimated density at the given point.
#'   Currently returns 1 as a placeholder implementation.
#'
#' @details
#' This function is intended to estimate the density of points in a high-dimensional
#' space. The current implementation returns a constant value of 1, serving as a
#' placeholder. In production use, this should be replaced with an appropriate
#' density estimation method such as:
#' \itemize{
#'   \item Kernel density estimation (KDE)
#'   \item k-nearest neighbors density estimation
#'   \item Gaussian mixture models
#' }
#'
#' @note This is a placeholder implementation. Users should replace this with an
#'   appropriate density estimation method for their specific use case.
#'
#' @examples
#' # Current placeholder usage
#' X <- matrix(rnorm(100), ncol=2)
#' point <- c(0, 0)
#' density <- estimate_density(point, X)  # Returns 1
#'
#' @export
estimate_density <- function(point, X) {
    return(1)  # Returning a constant for simplicity.
}

#' Estimates geodesic (shortest path) nearest neighbors.
#'
#' @param X      A numeric matrix.
#' @param k      The number of nearest neighbors to be returned.
#' @param K      The number of neighbors in knn.graph() to build a knn graph. When
#'               k=1, the knn graph is the minimal spanning tree.
#' @param G      A graph associated with X.
#'
#' @return A list containing two matrices:
#'   \item{nn.index}{An n x k matrix where element \code{[i,j]} contains the index of the j-th
#'                   geodesic nearest neighbor of point i.}
#'   \item{nn.dist}{An n x k matrix where element \code{[i,j]} contains the geodesic distance
#'                  to the j-th nearest neighbor of point i.}
#'
#' @details
#' This function computes k-nearest neighbors based on geodesic distances (shortest paths
#' through a graph) rather than Euclidean distances. The geodesic distance is particularly
#' useful for data that lies on a manifold, where the straight-line distance between points
#' may not accurately reflect their true similarity.
#'
#' The function first constructs or uses a provided graph G to compute geodesic distances
#' between all pairs of points, then identifies the k nearest neighbors for each point
#' based on these distances.
#'
#' @examples
#' \dontrun{
#' # Generate sample data on a spiral
#' t <- seq(0, 4*pi, length.out = 100)
#' X <- cbind(t*cos(t), t*sin(t))
#'
#' # Find 5 geodesic nearest neighbors
#' gnn <- geodesic.knn(X, k = 5, K = 10)
#'
#' # Compare with Euclidean nearest neighbors
#' enn <- get.knn(X, k = 5)
#' }
#'
#' @seealso
#' \code{\link{estimate.geodesic.distances}} for computing geodesic distances
#' \code{\link{dist.to.knn}} for converting distance matrix to k-NN format
#'
#' @export
geodesic.knn <- function(X, k, K=5, G=NULL) {
    if (!is.matrix(X)) {
        X <- try(as.matrix(X), silent = TRUE)
        if (inherits(X, "try-error")) {
            stop("X must be a matrix or coercible to a matrix")
        }
    }
    if (!is.numeric(X)) {
        stop("X must contain numeric values")
    }
    if (any(is.na(X)) || any(is.infinite(X))) {
        stop("X cannot contain NA, NaN, or Inf values")
    }
    stopifnot(k>0)
    ##d <- geodesic.dist(X, K, G)
    d <- estimate.geodesic.distances(X, K, G)
    r <- dist.to.knn(d, k)
    list(nn.index=r$nn.i,
         nn.dist=r$nn.d)
}

#' Estimate Geodesic Distances Between Points
#'
#' This function estimates the shortest path distances (geodesic distances) between points
#' in a given dataset. It can use either a k-nearest neighbors graph or a minimal spanning tree.
#'
#' @param points A matrix or data frame where each row represents a point in the feature space.
#' @param k Positive integer. The number of nearest neighbors to use when constructing the graph.
#'   When k=1 or method='mst', a minimal spanning tree is used instead. Default is 5.
#' @param graph An optional igraph object representing the graph structure of the points.
#'   If provided, this graph will be used instead of constructing a new one.
#' @param method Character string specifying the method to use for constructing the graph.
#'   Must be either "knn.graph" (default) or "mst" (minimal spanning tree).
#'
#' @return A distance matrix containing the estimated geodesic distances between all pairs of points.
#'   The matrix has dimensions n x n where n is the number of points. Row and column names are
#'   preserved from the input if present.
#'
#' @details
#' Geodesic distances represent the shortest path between points through a graph structure,
#' which can better capture the intrinsic geometry of data lying on a manifold compared to
#' Euclidean distances.
#'
#' The function supports two methods for graph construction:
#' \itemize{
#'   \item \strong{knn.graph}: Connects each point to its k nearest neighbors based on Euclidean distance
#'   \item \strong{mst}: Creates a minimal spanning tree of all points
#' }
#'
#' @note
#' The k-NN graph construction creates a directed graph that is then treated as undirected.
#' This may result in some points having more than k connections if they appear in other
#' points' k-nearest neighbor lists.
#'
#' @examples
#' # Generate sample data on a Swiss roll manifold
#' n <- 100
#' t <- seq(0, 4*pi, length.out = n)
#' points <- cbind(
#'   x = t * cos(t),
#'   y = 10 * runif(n),
#'   z = t * sin(t)
#' )
#'
#' # Estimate geodesic distances using k-NN graph
#' geo_dist_knn <- estimate.geodesic.distances(points, k = 5)
#'
#' # Estimate geodesic distances using MST
#' geo_dist_mst <- estimate.geodesic.distances(points, method = "mst")
#'
#' # Compare with Euclidean distances
#' euc_dist <- as.matrix(dist(points))
#'
#' # Geodesic distances are typically larger than Euclidean for manifold data
#' mean(geo_dist_knn > euc_dist, na.rm = TRUE)
#'
#' @importFrom igraph graph_from_adjacency_matrix graph_from_edgelist distances E V
#' @importFrom FNN get.knn
#' @importFrom stats dist
#'
#' @export
estimate.geodesic.distances <- function(points, k = 5, graph = NULL, method = "knn.graph") {
    ## Input validation
    if (!is.matrix(points) && !is.data.frame(points)) {
        stop("points must be a matrix or data frame.")
    }

    # Convert data.frame to matrix if needed
    if (is.data.frame(points)) {
        points <- as.matrix(points)
    }

    # Validate numeric data
    if (!is.numeric(points)) {
        stop("points must contain numeric values.")
    }

    # Check for NA or infinite values
    if (any(is.na(points)) || any(is.infinite(points))) {
        stop("points cannot contain NA, NaN, or infinite values.")
    }

    if (!is.numeric(k) || k < 1 || k != as.integer(k)) {
        stop("k must be a positive integer.")
    }

    # Check k is not larger than n-1
    n <- nrow(points)
    if (k >= n) {
        stop("k must be less than the number of points.")
    }

    if (!is.null(graph) && !inherits(graph, "igraph")) {
        stop("If provided, graph must be an igraph object.")
    }

    if (!method %in% c("knn.graph", "mst")) {
        stop("method must be either 'knn.graph' or 'mst'.")
    }

    ## Ensure required packages are available
    if (!requireNamespace("igraph", quietly = TRUE)) {
        stop("Package 'igraph' is required for this function to work. Please install it.")
    }
    if (method == "knn.graph" && k > 1 && !requireNamespace("FNN", quietly = TRUE)) {
        stop("Package 'FNN' is required for k-NN graph construction. Please install it.")
    }

    if (is.null(graph)) {
        if (method == "mst" || k == 1) {
            ## Minimal Spanning Tree
            dist_matrix <- as.matrix(dist(points))

            # Create complete graph with distance weights
            complete_graph <- igraph::graph_from_adjacency_matrix(
                dist_matrix,
                mode = "undirected",
                weighted = TRUE,
                diag = FALSE
            )

            # Extract minimal spanning tree
            graph <- igraph::mst(complete_graph)

        } else {
            ## K-Nearest Neighbors Graph
            nn <- FNN::get.knn(points, k = k)

            # Create edge list with proper indexing
            edges <- matrix(nrow = 0, ncol = 2)
            weights <- numeric(0)

            for (i in 1:nrow(points)) {
                for (j in 1:k) {
                    # Add both directions to ensure undirected graph
                    neighbor_idx <- nn$nn.index[i, j]
                    edges <- rbind(edges, c(i, neighbor_idx))
                    weights <- c(weights, nn$nn.dist[i, j])
                }
            }

            # Create graph
            graph <- igraph::graph_from_edgelist(edges, directed = FALSE)

            # Remove duplicate edges (from making it undirected)
            graph <- igraph::simplify(graph, remove.multiple = TRUE, remove.loops = TRUE)

            # Set edge weights as the minimum distance for each edge
            # (some edges might appear twice with different weights)
            edge_list <- igraph::as_edgelist(graph)
            edge_weights <- numeric(nrow(edge_list))

            for (e in 1:nrow(edge_list)) {
                v1 <- edge_list[e, 1]
                v2 <- edge_list[e, 2]

                # Find the weight for this edge
                weight1 <- if (v2 %in% nn$nn.index[v1, ]) {
                    nn$nn.dist[v1, which(nn$nn.index[v1, ] == v2)]
                } else { Inf }

                weight2 <- if (v1 %in% nn$nn.index[v2, ]) {
                    nn$nn.dist[v2, which(nn$nn.index[v2, ] == v1)]
                } else { Inf }

                edge_weights[e] <- min(weight1, weight2)
            }

            igraph::E(graph)$weight <- edge_weights
        }
    }

    ## Calculate geodesic distances
    geodesic_distances <- igraph::distances(graph, mode = "all")

    # Preserve row and column names
    if (!is.null(rownames(points))) {
        rownames(geodesic_distances) <- rownames(points)
        colnames(geodesic_distances) <- rownames(points)
    }

    return(geodesic_distances)
}

#' Estimates geodesic (shortest path) nearest neighbors of X.grid points in X.
#' That is for each point of X.grid the k-NN's within X are returned.
#'
#' @param X      A numeric matrix.
#' @param X.grid A grid associated with X.
#' @param k      The number of nearest neighbors to be returned.
#' @param method A method for building a graph distances within which are going
#'               to give shortest path distance estimates. This parameter is not used now,
#'               but in the nearest future I am envisioning other methods of constructing
#'               the graph.
#' @param K      The number of neighbors in knn.graph() to build a knn graph. When
#'               k=1, the knn graph is the minimal spanning tree.
#'
#' @return A list containing:
#'   \item{V}{Combined vertex matrix containing both X.grid and X points.}
#'   \item{E}{Edge matrix defining the graph structure.}
#'   \item{nn.index}{An nrow(X.grid) x k matrix where element \code{[i,j]} contains the
#'                   index (in X) of the j-th geodesic nearest neighbor of grid point i.}
#'   \item{nn.dist}{An nrow(X.grid) x k matrix where element \code{[i,j]} contains the
#'                  geodesic distance from grid point i to its j-th nearest neighbor in X.}
#'
#' @details
#' This function finds k-nearest neighbors from dataset X for each point in X.grid
#' based on geodesic distances. It's particularly useful for interpolation or
#' extrapolation tasks where you want to find the closest data points to query points
#' on a manifold.
#'
#' The algorithm works by:
#' \enumerate{
#'   \item Creating a combined graph that includes both X.grid and X points
#'   \item Establishing edges within X.grid based on grid structure
#'   \item Connecting X points to their nearest grid points
#'   \item Computing geodesic distances through this combined graph
#'   \item Extracting k-nearest neighbors from X for each X.grid point
#' }
#'
#' @note
#' The parameter K is automatically set to 2^ncol(X) to ensure adequate connectivity
#' between the data points and the grid. The grid connectivity is based on the
#' dimensionality of the data (2 neighbors in 1D, 4 in 2D, 6 in 3D, etc.).
#'
#' @examples
#' \dontrun{
#' # Create sample data
#' X <- matrix(rnorm(200), ncol=2)
#'
#' # Create a regular grid
#' x_seq <- seq(min(X[,1]), max(X[,1]), length.out=10)
#' y_seq <- seq(min(X[,2]), max(X[,2]), length.out=10)
#' X.grid <- as.matrix(expand.grid(x_seq, y_seq))
#'
#' # Find 3 nearest neighbors in X for each grid point
#' result <- geodesic.knnx(X, X.grid, k=3)
#'
#' # Access the nearest neighbor indices and distances
#' nn_indices <- result$nn.index
#' nn_distances <- result$nn.dist
#' }
#'
#' @seealso
#' \code{\link{geodesic.knn}} for finding geodesic nearest neighbors within a single dataset
#' \code{\link[FNN]{get.knn}} for Euclidean k-nearest neighbors
#' \code{\link[FNN]{get.knnx}} for Euclidean k-nearest neighbors between two datasets
#'
#' @importFrom igraph graph_from_adjacency_matrix distances
#' @importFrom FNN get.knn get.knnx
#'
#' @export
geodesic.knnx <- function(X, X.grid, k, method="knn.graph", K=5) {
    if (!is.matrix(X)) {
        X <- try(as.matrix(X), silent = TRUE)
        if (inherits(X, "try-error")) {
            stop("X must be a matrix or coercible to a matrix")
        }
    }
    if (!is.numeric(X)) {
        stop("X must contain numeric values")
    }
    if (any(is.na(X)) || any(is.infinite(X))) {
        stop("X cannot contain NA, NaN, or Inf values")
    }
    stopifnot(k>0)
    n <- nrow(X)
    N <- nrow(X.grid)
    dimK <- 2 * ncol(X) # in dim 1 grid vertex has only 2 nbrs, in dim 2 - 4, in dim 3 - 6 etc
    nn <- FNN::get.knn(X.grid, k=dimK)
    E.grid <- matrix(nrow=dimK*N, ncol=2)
    ii <- seq(N)
    for ( i in seq(dimK) )
    {
        E.grid[ii,] <- cbind(seq(N), nn$nn.index[,i])
        ii <- ii + N
    }
    K <- 2^ncol(X)
    nn <- FNN::get.knnx(X.grid, X, k=K)
    nn.i <- nn$nn.index
    E <- matrix(nrow=K*n, ncol=2)
    l <- 1
    for ( i in seq(n) )
    {
        for ( j in seq(K) )
        {
            E[l,] <- c(i+N, nn.i[i,j])
            l <- l + 1
        }
    }
    V <- rbind(X.grid, X)
    E <- rbind(E.grid, E)
    A <- graph.adj.mat(V, E)
    G <- igraph::graph_from_adjacency_matrix(A, mode="undirected", weighted=TRUE)
    d <- igraph::distances(G)
    ## rownames(d) <- rownames(X)
    ## colnames(d) <- rownames(X)
    ## getting the largest distance that will be used for unreachable vertices for which graph distance is Inf
    dd <- as.numeric(d)
    dd <- dd[is.finite(dd)]
    max.d <- max(dd)
    ##r <- dist.to.knn(d, k)
    M <- nrow(d)
    nn.i <- matrix(0, nrow=N, ncol=k)
    nn.d <- matrix(0, nrow=N, ncol=k)
    for ( i in seq(N) )
    {
        x <- as.numeric(d[i,])
        o <- order(x)
        x <- x[o]
        ii <- o
        idx <- ii > N
        ii <- ii[idx] # selecting only indices of X
        x <- x[idx]
        x[!is.finite(x)] <- max.d
        nn.i[i,] <- ii[seq(k)] - N
        nn.d[i,] <- x[seq(k)]
    }
    list(V=V,
         E=E,
         nn.index=nn.i,
         nn.dist=nn.d)
}

#' Creates weights adjacency matrix given a matrix of edges and position matrix
#' of the corresponding vertices.
#'
#' The weights adjacency matrix A has the property that the (i,j) entry is the
#' weight of the edge between i and j, if such edge exists, and 0 otherwise. The
#' weights are distances in \eqn{R^{ncol(X)}} between corresponding vertices (rows of
#' X).
#'
#' @param X A position matrix of vertices of the graph where each row represents
#'   a vertex position in \eqn{R^d} space (d = ncol(X)).
#' @param E A two-column matrix where each row represents an edge. \code{E[i,1]} and \code{E[i,2]}
#'   are the indices of the vertices (rows of X) connected by the i-th edge.
#'
#' @return A symmetric n x n adjacency matrix where n = nrow(X). Element
#'     \code{A[i,j]} contains the Euclidean distance between vertices \code{i}
#'     and \code{j} if they are connected by an edge, and 0 otherwise.
#'
#' @details
#' This function constructs a weighted adjacency matrix for a graph where:
#' \itemize{
#'   \item Vertices are represented by their positions in X
#'   \item Edges are specified by the index pairs in E
#'   \item Edge weights are the Euclidean distances between connected vertices
#' }
#'
#' The resulting matrix is symmetric since the graph is treated as undirected.
#' Self-loops (edges from a vertex to itself) will have weight 0.
#'
#' @note
#' The function assumes 1-based indexing for the edge matrix E. All indices in E
#' must be between 1 and nrow(X).
#'
#' @examples
#' # Create a simple triangle graph
#' X <- matrix(c(0,0, 1,0, 0,1), ncol=2, byrow=TRUE)
#' E <- matrix(c(1,2, 2,3, 3,1), ncol=2, byrow=TRUE)
#' A <- graph.adj.mat(X, E)
#' print(A)
#' # Should show distances: A[1,2]=A[2,1]=1, A[2,3]=A[3,2]=sqrt(2), A[3,1]=A[1,3]=1
#'
#' @export
graph.adj.mat <- function(X, E)
{
    # Input validation
    if (!is.matrix(X)) {
        stop("X must be a matrix")
    }

    if (!is.numeric(X)) {
        stop("X must contain numeric values")
    }

    if (any(is.na(X)) || any(is.infinite(X))) {
        stop("X cannot contain NA, NaN, or infinite values")
    }

    if (!is.matrix(E)) {
        stop("E must be a matrix")
    }

    if (ncol(E) != 2) {
        stop("E must have exactly 2 columns")
    }

    if (!is.numeric(E)) {
        stop("E must contain numeric values")
    }

    if (any(is.na(E))) {
        stop("E cannot contain NA values")
    }

    # Check that E contains valid integer indices
    if (any(E != as.integer(E))) {
        stop("E must contain integer indices")
    }

    n <- nrow(X)

    # Check edge indices are valid
    if (nrow(E) > 0) {
        if (any(E < 1) || any(E > n)) {
            stop(paste("All edge indices in E must be between 1 and", n))
        }
    }

    # Initialize adjacency matrix
    A <- matrix(0, nrow=n, ncol=n)

    # Fill in edge weights
    if (nrow(E) > 0) {
        for (i in seq_len(nrow(E))) {
            s <- E[i, 1]
            e <- E[i, 2]

            # Calculate Euclidean distance between vertices
            # Using dist() on two points returns a single value
            distance <- as.numeric(dist(X[c(s, e), , drop=FALSE]))

            # Set both A[s,e] and A[e,s] for undirected graph
            A[s, e] <- distance
            A[e, s] <- distance
        }
    }

    # Set row and column names if X has them
    if (!is.null(rownames(X))) {
        rownames(A) <- rownames(X)
        colnames(A) <- rownames(X)
    }

    return(A)
}

#' Estimate Mean Abundance Along a Geodesic
#'
#' Estimates the mean abundance of covariates along a geodesic path. Given a matrix
#' of covariates defined over a subset of samples from the state space containing
#' the strand, this function estimates the mean of each column as a function of
#' distance along the geodesic for columns meeting prevalence criteria. Results
#' are saved to the specified data directory.
#'
#' @param X A numeric matrix of covariates with samples as rows and variables as columns.
#'   Row names should contain sample IDs.
#' @param strand.ids Character vector of sample IDs belonging to the strand.
#' @param dist.along.strand.geodesic Numeric vector of distances along the geodesic
#'   for each sample in the strand. Names should correspond to sample IDs.
#' @param data.dir Character string specifying the directory path where results
#'   will be saved.
#' @param winsorize Logical. If \code{TRUE} (default), performs right winsorization
#'   on columns of \code{X} before normalization.
#' @param winsorize.p Numeric value between 0 and 1. Proportion of values at the
#'   right tail to winsorize. Values above the (1 - \code{winsorize.p}) quantile
#'   are set to that quantile value. Default is 0.025.
#' @param min.max.normalize Logical. If \code{TRUE} (default), applies min-max
#'   normalization to each column of \code{X}.
#' @param prev.thld Numeric value between 0 and 1. Prevalence threshold for column
#'   filtering. Only columns with non-zero values in at least \code{prev.thld}
#'   proportion of samples are retained. Default is 0.9.
#' @param min.sample.count Integer. Minimum number of samples required in common
#'   between \code{X} and the strand to proceed with analysis. Default is 40.
#' @param rerun Logical. If \code{TRUE}, reruns \code{fassoc1.test()} even if
#'   results already exist. Default is \code{FALSE}.
#' @param n.partitions Integer. Number of partitions to split the column processing
#'   into. Useful for parallel processing. Default is 1.
#' @param partition.i Integer. Index of the partition to process when
#'   \code{n.partitions > 1}. Must be between 1 and \code{n.partitions}.
#' @param verbose Logical. If \code{TRUE} (default), prints progress messages
#'   during execution.
#'
#' @details
#' The function performs the following steps:
#' \enumerate{
#'   \item Identifies samples common to both \code{X} and \code{strand.ids}
#'   \item Filters columns based on the prevalence threshold
#'   \item Optionally applies winsorization and normalization
#'   \item Runs \code{fassoc1.test()} on each retained column
#'   \item Saves results to individual files in the specified directory
#' }
#'
#' When \code{n.partitions > 1}, the function processes only a subset of columns
#' specified by \code{partition.i}, enabling distributed computation.
#'
#' @return A list with the following components:
#'   \item{X}{The processed matrix after sample and column filtering, with
#'     optional winsorization and normalization applied.}
#'   \item{dist.along.strand.geodesic}{Numeric vector of geodesic distances
#'     for the samples common to both \code{X} and the strand.}
#'   \item{data.dir}{Character string of the data directory path.}
#'   \item{save.files}{Named character vector mapping standardized column names
#'     to file paths where results are saved.}
#'   \item{name.tbl}{Named character vector mapping standardized column names
#'     to original column names from \code{X}.}
#'
#' @note
#' Results for each column are saved as RDA files in \code{data.dir} with
#' filenames based on column indices. Each file contains \code{Ey} (expected
#' values) and \code{pval} (p-value) from \code{fassoc1.test()}.
#'
#' @seealso \code{\link{fassoc1.test}}, \code{\link{right.winsorize}},
#'   \code{\link{minmax.normalize}}
#'
#' @examples
#' \dontrun{
#' # Create example data
#' set.seed(123)
#' X <- matrix(rnorm(1000), nrow=100, ncol=10)
#' rownames(X) <- paste0("sample", 1:100)
#' colnames(X) <- paste0("var", 1:10)
#'
#' # Define strand
#' strand.ids <- paste0("sample", 1:80)
#' dist.along.strand.geodesic <- seq(0, 1, length.out=80)
#' names(dist.along.strand.geodesic) <- strand.ids
#'
#' # Run analysis
#' result <- E.geodesic.X(X = X,
#'                        strand.ids = strand.ids,
#'                        dist.along.strand.geodesic = dist.along.strand.geodesic,
#'                        data.dir = tempdir(),
#'                        prev.thld = 0.5)
#'
#' # Check results
#' str(result)
#' }
#'
#' @export
E.geodesic.X <- function(X,
                         strand.ids,
                         dist.along.strand.geodesic,
                         data.dir,
                         winsorize = TRUE,
                         winsorize.p = 0.025,
                         min.max.normalize = TRUE,
                         prev.thld = 0.9,
                         min.sample.count = 40,
                         rerun = FALSE,
                         n.partitions = 1,
                         partition.i = 1,
                         verbose = TRUE) {

  # Input validation
  if (!is.matrix(X) || !is.numeric(X)) {
    stop("X must be a numeric matrix")
  }

  if (!all(is.finite(X))) {
    stop("X must contain only finite values")
  }

  if (is.null(rownames(X))) {
    stop("X must have row names corresponding to sample IDs")
  }

  if (!is.character(strand.ids)) {
    stop("strand.ids must be a character vector")
  }

  if (!is.numeric(dist.along.strand.geodesic)) {
    stop("dist.along.strand.geodesic must be a numeric vector")
  }

  if (!dir.exists(data.dir)) {
    stop("data.dir does not exist: ", data.dir)
  }

  if (winsorize.p < 0 || winsorize.p > 1) {
    stop("winsorize.p must be between 0 and 1")
  }

  if (prev.thld < 0 || prev.thld > 1) {
    stop("prev.thld must be between 0 and 1")
  }

  if (partition.i > n.partitions || partition.i < 1) {
    stop("partition.i must be between 1 and n.partitions")
  }

  # Find common samples between X and strand
  comm.ids <- intersect(strand.ids, rownames(X))

  if (length(comm.ids) < min.sample.count) {
    stop("The number of samples common to X and the strand is less than min.sample.count: ",
         length(comm.ids), " < ", min.sample.count)
  }

  n.comm.ids <- length(comm.ids)

  if (verbose) {
    cat("The number of samples in the strand:", length(strand.ids), "\n")
    cat("The number of samples in X:", nrow(X), "\n")
    cat("The number of samples common to X and the strand:", n.comm.ids, "\n")
  }

  # Subset to common samples
  X <- X[comm.ids, , drop = FALSE]
  dist.along.strand.geodesic <- dist.along.strand.geodesic[comm.ids]

  # Filter columns based on prevalence threshold
  n.det <- apply(X, 2, function(x) sum(x != 0))
  prev <- n.det / n.comm.ids
  idx <- prev >= prev.thld
  nc.X.before <- ncol(X)
  X <- X[, idx, drop = FALSE]

  if (ncol(X) == 0) {
    stop("No columns remain after prevalence filtering with threshold ", prev.thld)
  }

  # Adjust winsorize.p if needed
  min.winsorize.p <- 1 / n.comm.ids
  if (winsorize.p < min.winsorize.p) {
    if (verbose) {
      cat("Adjusted winsorize.p from", winsorize.p, "to", min.winsorize.p, "\n")
    }
    winsorize.p <- min.winsorize.p
  }

  # Apply winsorization if requested
  if (winsorize) {
    X <- apply(X, 2, function(x) right.winsorize(x, p = winsorize.p))
  }

  # Apply normalization if requested
  y.binary <- FALSE
  if (min.max.normalize) {
    X <- apply(X, 2, minmax.normalize)
    y.binary <- TRUE
  }

  if (verbose) {
    cat("The number of columns of X before prevalence filtering:", nc.X.before, "\n")
    cat("The number of columns of X after prevalence filtering:", ncol(X), "\n")
    ptm <- proc.time()
    cat("Calculating association statistics for the columns of X...\n")
  }

  # Function to process one column
  process_one_column <- function(col.i) {
    if (verbose && n.partitions == 1) {
      cat("\r", col.i)
    }

    col.id <- colnames(X)[col.i]
    standardized.id <- standardize.string(col.id)

    # Use standardized name with column index to ensure uniqueness
    file.name <- paste0(standardized.id, "_", col.i, ".rda")
    file <- file.path(data.dir, file.name)

    if (!file.exists(file) || rerun) {
      y <- X[, col.i]
      x <- dist.along.strand.geodesic

      # For non-normalized data, filter to positive values only
      if (!min.max.normalize) {
        idx <- y > 0
        if (sum(idx) < 3) {  # Need at least 3 points for meaningful analysis
          return(list(col.id = col.id,
                      standardized.id = standardized.id,
                      file = NA))
        }
        y <- y[idx]
        x <- x[idx]
      }

      # Run association test
      fassoc1.res <- fassoc1.test(x, y, plot.it = FALSE, verbose = FALSE)

      # Save results
      Ey <- fassoc1.res$Ey
      pval <- fassoc1.res$p.value
      save(Ey, pval, file = file)
    }

    list(col.id = col.id,
         standardized.id = standardized.id,
         file = file)
  }

  # Initialize result containers
  save.files <- c()
  name.tbl <- c()

  # Process columns based on partitioning strategy
  if (n.partitions == 1) {
    # Process all columns
    for (col.i in seq_len(ncol(X))) {
      res <- process_one_column(col.i)
      if (!is.na(res$file)) {
        save.files[res$standardized.id] <- res$file
        name.tbl[res$standardized.id] <- res$col.id
      }
    }
    if (verbose) cat("\n")

  } else {
    # Process only the specified partition
    if (verbose) {
      cat("Splitting the columns of X into", n.partitions, "partitions\n")
      cat("Processing partition:", partition.i, "\n")
    }

    # Create partition indices
    col.indices <- seq_len(ncol(X))
    partition.assignments <- rep(1:n.partitions, length.out = length(col.indices))
    indices.to.process <- col.indices[partition.assignments == partition.i]

    # Process columns in this partition
    for (col.i in indices.to.process) {
      res <- process_one_column(col.i)
      if (!is.na(res$file)) {
        save.files[res$standardized.id] <- res$file
        name.tbl[res$standardized.id] <- res$col.id
      }
    }
  }

  if (verbose) {
    elapsed.time(ptm)
    cat("Completed processing", length(save.files), "columns\n")
  }

  # Return results
  list(X = X,
       dist.along.strand.geodesic = dist.along.strand.geodesic,
       data.dir = data.dir,
       save.files = save.files,
       name.tbl = name.tbl)
}
