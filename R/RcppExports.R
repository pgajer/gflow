# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

Rcpp_graph_kernel_smoother <- function(adj, w, y, bandwidth, with_details = FALSE) {
    .Call(`_gflow_Rcpp_graph_kernel_smoother`, adj, w, y, bandwidth, with_details)
}

#' Fully Adaptive Mean Shift with Gradient Field Averaging (C++ engine)
#'
#' Low-level Rcpp wrapper. Prefer calling the R wrapper
#' \code{adaptive_mean_shift_gfa()} for a friendlier interface.
#'
#' @param X numeric matrix (n x d).
#' @param k integer, k-NN for gradient estimation (excl. self).
#' @param density_k integer, k-NN for density estimation (excl. self).
#' @param n_steps integer, number of iterations.
#' @param initial_step_size positive numeric, initial per-point step size.
#' @param ikernel integer kernel id (1=Gaussian, 2=Epanechnikov, 3=Quartic).
#' @param dist_normalization_factor numeric > 0.
#' @param average_direction_only logical; if TRUE, average directions only.
#' @param momentum numeric, gradient momentum (default 0.9).
#' @param increase_factor numeric, step up factor (default 1.2).
#' @param decrease_factor numeric, step down factor (default 0.5).
#'
#' @return list with \code{X_traj} (list of n x d matrices over iterations)
#'   and \code{median_kdistances} (numeric).
#' @export
rcpp_adaptive_mean_shift_gfa <- function(X, k, density_k, n_steps, initial_step_size, ikernel = 1L, dist_normalization_factor = 1.01, average_direction_only = FALSE, momentum = 0.9, increase_factor = 1.2, decrease_factor = 0.5) {
    .Call(`_gflow_rcpp_adaptive_mean_shift_gfa`, X, k, density_k, n_steps, initial_step_size, ikernel, dist_normalization_factor, average_direction_only, momentum, increase_factor, decrease_factor)
}

#' kNN-Adaptive Mean Shift with Gradient Field Averaging (C++ engine)
#'
#' Low-level Rcpp wrapper. Prefer calling the R wrapper
#' \code{knn_adaptive_mean_shift_gfa()} for a friendlier interface.
#'
#' @param X numeric matrix (n x d).
#' @param k integer, k-NN for gradient estimation (excl. self).
#' @param density_k integer, k-NN for density estimation (excl. self).
#' @param n_steps integer, number of iterations.
#' @param step_size positive numeric step size (constant over iterations).
#' @param ikernel integer kernel id (1=Gaussian, 2=Epanechnikov, 3=Quartic).
#' @param dist_normalization_factor numeric > 0.
#' @param average_direction_only logical; if TRUE, average directions only.
#'
#' @return list with \code{X_traj} (list of n x d matrices over iterations)
#'   and \code{median_kdistances} (numeric).
#' @export
rcpp_knn_adaptive_mean_shift_gfa <- function(X, k, density_k, n_steps, step_size, ikernel = 1L, dist_normalization_factor = 1.01, average_direction_only = FALSE) {
    .Call(`_gflow_rcpp_knn_adaptive_mean_shift_gfa`, X, k, density_k, n_steps, step_size, ikernel, dist_normalization_factor, average_direction_only)
}

