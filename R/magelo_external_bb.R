## ============================================================================
## R Wrappers for External Bayesian Bootstrap Functions
## ============================================================================
##
## These functions enable paired BB comparisons by using pre-generated
## Dirichlet weights. This is essential for proper paired hypothesis testing.
##
## @author Pawel Gajer
## @date 2025
## ============================================================================


#' Generate Dirichlet(1,...,1) Weights for Bayesian Bootstrap
#'
#' Generates a matrix of Dirichlet weights that can be used for paired
#' Bayesian bootstrap comparisons. Each column contains weights that sum to n
#' (not normalized to 1, as BB convention uses n * w).
#'
#' @param n     Integer. Number of data points (length of weight vectors).
#' @param n.BB  Integer. Number of BB iterations (columns).
#' @param seed  Integer or NULL. Random seed for reproducibility.
#'
#' @return A numeric matrix of dimension n x n.BB, where each column contains
#'   Dirichlet(1,...,1) weights scaled to sum to n.
#'
#' @details
#' The Dirichlet(1,...,1) distribution is uniform on the (n-1)-dimensional
#' simplex. Weights are generated by:
#' 1. Draw n independent Exponential(1) random variables
#' 2. Normalize to sum to n
#'
#' The resulting weights have mean 1 for each element, which is the expected
#' value under uniform sampling.
#'
#' @examples
#' \dontrun{
#' # Generate 100 weight vectors for 50 data points
#' lambda <- generate.dirichlet.weights(50, 100, seed = 123)
#'
#' # Verify columns sum to n
#' colSums(lambda)  # Should all be 50
#' }
#'
#' @export
generate.dirichlet.weights <- function(n, n.BB, seed = NULL) {

    stopifnot(is.numeric(n) && length(n) == 1 && n >= 2)
    stopifnot(is.numeric(n.BB) && length(n.BB) == 1 && n.BB >= 1)

    n <- as.integer(n)
    n.BB <- as.integer(n.BB)

    if (!is.null(seed)) {
        set.seed(seed)
    }

    ## Call C function
    lambda <- .Call("S_generate_dirichlet_weights",
                    n, n.BB,
                    PACKAGE = "gflow")

    return(lambda)
}


#' Bayesian Bootstrap gpredictions with External Weights
#'
#' Generates BB gpredictions (predictions on grid) using externally provided
#' Dirichlet weights. This enables paired comparisons where signal and null
#' computations use the same weights.
#'
#' @param n.BB         Integer. Number of BB iterations.
#' @param nn.i         Matrix of neighbor indices (ng x K).
#' @param nn.x         Matrix of x values over neighbors (ng x K).
#' @param nn.y         Matrix of y values over neighbors (ng x K).
#' @param y.binary     Logical. If TRUE, restrict predictions to \eqn{[0,1]}.
#' @param nn.w         Matrix of base weights (ng x K).
#' @param nx           Integer. Number of original data points.
#' @param max.K        Integer vector. Maximum neighbor indices per grid point.
#' @param degree       Integer. Polynomial degree (1 or 2).
#' @param grid.nn.i    Matrix of grid neighbor indices.
#' @param grid.nn.x    Matrix of grid neighbor x values.
#' @param grid.nn.w    Matrix of grid neighbor weights.
#' @param grid.max.K   Integer vector. Max neighbor indices for grid.
#' @param lambda       Matrix of external weights (nx x n.BB).
#'
#' @return A list with components:
#'   \describe{
#'     \item{bb.gpredictions}{Matrix of BB gpredictions (ng x n.BB)}
#'     \item{bb.dgpredictions}{Matrix of BB derivative estimates (ng x n.BB)}
#'   }
#'
#' @details
#' This function is identical to \code{get.BB.gpredictions} except that it
#' accepts pre-generated Dirichlet weights instead of generating them internally.
#' The lambda matrix should be generated using \code{generate.dirichlet.weights}.
#'
#' @seealso \code{\link{generate.dirichlet.weights}}
#'
#' @keywords internal
get.BB.gpredictions.external <- function(n.BB,
                                         nn.i,
                                         nn.x,
                                         nn.y,
                                         y.binary,
                                         nn.w,
                                         nx,
                                         max.K,
                                         degree,
                                         grid.nn.i,
                                         grid.nn.x,
                                         grid.nn.w,
                                         grid.max.K,
                                         lambda) {

    ## Input validation
    stopifnot(is.matrix(lambda))
    stopifnot(nrow(lambda) == nx)
    stopifnot(ncol(lambda) == n.BB)

    ng <- nrow(nn.i)
    K <- ncol(nn.i)

    grid.ng <- nrow(grid.nn.i)
    grid.K <- ncol(grid.nn.i)

    ## Call C function via .Call
    result <- .Call("S_get_BB_Eyg_external",
                    as.integer(n.BB),
                    as.integer(t(nn.i - 1)),      # 0-based, transposed
                    as.double(t(nn.x)),
                    as.double(t(nn.y)),
                    as.integer(y.binary),
                    as.double(t(nn.w)),
                    as.integer(nx),
                    as.integer(K),                # nrTnn after transpose
                    as.integer(ng),               # ncTnn after transpose
                    as.integer(max.K - 1),        # 0-based
                    as.integer(degree),
                    as.integer(t(grid.nn.i - 1)), # 0-based, transposed
                    as.double(t(grid.nn.x)),
                    as.double(t(grid.nn.w)),
                    as.integer(grid.K),           # nrTgrid_nn
                    as.integer(grid.ng),          # ncTgrid_nn
                    as.integer(grid.max.K - 1),   # 0-based
                    as.double(lambda),
                    PACKAGE = "gflow")

    return(result)
}


#' Fit magelo Model with External BB Weights
#'
#' A wrapper around magelo that uses externally provided Dirichlet weights
#' for Bayesian bootstrap. This enables paired comparisons.
#'
#' @param x           Numeric vector of predictor values.
#' @param y           Numeric vector of response values.
#' @param lambda      Matrix of external BB weights (length(x) x n.BB).
#' @param bw          Bandwidth parameter. If NULL, automatically selected.
#' @param grid.size   Number of grid points. Default is 400.
#' @param degree      Polynomial degree (0, 1, or 2). Default is 1.
#' @param min.K       Minimum number of neighbors. Default is 5.
#' @param nn.kernel   Kernel function. Default is "epanechnikov".
#'
#' @return A list with components:
#'   \describe{
#'     \item{gpredictions}{Point estimate on grid}
#'     \item{BB.gpredictions}{Matrix of BB gpredictions (ng x n.BB)}
#'     \item{BB.dgpredictions}{Matrix of BB derivatives (ng x n.BB)}
#'     \item{xgrid}{Grid points}
#'     \item{opt.bw}{Optimal bandwidth used}
#'   }
#'
#' @details
#' This function fits a local polynomial regression model and generates
#' BB samples using the provided external weights. For paired comparisons,
#' call this function twice (for signal and null) with the same lambda matrix.
#'
#' @examples
#' \dontrun{
#' # Generate data
#' x <- runif(100)
#' y <- sin(2*pi*x) + rnorm(100, sd = 0.2)
#'
#' # Generate shared weights
#' lambda <- generate.dirichlet.weights(100, 500)
#'
#' # Fit signal model
#' signal <- magelo.with.external.BB(x, y, lambda)
#'
#' # Fit null model (permuted y)
#' null <- magelo.with.external.BB(x, sample(y), lambda)
#'
#' # Now signal and null BB samples use the same weights
#' }
#'
#' @export
magelo.with.external.BB <- function(x,
                                    y,
                                    lambda,
                                    bw = NULL,
                                    grid.size = 400,
                                    degree = 1,
                                    min.K = 5,
                                    nn.kernel = "epanechnikov") {

    ## Input validation
    stopifnot(is.numeric(x) && is.numeric(y))
    stopifnot(length(x) == length(y))
    stopifnot(is.matrix(lambda))
    stopifnot(nrow(lambda) == length(x))

    nx <- length(x)
    n.BB <- ncol(lambda)

    ## Check for binary y
    y.binary <- all(y %in% c(0, 1))

    ## Sort by x
    o <- order(x)
    x <- x[o]
    y <- y[o]
    ## Reorder lambda rows accordingly
    lambda <- lambda[o, , drop = FALSE]

    ## Define grid
    x.range <- range(x)
    dx <- diff(x.range)
    xgrid <- seq(x.range[1], x.range[2], length = grid.size)

    ## Set bandwidth if not provided
    if (is.null(bw)) {
        f <- 0.2
        window.size <- f * dx
        bw <- window.size / 2
    }

    ## Get nearest neighbors (requires FNN package or similar)
    if (!requireNamespace("FNN", quietly = TRUE)) {
        stop("Package 'FNN' is required for magelo.with.external.BB")
    }

    nn <- FNN::get.knnx(x, xgrid, k = nx - 1)
    nn.i <- nn$nn.index
    nn.d <- nn$nn.dist

    ## Compute weights using kernel
    ## This mirrors the get.bws and row.weighting logic in magelo
    nn.r <- pmax(nn.d[, min.K], bw)
    nn.w <- matrix(0, nrow = grid.size, ncol = nx - 1)
    max.K <- integer(grid.size)

    kernels <- c("epanechnikov", "triangular", "tr.exponential", "normal")
    nn.kernel <- match.arg(nn.kernel, kernels)

    for (i in seq_len(grid.size)) {
        r <- nn.r[i]
        d <- nn.d[i, ]
        u <- d / r

        if (nn.kernel == "epanechnikov") {
            w <- pmax(0, 0.75 * (1 - u^2))
        } else if (nn.kernel == "triangular") {
            w <- pmax(0, 1 - abs(u))
        } else if (nn.kernel == "tr.exponential") {
            w <- exp(-u^2)
            w[u > 1] <- 0
        } else {  # normal
            w <- dnorm(u)
        }

        nn.w[i, ] <- w
        max.K[i] <- max(which(w > 0))
    }

    ## Normalize weights
    rs <- rowSums(nn.w)
    nn.w <- nn.w / rs

    ## x and y over neighbors
    nn.x <- matrix(x[nn.i], nrow = grid.size)
    nn.y <- matrix(y[nn.i], nrow = grid.size)

    ## For degree > 0, we need grid neighbor structures for prediction
    ## Get grid-to-grid neighbors
    grid.nn <- FNN::get.knnx(xgrid, xgrid, k = min(grid.size - 1, 20))
    grid.nn.i <- grid.nn$nn.index
    grid.nn.d <- grid.nn$nn.dist

    ## Grid weights
    grid.nn.r <- pmax(grid.nn.d[, min(5, ncol(grid.nn.d))], bw / 2)
    grid.nn.w <- matrix(0, nrow = grid.size, ncol = ncol(grid.nn.i))
    grid.max.K <- integer(grid.size)

    for (i in seq_len(grid.size)) {
        r <- grid.nn.r[i]
        d <- grid.nn.d[i, ]
        u <- d / r

        if (nn.kernel == "epanechnikov") {
            w <- pmax(0, 0.75 * (1 - u^2))
        } else if (nn.kernel == "triangular") {
            w <- pmax(0, 1 - abs(u))
        } else if (nn.kernel == "tr.exponential") {
            w <- exp(-u^2)
            w[u > 1] <- 0
        } else {
            w <- dnorm(u)
        }

        grid.nn.w[i, ] <- w
        grid.max.K[i] <- max(which(w > 0))
    }

    grid.nn.w <- grid.nn.w / rowSums(grid.nn.w)
    grid.nn.x <- matrix(xgrid[grid.nn.i], nrow = grid.size)

    ## Fit point estimate using standard magelo
    ## (We could also compute this from the BB samples, but calling magelo
    ## ensures consistency)
    if (exists("magelo")) {
        base.fit <- magelo(x, y, bw = bw, grid.size = grid.size,
                           degree = degree, min.K = min.K,
                           n.BB = 0, get.BB.gpredictions = FALSE)
        gpredictions <- base.fit$gpredictions
    } else {
        ## Fallback: compute directly
        gpredictions <- rep(NA, grid.size)
        warning("magelo function not found, gpredictions not computed")
    }

    ## Get BB samples with external weights
    if (degree == 0) {
        ## Degree 0 case: weighted means
        ## For now, compute in R (could add C function later)
        BB.gpredictions <- matrix(NA, nrow = grid.size, ncol = n.BB)
        BB.dgpredictions <- matrix(0, nrow = grid.size, ncol = n.BB)

        for (b in seq_len(n.BB)) {
            lambda.b <- lambda[, b]

            ## Apply weights to nn.w
            bb.nn.w <- nn.w * lambda.b[nn.i]
            bb.nn.w <- bb.nn.w / rowSums(bb.nn.w)

            ## Weighted means
            BB.gpredictions[, b] <- rowSums(nn.y * bb.nn.w)
        }

    } else {
        ## Degree 1 or 2: use C function
        BB.res <- get.BB.gpredictions.external(
            n.BB = n.BB,
            nn.i = nn.i,
            nn.x = nn.x,
            nn.y = nn.y,
            y.binary = as.integer(y.binary),
            nn.w = nn.w,
            nx = nx,
            max.K = max.K,
            degree = degree,
            grid.nn.i = grid.nn.i,
            grid.nn.x = grid.nn.x,
            grid.nn.w = grid.nn.w,
            grid.max.K = grid.max.K,
            lambda = lambda
        )

        BB.gpredictions <- BB.res$bb.gpredictions
        BB.dgpredictions <- BB.res$bb.dgpredictions
    }

    ## Return results
    list(
        gpredictions = gpredictions,
        BB.gpredictions = BB.gpredictions,
        BB.dgpredictions = BB.dgpredictions,
        xgrid = xgrid,
        opt.bw = bw,
        x = x,
        y = y,
        degree = degree,
        n.BB = n.BB,
        lambda = lambda
    )
}
