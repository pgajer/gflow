% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/graph_diffusion_smoother.R
\name{graph.diffusion.matrix.smoother}
\alias{graph.diffusion.matrix.smoother}
\title{Graph Diffusion Matrix Smoother}
\usage{
graph.diffusion.matrix.smoother(
  X,
  graph,
  edge.lengths,
  weights = NULL,
  n.time.steps = 100,
  step.factor = 0.5,
  normalize = 0,
  imputation.method = "local_mean_threshold",
  max.iterations = 10,
  convergence.threshold = 1e-06,
  ikernel = 1,
  dist.normalization.factor = 1.01,
  n.CVs = 0,
  n.CV.folds = 10,
  epsilon = 1e-10,
  seed = 0
)
}
\arguments{
\item{X}{A numeric matrix where rows represent vertices and columns represent
features to be smoothed.}

\item{graph}{A list of integer vectors representing the adjacency structure
(1-based indexing).}

\item{edge.lengths}{A list of numeric vectors containing edge lengths.}

\item{weights}{An optional numeric vector of vertex weights. If \code{NULL},
all vertices are weighted equally.}

\item{n.time.steps}{An integer specifying the number of diffusion steps.
Default is 100.}

\item{step.factor}{A numeric value between 0 and 1 for step size. Default is 0.5.}

\item{normalize}{An integer (0, 1, or 2) for normalization method. Default is 0.}

\item{imputation.method}{Either an integer (0-4) or a character string:
\itemize{
\item 0 or "local_mean_threshold": Uses local mean threshold (default)
\item 1 or "neighborhood_matching": Neighborhood-based matching
\item 2 or "iterative_neighborhood_matching": Iterative version
\item 3 or "supplied_threshold": User-supplied threshold
\item 4 or "global_mean_threshold": Global mean threshold
}}

\item{max.iterations}{Maximum iterations for iterative methods. Default is 10.}

\item{convergence.threshold}{Convergence threshold. Default is 1e-6.}

\item{ikernel}{An integer (0-4) for kernel type. Default is 1.}

\item{dist.normalization.factor}{Distance normalization factor > 1. Default is 1.01.}

\item{n.CVs}{Number of cross-validation runs. Default is 0.}

\item{n.CV.folds}{Number of CV folds. Default is 10.}

\item{epsilon}{Numerical tolerance. Default is 1e-10.}

\item{seed}{Random seed for CV. Default is 0.}
}
\value{
A list containing:
\item{X.traj}{A list of matrices representing the diffusion trajectory.}
\item{mean.cv.error}{A vector of mean CV errors per time step.}
}
\description{
Applies graph diffusion smoothing to each column of a matrix independently.
This is useful for smoothing multiple features or time series on the same graph
structure simultaneously.
}
\examples{
\dontrun{
# Create example data
n <- 50
p <- 5
X <- matrix(rnorm(n * p), n, p)

# Create a ring graph
graph <- vector("list", n)
edge.lengths <- vector("list", n)
for(i in 1:n) {
  graph[[i]] <- c(ifelse(i == 1, n, i-1), ifelse(i == n, 1, i+1))
  edge.lengths[[i]] <- c(1, 1)
}

result <- graph.diffusion.matrix.smoother(
  X = X,
  graph = graph,
  edge.lengths = edge.lengths,
  n.time.steps = 20
)
}

}
