% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/graph_utils.R
\name{identical.vertex.set.weighted.graph.similarity}
\alias{identical.vertex.set.weighted.graph.similarity}
\title{Weighted Graph Matching between two graphs with identical vertex sets.}
\usage{
identical.vertex.set.weighted.graph.similarity(
  graph1.adj.list,
  graph1.weights,
  graph2.adj.list,
  graph2.weights,
  calculate.normalized.deviation = FALSE
)
}
\arguments{
\item{graph1.adj.list}{A list representing the adjacency list of the first graph.}

\item{graph1.weights}{A list representing the weights of the first graph.}

\item{graph2.adj.list}{A list representing the adjacency list of the second graph.}

\item{graph2.weights}{A list representing the weights of the second graph.}

\item{calculate.normalized.deviation}{Logical indicating whether to calculate the
normalized deviation (default: FALSE). If TRUE, returns normalized deviation;
if FALSE, returns raw distance difference.}
}
\value{
A numeric value between 0 and 1 representing the normalized
deviation between the two graphs. A value closer to 0 indicates higher
similarity between the graphs.
}
\description{
This function computes a similarity measure between two weighted graphs
derived from the same dataset. It assumes that both graphs have identical
vertex sets and indexing, eliminating the need for vertex permutation.
}
\details{
The function performs the following steps:
\enumerate{
\item Converts the input lists to igraph objects.
\item Calculates the distance matrices for both graphs using edge weights.
\item Computes the L1 norm of the difference between these distance matrices.
\item Normalizes the result using the maximum possible deviation, which is
based on the largest distance found in either graph.
}
}
\note{
\itemize{
\item This function assumes that the graphs are undirected.
\item The weights should be stored in the input lists as a vector named 'weight'.
\item For disconnected graphs, infinite distances are ignored in calculating
the maximum distance.
}
}
\examples{
# Create adjacency lists (as lists, not matrices)
g1.adj.list <- list(c(2), c(3), c(1))  # vertex 1->2, vertex 2->3, vertex 3->1
g1.weights <- list(c(1), c(2), c(3))   # corresponding weights

g2.adj.list <- list(c(2), c(3), c(1))  # same structure
g2.weights <- list(c(1), c(3), c(2))   # different weights

similarity <- identical.vertex.set.weighted.graph.similarity(
  g1.adj.list, g1.weights, g2.adj.list, g2.weights
)
print(similarity)

}
