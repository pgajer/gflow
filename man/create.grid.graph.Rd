% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/uniform_grid_graph.R
\name{create.grid.graph}
\alias{create.grid.graph}
\title{Create a Refined Graph with Uniformly Spaced Grid Vertices}
\usage{
create.grid.graph(
  adj.list,
  weight.list,
  grid.size,
  start.vertex = 1L,
  snap.tolerance = 0.1
)
}
\arguments{
\item{adj.list}{A list where each element \code{i} is an integer vector containing the
indices of vertices adjacent to vertex \code{i}. Vertex indices must be 1-based
(following R's convention). The graph structure must be undirected, meaning if
vertex \code{j} appears in \code{adj.list[[i]]}, then vertex \code{i} must appear
in \code{adj.list[[j]]}.}

\item{weight.list}{A list matching the structure of \code{adj.list}, where each element
contains the corresponding edge weights (typically distances or lengths).
\code{weight.list[[i]][j]} should contain the weight of the edge between vertex
\code{i} and vertex \code{adj.list[[i]][j]}. Weights must be positive numbers.}

\item{grid.size}{A positive integer specifying the desired number of grid vertices
to add. Must be at least 2. The actual number of added vertices may differ
slightly from this target due to the distribution of edge lengths in the graph.}

\item{start.vertex}{An integer specifying the starting vertex for graph traversal.
Must be between 1 and the number of vertices in the input graph. Defaults to 1.}

\item{snap.tolerance}{A numeric value between 0 and 0.5 controlling the snapping
behavior when placing grid vertices near existing vertices. When a grid vertex
would be placed within this fraction of an edge length from an existing vertex,
it is merged with that vertex instead. Defaults to 0.1.}
}
\value{
A list with three components:
\describe{
\item{\code{adj_list}}{A list representing the adjacency structure of the refined
graph, including both original and grid vertices. The structure follows the same
format as the input \code{adj.list}.}
\item{\code{weight_list}}{A list containing edge weights for the refined graph,
structured to match the new \code{adj.list}. Edge weights are adjusted to
reflect the new distances between connected vertices.}
\item{\code{grid_vertices}}{An integer vector containing the 1-based indices of
the newly added grid vertices in the refined graph.}
}
}
\description{
Creates a refined version of an input graph by adding grid vertices (points) along
its edges. The grid vertices are placed to maintain approximately uniform spacing
throughout the graph structure. This function is particularly useful for tasks
that require a denser sampling of points along the graph edges, such as
graph-based interpolation or spatial analysis.
}
\details{
The function performs a breadth-first traversal starting from \code{start.vertex}
to determine the order in which edges are processed. Grid vertices are distributed
across edges based on their relative lengths, with longer edges receiving more grid
vertices. The algorithm ensures that the spacing between consecutive vertices
(original or grid) along any edge is as uniform as possible.

The \code{snap.tolerance} parameter helps prevent the creation of vertices that are
too close to existing ones, which can cause numerical issues in downstream analyses.
}
\examples{
# Create a simple path graph with 3 vertices
adj <- list(c(2L), c(1L, 3L), c(2L))
weights <- list(c(1.0), c(1.0, 2.0), c(2.0))

# Add approximately 5 grid vertices
result <- create.grid.graph(adj, weights, grid.size = 5)

# Examine the results
cat("Original graph had", length(adj), "vertices\\\\n")
cat("Refined graph has", length(result$adj.list), "vertices\\\\n")
cat("Grid vertices added:", length(result$grid.vertices), "\\\\n")
cat("Indices of grid vertices:", result$grid.vertices, "\\\\n")

\dontrun{
# Create a more complex graph (a cycle with varying edge weights)
n <- 6
adj <- lapply(1:n, function(i) c(ifelse(i == 1, n, i - 1),
                                 ifelse(i == n, 1, i + 1)))
weights <- lapply(1:n, function(i) runif(2, 0.5, 2.0))

# Refine with more grid vertices
result <- create.grid.graph(adj, weights, grid.size = 20)

g <- igraph::graph_from_adj_list(result$adj.list, mode = "undirected")
plot(g, vertex.color = ifelse(1:length(result$adj.list) \%in\%
                                result$grid.vertices, "red", "blue"))
}

}
\seealso{
\code{\link[igraph]{graph_from_adj_list}} for converting adjacency lists to igraph objects
}
