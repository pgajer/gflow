% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/graph_utils.R
\name{wgraph.prune.long.edges}
\alias{wgraph.prune.long.edges}
\title{Prune Long Edges in a Weighted Graph}
\usage{
wgraph.prune.long.edges(
  graph,
  edge.lengths,
  alt.path.len.ratio.thld,
  use.total.length.constraint = TRUE,
  verbose = FALSE
)
}
\arguments{
\item{graph}{A list of integer vectors representing the adjacency list of the graph.
Each element of the list corresponds to a vertex, and contains the indices of its neighboring vertices.
The graph should use 1-based indexing (as is standard in R).}

\item{edge.lengths}{A list of numeric vectors representing the lengths of edges.
Each element corresponds to a vertex, and contains the lengths of edges to its neighbors.
The structure should match that of the \code{graph} parameter.}

\item{alt.path.len.ratio.thld}{A single numeric value representing the threshold for the
alternative path length ratio. Edges are pruned if an alternative path is found with
length less than this ratio times the original edge length.}

\item{use.total.length.constraint}{A logical value. If TRUE, the total length of the alternative path
must be less than the original edge length. If FALSE, each edge in the alternative path
must be shorter than the original edge length. Default is TRUE.}

\item{verbose}{A logical value. If TRUE, progress information will be printed during the pruning process.
Default is FALSE.}
}
\value{
A list containing four elements:
\item{adj_list}{A list of integer vectors representing the adjacency list of the pruned graph.}
\item{edge_lengths_list}{A list of numeric vectors representing the edge lengths in the pruned graph.}
\item{path_lengths}{A numeric vector of alternative path lengths found during pruning.}
\item{edge_lengths}{A numeric vector of original edge lengths corresponding to path_lengths.}
}
\description{
This function prunes long edges in a weighted graph based on the existence of shorter alternative paths.
It uses a C++ implementation for efficiency and returns the pruned graph along with information about the pruning process.
}
\details{
The function first converts the input graph to 0-based indexing for the C++ function,
then calls the C++ implementation to perform the pruning. The pruned graph is converted
back to 1-based indexing before being returned.

The pruning process iterates through edges from longest to shortest. For each edge,
it searches for an alternative path. If a path is found that is shorter than the threshold
ratio times the original edge length, the edge is removed from the graph.
}
\note{
\itemize{
\item The function assumes the input graph is undirected.
\item The input graph and edge lengths must be consistent (same length and structure).
\item The function may modify the order of vertices in the adjacency lists.
}
}
\examples{
\dontrun{
# Create a simple weighted graph
graph <- list(c(2,3), c(1,3), c(1,2))
edge.lengths <- list(c(1,2), c(1,3), c(2,3))
threshold <- 0.9

# Prune the graph
result <- wgraph.prune.long.edges(graph, edge.lengths, threshold,
                                  use.total.length.constraint = TRUE,
                                  verbose = TRUE)
# Examine the results
print(result$adj_list)
print(result$edge_lengths_list)
print(result$path_lengths)
print(result$edge_lengths)
}
}
