% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/path_graphs.R
\name{create.path.graph}
\alias{create.path.graph}
\title{Create a Path Graph with Limited Hop Distance}
\usage{
create.path.graph(graph, edge.lengths, h)
}
\arguments{
\item{graph}{A list where each element \code{i} is a numeric vector containing the
indices of vertices adjacent to vertex \code{i}. Indices should be 1-based
(following R convention). Each vertex \code{i} should have an entry in the
list, even if it has no neighbors (empty vector).}

\item{edge.lengths}{A list with the same structure as \code{graph} where each
element \code{i} contains the weights/lengths of the edges specified in
\code{graph[[i]]}. Must contain numeric values > 0. The order of weights
must correspond to the order of vertices in \code{graph[[i]]}.}

\item{h}{Integer >= 1 specifying the maximum number of hops allowed in the
path graph. A hop is a single edge traversal.}
}
\value{
An S3 object of class \code{"path.graph"} containing:
\describe{
\item{adj.list}{A list where \code{adj.list[[i]]} contains all vertices
reachable from vertex \code{i} within \code{h} hops}
\item{edge.length.list}{A list where \code{edge.length.list[[i]]} contains
the shortest path lengths to each vertex in \code{adj.list[[i]]}}
\item{hop.list}{A list where \code{hop.list[[i]]} contains the number of
hops required to reach each vertex in \code{adj.list[[i]]}}
\item{shortest.paths}{A list with components:
\describe{
\item{i}{Source vertex indices}
\item{j}{Target vertex indices}
\item{paths}{List of vertex sequences for each shortest path}
}}
}
}
\description{
Constructs a path graph from an input graph by finding all reachable vertices
within a specified maximum number of hops. For each pair of vertices, stores
the shortest path information along with edge weights and hop counts.
}
\details{
The function uses Dijkstra's algorithm to compute shortest paths from each
vertex to all reachable vertices within the specified hop limit. The algorithm
is implemented in C++ for performance. The resulting path graph can be used
for various network analyses where connectivity within a limited number of
steps is relevant.
}
\note{
\itemize{
\item All vertex indices in input and output are 1-based (R convention)
\item The function internally converts indices to 0-based for C++ processing
\item Empty adjacency lists are allowed for isolated vertices
\item The graph can be directed or undirected
\item Self-loops are not allowed
}
}
\examples{
\dontrun{
# Create a simple graph with 3 vertices
graph <- list(
  c(2),    # Vertex 1 connected to 2
  c(1, 3), # Vertex 2 connected to 1 and 3
  c(2)     # Vertex 3 connected to 2
)

# Define edge lengths
edge.lengths <- list(
  c(1.0),      # Length of edge 1->2
  c(1.0, 2.0), # Lengths of edges 2->1 and 2->3
  c(2.0)       # Length of edge 3->2
)

# Create path graph with maximum 2 hops
pg <- create.path.graph(graph, edge.lengths, h = 2)

# Print the path graph
print(pg)

# Get shortest path between vertices 1 and 3
path <- get.shortest.path(pg, 1, 3)
}

}
\seealso{
\code{\link[igraph]{shortest_paths}} for alternative shortest path calculations,
\code{\link{create.path.graph.series}} for creating multiple path graphs efficiently
}
