% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/deg0_lowess_graph_smoothing.R
\name{deg0.lowess.graph.smoothing}
\alias{deg0.lowess.graph.smoothing}
\title{Iterative Degree 0 LOWESS Graph Smoothing}
\usage{
deg0.lowess.graph.smoothing(
  adj.list,
  weight.list,
  X,
  max.iterations = 10,
  convergence.threshold = 1e-04,
  convergence.type = 1,
  k = 10,
  pruning.thld = 0.1,
  n.bws = 10,
  log.grid = TRUE,
  min.bw.factor = 0.05,
  max.bw.factor = 0.5,
  dist.normalization.factor = 1,
  kernel.type = 1,
  n.folds = 5,
  use.uniform.weights = FALSE,
  outlier.thld = 0.1,
  with.bw.predictions = FALSE,
  switch.to.residuals.after = NULL,
  verbose = FALSE
)
}
\arguments{
\item{adj.list}{A list of integer vectors representing the adjacency list of the graph.
Each element \code{adj.list[[i]]} contains the indices of vertices adjacent to vertex i.}

\item{weight.list}{A list of numeric vectors with edge weights corresponding to adjacencies.
Each element \code{weight.list[[i]][j]} is the weight of the edge from vertex i to
\code{adj.list[[i]][j]}.}

\item{X}{A numeric matrix where rows are samples and columns are features}

\item{max.iterations}{Maximum number of iterations to perform}

\item{convergence.threshold}{Threshold for convergence}

\item{convergence.type}{Type of convergence criteria:
1 = maximum absolute difference
2 = mean absolute difference
3 = maximum relative change}

\item{k}{Number of nearest neighbors for kNN graph construction}

\item{pruning.thld}{Threshold for pruning edges in graph construction}

\item{n.bws}{Number of candidate bandwidths for LOWESS}

\item{log.grid}{Logical, whether to use logarithmic spacing for bandwidth grid}

\item{min.bw.factor}{Factor for minimum bandwidth (multiplied by graph diameter)}

\item{max.bw.factor}{Factor for maximum bandwidth (multiplied by graph diameter)}

\item{dist.normalization.factor}{Factor for normalizing distances in kernel weight calculation}

\item{kernel.type}{Type of kernel function (1 = Gaussian, 2 = Exponential, etc.)}

\item{n.folds}{Number of cross-validation folds for bandwidth selection}

\item{use.uniform.weights}{Logical, whether to use uniform weights instead of kernel weights}

\item{outlier.thld}{Maximum proportion of vertices that can be identified as outliers
in a single iteration before terminating the smoothing process. When the graph
has multiple connected components, vertices not in the largest component are
considered outliers. If the proportion of outliers exceeds this threshold,
the algorithm stops to prevent excessive removal of data points. Must be between
0 and 0.5. Default is 0.1 (10\% of vertices).}

\item{with.bw.predictions}{Logical, whether to compute predictions for all bandwidths}

\item{switch.to.residuals.after}{Number of iterations to perform direct smoothing before
switching to residual smoothing (boosting mode). Default is max.iterations (never switch).
Set to 0 to use residual smoothing from the start.}

\item{verbose}{Logical, whether to print progress information}
}
\value{
A list containing:
\item{smoothed.graphs}{List of smoothed graphs at each iteration}
\item{smoothed.X}{List of smoothed data matrices at each iteration}
\item{convergence.metrics}{Numeric vector of convergence metrics at each iteration}
\item{iterations.performed}{Number of iterations actually performed}
\item{used.boosting}{Logical, whether boosting (residual smoothing) was used}
\item{vertex.mappings}{List of vertex mappings at each iteration}
\item{outlier.indices}{Integer vector of indices of identified outlier vertices}
}
\description{
Apply iterative degree 0 LOWESS smoothing to a graph and its associated data matrix.
At each iteration, conditional expectations of features are estimated using
locally weighted averages, and a new graph is constructed from the smoothed data.
}
\examples{
\dontrun{
# Create a graph and data matrix
graph <- create.iknn.graph(X, k = 10, pruning.thld = 0.1)

# Apply degree 0 LOWESS graph smoothing - traditional approach
result1 <- deg0.lowess.graph.smoothing(
  adj.list = graph$adj_list,
  weight.list = graph$weight_list,
  X = X,
  max.iterations = 10,
  convergence.threshold = 1e-4,
  convergence.type = 1,  # MAX.ABSOLUTE.DIFF
  k = 10,
  pruning.thld = 0.1,
  n.bws = 10,
  n.folds = 5,
  verbose = TRUE
)

# Apply degree 0 LOWESS graph smoothing with boosting
result2 <- deg0.lowess.graph.smoothing(
  adj.list = graph$adj_list,
  weight.list = graph$weight_list,
  X = X,
  max.iterations = 10,
  convergence.threshold = 1e-4,
  convergence.type = 1,  # MAX.ABSOLUTE.DIFF
  k = 10,
  pruning.thld = 0.1,
  n.bws = 10,
  n.folds = 5,
  switch.to.residuals.after = 2,  # Switch to boosting after 2 iterations
  verbose = TRUE
)

# Access final smoothed data matrix
X.smoothed <- result2$smoothed.X[[length(result2$smoothed.X)]]

# Plot convergence metrics for both approaches
plot(result1$convergence.metrics, type = "b", col = "blue",
     xlab = "Iteration", ylab = "Convergence Metric")
lines(result2$convergence.metrics, type = "b", col = "red")
legend("topright", legend = c("Traditional", "Boosting"),
       col = c("blue", "red"), lty = 1)
}

}
