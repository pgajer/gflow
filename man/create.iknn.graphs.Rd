% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/iknn_graphs.R
\name{create.iknn.graphs}
\alias{create.iknn.graphs}
\title{Create intersection k-nearest neighbor graphs with dual pruning}
\usage{
create.iknn.graphs(
  X,
  kmin,
  kmax,
  max.path.edge.ratio.deviation.thld = 0.1,
  path.edge.ratio.percentile = 0.5,
  compute.full = TRUE,
  pca.dim = 100,
  variance.explained = 0.99,
  n.cores = NULL,
  verbose = FALSE
)
}
\arguments{
\item{X}{A numeric matrix (or object coercible to a numeric matrix) with rows
= observations and columns = features.}

\item{kmin}{Integer \eqn{\ge 1}, the minimum k.}

\item{kmax}{Integer \eqn{> k_{\mathrm{min}}}, the maximum k.}

\item{max.path.edge.ratio.deviation.thld}{Numeric in \eqn{[0, 0.2)}.
Geometric pruning removes an edge \eqn{(i,j)} when there exists an
alternative path between \eqn{i} and \eqn{j} whose path/edge length ratio
minus 1.0 is \emph{less than} this threshold. This is a deviation
threshold \eqn{\delta} in \eqn{[0, 0.2)}. Internally we compare the
path-to-edge ratio R to \eqn{1 + \delta}.}

\item{path.edge.ratio.percentile}{Numeric in \eqn{[0,1]}. Only edges with
length above this percentile are considered for geometric pruning.}

\item{compute.full}{Logical. If \code{TRUE}, return the pruned graphs; if \code{FALSE},
return only edge statistics.}

\item{pca.dim}{Positive integer or \code{NULL}. If not \code{NULL} and \code{ncol(X) > pca.dim}, PCA is used to reduce to at most \code{pca.dim} components.}

\item{variance.explained}{Numeric in \eqn{(0,1]} or \code{NULL}. If not \code{NULL},
choose the smallest number of PCs whose cumulative variance explained
exceeds this threshold, capped by \code{pca.dim}.}

\item{n.cores}{Integer or \code{NULL}. Number of CPU cores. \code{NULL} uses the
maximum available (OpenMP build only).}

\item{verbose}{Logical; print progress and timing.}
}
\value{
A list of class \code{"iknn_graphs"} with entries:
\describe{
\item{k_statistics}{Matrix of per-\eqn{k} edge counts and reductions.
(If the C++ side supplies column names, theyâ€™re preserved.
Otherwise we add names consistent with what the C++ returns.)}
\item{geom_pruned_graphs}{If \code{compute.full=TRUE}, list of geometrically
pruned graphs (adjacency + weights); otherwise \code{NULL}.}
\item{isize_pruned_graphs}{If \code{compute.full=TRUE}, list of intersection-size
pruned graphs; otherwise \code{NULL}.}
\item{edge_pruning_stats}{List (per \eqn{k}) of matrices with edge-level
statistics (lengths, path/edge ratios, etc.).}
}
}
\description{
For each \eqn{k \in [k_{\mathrm{min}},\,k_{\mathrm{max}}]}, builds an
intersection-weighted k-NN graph and applies two pruning schemes:
(1) geometric (path-to-edge ratio) and (2) intersection-size.
Optionally performs PCA before graph construction.
}
\details{
Geometric pruning uses the deviation threshold
\code{max.path.edge.ratio.deviation.thld} and the filtering percentile
\code{path.edge.ratio.percentile}. Intersection-size pruning currently uses
a maximum alternative path length of 2.
}
\examples{
# Generate sample data
X <- matrix(rnorm(100 * 5), 100, 5)

# Basic usage
res1 <- create.iknn.graphs(
  X, kmin = 3, kmax = 10, n.cores = 1,
  compute.full = FALSE
)

# With custom pruning parameters
res2 <- create.iknn.graphs(
  X, kmin = 3, kmax = 10,
  max.path.edge.ratio.deviation.thld = 0.1,
  path.edge.ratio.percentile = 0.5,
  compute.full = TRUE,
  n.cores = 1,
  verbose = TRUE
)

# View statistics for each k
print(res2$k_statistics)

}
