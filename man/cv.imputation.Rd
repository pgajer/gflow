% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/graph_cv_imputation.R
\name{cv.imputation}
\alias{cv.imputation}
\title{Cross-Validation Imputation on Graphs}
\usage{
cv.imputation(
  test.set,
  graph,
  edge.lengths,
  y,
  y.binary,
  imputation.method = 1,
  max.iterations = 10,
  convergence.threshold = 1e-06,
  apply.binary.threshold = TRUE,
  binary.threshold = 0.5,
  kernel = "Epanechnikov",
  dist.normalization.factor = 1.01
)
}
\arguments{
\item{test.set}{A numeric vector of indices for the test set vertices (1-based).}

\item{graph}{A list of numeric vectors representing the graph structure.
Each element of the list corresponds to a vertex and contains the indices of its neighbors.}

\item{edge.lengths}{A list of edge lengths. The structure should match that of \code{graph}.}

\item{y}{A numeric vector of original vertex values.}

\item{y.binary}{A logical value indicating whether the data is binary (TRUE) or continuous (FALSE).}

\item{imputation.method}{A string or integer specifying the imputation method. Options are:
- 0 or "local_mean_threshold": Uses the mean of y computed over the training vertices (default).
- 1 or "neighborhood_matching": Uses a matching method based on local neighborhood statistics.
- 2 or "iterative_neighborhood_matching": Uses an iterative version of the neighborhood matching method.
- 3 or "supplied_threshold": Uses a user-supplied threshold value.
- 4 or "global_mean_threshold": Uses the global mean of y across all vertices.}

\item{max.iterations}{An integer specifying the maximum number of iterations for iterative methods.}

\item{convergence.threshold}{A numeric value specifying the convergence threshold for iterative methods.}

\item{apply.binary.threshold}{A logical value indicating whether to apply binary thresholding to the results.}

\item{binary.threshold}{A numeric value between 0 and 1 specifying the threshold for binary classification.}

\item{kernel}{A character string specifying the kernel function for distance weighting.
Options are "Box", "Triangular", "Epanechnikov", or "Gaussian".}

\item{dist.normalization.factor}{A numeric value greater than 1 used for normalizing distances.}
}
\value{
A numeric vector containing the imputed values for the test set vertices.
}
\description{
Performs cross-validation imputation on graph-structured data using various methods.
This function supports both binary and continuous data, and offers different
imputation strategies including local mean thresholding, neighborhood matching,
and iterative approaches.
}
\details{
This function serves as an R interface to a C++ implementation of graph-based
imputation methods. It handles various input checks and data type conversions
before calling the underlying C++ function.

The choice of imputation method, kernel function, and other parameters allows
for flexibility in addressing different types of graph-structured data and
imputation scenarios.
}
\note{
\itemize{
\item The function assumes that the graph structure is consistent and that all
vertex indices in test.set and training.set are valid.
\item For binary data (y.binary = TRUE), the imputed values will be either 0 or 1.
\item For continuous data, the imputed values may fall outside the range of the
original y values, depending on the chosen method.
}
}
\examples{
\dontrun{
# Example with a small graph
graph <- list(c(2,3), c(1,3), c(1,2,4), c(3))
y <- c(1, 0, 1, 0)
test.set <- c(2, 4)
result <- cv.imputation(test.set, graph, y = y, y.binary = TRUE,
                        imputation.method = "LOCAL_MEAN_THRESHOLD")
print(result)
}

}
\seealso{
For more details on graph-based imputation methods, see the documentation
of the underlying C++ implementation.
}
