% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/graph_spectral_smoother.R
\name{graph.spectral.smoother}
\alias{graph.spectral.smoother}
\title{Graph Spectral Smoother utilizing spectrum of graph Laplacian}
\usage{
graph.spectral.smoother(
  graph,
  edge.lengths,
  y,
  weights = NULL,
  imputation.method = 0,
  max.iterations = 10,
  convergence.threshold = 1e-06,
  apply.binary.threshold = TRUE,
  binary.threshold = 0.5,
  kernel = 1,
  dist.normalization.factor = 1.1,
  n.CVs = 0,
  n.CV.folds = 10,
  epsilon = 1e-10,
  min.plambda = 0.01,
  max.plambda = 0.2,
  seed = 0,
  verbose = FALSE
)
}
\arguments{
\item{graph}{A list of integer vectors representing the graph's adjacency list.
Each vector contains the indices of neighboring vertices (1-based).}

\item{edge.lengths}{A list of edge lengths. Structure should match that of graph.}

\item{y}{A numeric vector representing the graph signal to be smoothed.}

\item{weights}{A numeric vector of weights for each vertex. If NULL, uniform weights are used.}

\item{imputation.method}{Integer specifying the imputation method:
0: LOCAL_MEAN_THRESHOLD (default)
1: NEIGHBORHOOD_MATCHING
2: ITERATIVE_NEIGHBORHOOD_MATCHING
3: SUPPLIED_THRESHOLD
4: GLOBAL_MEAN_THRESHOLD}

\item{max.iterations}{Integer. Maximum iterations for iterative matching method. Default is 10.}

\item{convergence.threshold}{Numeric. Convergence threshold for iterative matching. Default is 1e-6.}

\item{apply.binary.threshold}{Logical. Whether to apply binary thresholding. Default is TRUE.}

\item{binary.threshold}{Numeric. Threshold for binary classification (0-1). Default is 0.5.}

\item{kernel}{Integer specifying the kernel function:
0: Constant, 1: Epanechnikov (default), 2: Triangular,
3: Truncated Exponential, 4: Normal}

\item{dist.normalization.factor}{Numeric. Scaling factor for distance normalization. Default is 1.01.}

\item{n.CVs}{Integer. Number of cross-validation iterations. Default is 0.}

\item{n.CV.folds}{Integer. Number of cross-validation folds. Default is 10.}

\item{epsilon}{Numeric. Small positive constant for numerical stability. Default is 1e-10.}

\item{min.plambda}{Numeric. Lower bound on proportion of eigenvectors to use. Default is 0.01.}

\item{max.plambda}{Numeric. Upper bound on proportion of eigenvectors to use. Default is 0.20.}

\item{seed}{Integer. Seed for random number generation. Default is 0.}

\item{verbose}{Logical. Whether to print additional information. Default is FALSE.}
}
\value{
A list containing:
\item{optimal.num.eigenvectors}{Optimal number of eigenvectors used for smoothing}
\item{y.smoothed}{Smoothed signal}
\item{cv.errors}{Cross-validation errors for each fold}
\item{mean.cv.errors}{Mean cross-validation errors across all folds}
\item{median.cv.errors}{Median cross-validation errors across all folds}
\item{Cmean.cv.errors}{Mean cross-validation errors computed in C++}
\item{min.plambda, max.plambda}{Input lambda values}
\item{min.num.eigenvectors, max.num.eigenvectors}{Range of eigenvectors used}
\item{evalues, evectors}{Eigenvalues and eigenvectors of the graph Laplacian}
\item{low.pass.ys}{Low-pass filtered versions of y for different numbers of eigenvectors}
}
\description{
Smooths a graph signal using a spectral smoothing technique based on the graph Laplacian.
It determines the optimal number of low-eigenvalue eigenvectors for representing
the graph function and returns the smoothed signal along with cross-validation errors.
}
