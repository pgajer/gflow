% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/harmonic_smoother.R
\name{perform.harmonic.smoothing}
\alias{perform.harmonic.smoothing}
\title{Perform Harmonic Smoothing on Graph Function Values}
\usage{
perform.harmonic.smoothing(
  adj.list,
  weight.list,
  values,
  region.vertices,
  max.iterations = 100,
  tolerance = 1e-06
)
}
\arguments{
\item{adj.list}{A list of integer vectors, where each vector contains indices
of vertices adjacent to the corresponding vertex. Indices must be 1-based.}

\item{weight.list}{A list of numeric vectors containing weights of edges
corresponding to adjacencies in \code{adj.list}.}

\item{values}{A numeric vector of function values defined at each vertex.}

\item{region.vertices}{An integer vector of vertex indices (1-based) defining
the region to be smoothed. Boundary vertices will have fixed values.}

\item{max.iterations}{Integer scalar, the maximum number of relaxation
iterations to perform. Default is 100.}

\item{tolerance}{Numeric scalar, the convergence threshold for value changes.
Default is 1e-6.}
}
\value{
A numeric vector of the same length as \code{values}, with smoothed
values within the specified region.
}
\description{
Applies harmonic smoothing to function values defined on vertices of a graph,
preserving values at the boundary of a specified region while smoothly
interpolating interior values. This function implements a discrete Laplace
equation solution using weighted averaging.
}
\details{
Harmonic smoothing preserves the overall shape of a function defined on a
graph while removing local fluctuations. It works by iteratively updating
interior vertex values as weighted averages of their neighbors until
convergence, while keeping boundary values fixed.

The algorithm:
\enumerate{
\item Identifies boundary vertices (vertices with neighbors outside the
region or degree 1 vertices)
\item Iteratively updates interior vertex values using edge-weighted averaging
\item Continues until convergence or maximum iterations reached
}

Edge weights are incorporated by using their inverse as weighting factors,
respecting the geometric structure of the graph.
}
\examples{
\dontrun{
# Create a simple grid graph
grid.graph <- create.graph.from.grid(10, 10)

# Create noisy function values
values <- sin(0.1 * seq_len(100)) + rnorm(100, 0, 0.1)

# Define a region for smoothing (center of the grid)
region <- 35:65

# Apply harmonic smoothing
smoothed.values <- perform.harmonic.smoothing(
  grid.graph$adj.list,
  grid.graph$weight.list,
  values,
  region,
  max.iterations = 200,
  tolerance = 1e-8
)

# Plot original vs smoothed values
plot(values, type = "l", col = "gray")
lines(smoothed.values, col = "red")
}

}
\seealso{
\code{\link{harmonic.smoother}} for smoothing with topology tracking,
\code{\link{get.region.boundary}} for boundary vertex identification
}
