% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/graph_utils.R, R/visualize_grid_function.R
\name{visualize.grid.function}
\alias{visualize.grid.function}
\title{Visualize a Function on a Grid Graph}
\usage{
visualize.grid.function(
  grid.size,
  z,
  centers = NULL,
  title = "Function on Grid Graph"
)

visualize.grid.function(
  grid.size,
  z,
  centers = NULL,
  title = "Function on Grid Graph"
)
}
\arguments{
\item{grid.size}{Integer; The size of the square grid (grid.size x grid.size)}

\item{z}{Numeric vector; Function values at each vertex of the grid graph,
ordered row-wise (length = grid.size^2)}

\item{centers}{Optional integer vector; Indices of special vertices to highlight
(e.g., local maxima or centers)}

\item{title}{Character string; Title for the plots (default: "Function on Grid Graph")}
}
\value{
Invisibly returns the function values

Invisibly returns the input z values
}
\description{
Creates visualizations of a function defined on a grid graph, including
2D heatmap, 3D surface plot (if rgl is available), and contour plot.

Creates multiple visualizations of a function defined on a grid graph including
heatmap with contours, 3D perspective plot, and optionally an interactive 3D plot.
}
\details{
The function creates a side-by-side visualization with:
\itemize{
\item Left panel: Heatmap with contour lines and optional center points
\item Right panel: 3D perspective plot of the surface
}

If the rgl package is available, an additional interactive 3D visualization
is created in a separate window.

The grid vertices are numbered from 1 to grid.size^2, going row by row.
The function values in z should be ordered to match this numbering.
}
\examples{
\dontrun{
# Create a grid graph
grid.size <- 20
grid <- create.grid.graph(grid.size, grid.size)

# Generate a mixture of Gaussians
centers <- c(1, grid.size * grid.size / 2 + grid.size / 2)
y <- generate.graph.gaussian.mixture(
  grid$adj.list,
  grid$weight.list,
  centers
)

# Visualize the function
visualize.grid.function(grid.size, y, centers)
}

\dontrun{
# Create a simple example with a Gaussian-like function on a 20x20 grid
grid.size <- 20
n_vertices <- grid.size^2

# Generate coordinates
x <- rep(1:grid.size, grid.size) / grid.size
y <- rep(1:grid.size, each=grid.size) / grid.size

# Create a function with two peaks
z <- exp(-10*((x-0.3)^2 + (y-0.3)^2)) + 0.5*exp(-8*((x-0.7)^2 + (y-0.6)^2))

# Find local maxima (simple approach)
centers <- which(z > 0.9)

# Visualize
visualize.grid.function(grid.size, z, centers)
}

}
