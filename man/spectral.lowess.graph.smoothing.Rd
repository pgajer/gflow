% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/spectral_lowess_graph_smoothing.R
\name{spectral.lowess.graph.smoothing}
\alias{spectral.lowess.graph.smoothing}
\title{Iterative Spectral LOWESS Graph Smoothing}
\usage{
spectral.lowess.graph.smoothing(
  adj.list,
  weight.list,
  X,
  max.iterations = 10,
  convergence.threshold = 1e-04,
  convergence.type = 1,
  k = 10,
  pruning.thld = 0.1,
  n.evectors = 8,
  n.bws = 10,
  log.grid = TRUE,
  min.bw.factor = 0.05,
  max.bw.factor = 0.5,
  dist.normalization.factor = 1.1,
  kernel.type = 7L,
  n.cleveland.iterations = 1,
  compute.errors = TRUE,
  compute.scales = TRUE,
  switch.to.residuals.after = NULL,
  verbose = FALSE
)
}
\arguments{
\item{adj.list}{A list of integer vectors representing the adjacency list of the graph.
Each element \code{adj.list[[i]]} contains the indices of vertices adjacent to vertex i.}

\item{weight.list}{A list of numeric vectors with edge weights corresponding to adjacencies.
Each element \code{weight.list[[i]][j]} is the weight of the edge from vertex i to
\code{adj.list[[i]][j]}.}

\item{X}{A numeric matrix where rows are samples and columns are features}

\item{max.iterations}{Maximum number of iterations to perform}

\item{convergence.threshold}{Threshold for convergence}

\item{convergence.type}{Type of convergence criteria:
1 = maximum absolute difference
2 = mean absolute difference
3 = maximum relative change}

\item{k}{Number of nearest neighbors for kNN graph construction}

\item{pruning.thld}{Threshold for pruning edges in graph construction}

\item{n.evectors}{Number of eigenvectors for spectral embedding}

\item{n.bws}{Number of candidate bandwidths for LOWESS}

\item{log.grid}{Logical, whether to use logarithmic spacing for bandwidth grid}

\item{min.bw.factor}{Factor for minimum bandwidth (multiplied by graph diameter)}

\item{max.bw.factor}{Factor for maximum bandwidth (multiplied by graph diameter)}

\item{dist.normalization.factor}{Factor for normalizing distances in kernel weight calculation}

\item{kernel.type}{Type of kernel function (1 = Gaussian, 2 = Exponential, etc.)}

\item{n.cleveland.iterations}{Number of robustness iterations for Cleveland's algorithm}

\item{compute.errors}{Logical, whether to compute prediction errors}

\item{compute.scales}{Logical, whether to compute bandwidth/scale information}

\item{switch.to.residuals.after}{Number of iterations to perform direct smoothing before
switching to residual smoothing (boosting mode). Default is max.iterations (never switch).
Set to 0 to use residual smoothing from the start.}

\item{verbose}{Logical, whether to print progress information}
}
\value{
A list containing:
\item{smoothed.graphs}{List of smoothed graphs at each iteration}
\item{smoothed.X}{List of smoothed data matrices at each iteration}
\item{convergence.metrics}{Numeric vector of convergence metrics at each iteration}
\item{iterations.performed}{Number of iterations actually performed}
\item{used.boosting}{Logical, whether boosting (residual smoothing) was used}
}
\description{
Apply iterative spectral LOWESS smoothing to a graph and its associated data matrix.
At each iteration, conditional expectations of features are estimated using
spectral embedding of local neighborhoods, and a new graph is constructed
from the smoothed data.
}
\examples{
\dontrun{
# Create a graph and data matrix
graph <- create.iknn.graph(X, k = 10, pruning.thld = 0.1)

# Apply spectral LOWESS graph smoothing - traditional approach
result1 <- spectral.lowess.graph.smoothing(
  adj.list = graph$adj_list,
  weight.list = graph$weight_list,
  X = X,
  max.iterations = 10,
  convergence.threshold = 1e-4,
  convergence.type = 1,  # MAX.ABSOLUTE.DIFF
  k = 10,
  pruning.thld = 0.1,
  n.evectors = 8,
  verbose = TRUE
)

# Apply spectral LOWESS graph smoothing with boosting
result2 <- spectral.lowess.graph.smoothing(
  adj.list = graph$adj_list,
  weight.list = graph$weight_list,
  X = X,
  max.iterations = 10,
  convergence.threshold = 1e-4,
  convergence.type = 1,  # MAX.ABSOLUTE.DIFF
  k = 10,
  pruning.thld = 0.1,
  n.evectors = 8,
  switch.to.residuals.after = 2,  # Switch to boosting after 2 iterations
  verbose = TRUE
)

# Access final smoothed data matrix
X.smoothed <- result2$smoothed.X[[length(result2$smoothed.X)]]

# Plot convergence metrics for both approaches
plot(result1$convergence.metrics, type = "b", col = "blue",
     xlab = "Iteration", ylab = "Convergence Metric")
lines(result2$convergence.metrics, type = "b", col = "red")
legend("topright", legend = c("Traditional", "Boosting"), 
       col = c("blue", "red"), lty = 1)
}

}
