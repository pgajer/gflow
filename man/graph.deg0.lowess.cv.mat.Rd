% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/graph_deg0_lowess_cv_mat.R
\name{graph.deg0.lowess.cv.mat}
\alias{graph.deg0.lowess.cv.mat}
\title{Matrix Version of Graph-Based LOWESS with Cross-Validation}
\usage{
graph.deg0.lowess.cv.mat(
  adj.list,
  weight.list,
  Y,
  min.bw.factor = 0.1,
  max.bw.factor = 0.5,
  n.bws = 10,
  log.grid = TRUE,
  kernel.type = 7L,
  dist.normalization.factor = 1.1,
  use.uniform.weights = FALSE,
  n.folds = 5,
  with.bw.predictions = FALSE,
  precision = 1e-06,
  verbose = FALSE
)
}
\arguments{
\item{adj.list}{A list of integer vectors. Each vector contains the indices of vertices
adjacent to the vertex at the corresponding list position.}

\item{weight.list}{A list of numeric vectors. Each vector contains the weights (distances)
of edges to the adjacent vertices specified in adj.list.}

\item{Y}{A list of numeric vectors. Each vector represents a response variable measured
at each vertex of the graph.}

\item{min.bw.factor}{Minimum bandwidth as a factor of graph diameter. The actual minimum
bandwidth will be min.bw.factor * graph.diameter.}

\item{max.bw.factor}{Maximum bandwidth as a factor of graph diameter. The actual maximum
bandwidth will be max.bw.factor * graph.diameter.}

\item{n.bws}{Number of bandwidths to test in the grid between min.bw and max.bw.}

\item{log.grid}{Logical, if TRUE, use logarithmic spacing for the bandwidth grid;
if FALSE, use linear spacing.}

\item{kernel.type}{Integer specifying the kernel function to use.
Possible values: 0=uniform, 1=triangular, 2=epanechnikov, 3=quartic,
4=triweight, 5=tricube, 6=gaussian, 7=cosine.}

\item{dist.normalization.factor}{Factor for normalizing distances in kernel weights.
A typical value is 1.1, which ensures all normalized distances fall within
the effective support of most kernel functions.}

\item{use.uniform.weights}{Whether to use uniform weights instead of kernel weights}

\item{n.folds}{Number of cross-validation folds.}

\item{with.bw.predictions}{Logical, if TRUE, compute and return predictions for all
bandwidths; if FALSE, only return predictions for the optimal bandwidths.}

\item{precision}{Numeric precision parameter for binary search and comparisons.}

\item{verbose}{Logical, if TRUE, print progress information during computation.}
}
\value{
A list containing:
\describe{
\item{predictions}{A list of numeric vectors, where \code{predictions[[j]][i]} is the smoothed
value for the jth response variable at the ith vertex}
\item{bw.predictions}{A nested list structure, where \code{bw.predictions[[j]][[bw.idx]]}
contains predictions for the jth response variable using the bandwidth at index bw.idx.
Only included if with.bw.predictions is TRUE.}
\item{bw.errors}{A list of numeric vectors, where \code{bw.errors[[j]][bw.idx]} is the
cross-validation error for the jth response variable using the bandwidth at index bw.idx}
\item{bws}{Numeric vector of bandwidths used in cross-validation}
\item{opt.bws}{Numeric vector of optimal bandwidths for each response variable}
\item{opt.bw.idxs}{Integer vector of indices of the optimal bandwidths in the bws vector
for each response variable (1-based indices)}
}
}
\description{
This function implements a matrix version of graph-based LOWESS (Locally Weighted
Smoothing) of degree 0 with spatially-stratified cross-validation for bandwidth selection.
It processes multiple response variables simultaneously, finding the optimal bandwidth
for each response variable. This is more efficient than calling the vector version
for each response variable separately.
}
\details{
The algorithm performs the following steps:
\enumerate{
\item Creates a maximal packing of vertices to serve as fold seed points
\item Assigns all vertices to the nearest seed point to form spatially coherent folds
\item For each candidate bandwidth, performs cross-validation across the folds for each response variable
\item Selects the bandwidth with the lowest cross-validation error for each response variable
\item Fits the final model with the optimal bandwidth for each response variable
}
}
\examples{
\dontrun{
# Create a simple graph with 3 response variables
adj.list <- list(c(2,3), c(1,3), c(1,2))
weight.list <- list(c(1,1), c(1,1), c(1,1))
Y <- list(c(1,2,3), c(4,5,6), c(7,8,9))

# Run the algorithm
result <- graph.deg0.lowess.cv.mat(
  adj.list, weight.list, Y,
  min.bw.factor = 0.1, max.bw.factor = 0.5,
  n.bws = 10, log.grid = TRUE, kernel.type = 2,
  dist.normalization.factor = 1.1, n.folds = 3,
  with.bw.predictions = FALSE, precision = 1e-6, verbose = TRUE
)

# Access results
result$predictions  # Smoothed values for each response variable
result$opt.bws      # Optimal bandwidths for each response variable
}

}
