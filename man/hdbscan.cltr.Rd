% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/clustering.R
\name{hdbscan.cltr}
\alias{hdbscan.cltr}
\title{Apply HDBSCAN Clustering}
\usage{
hdbscan.cltr(
  X,
  method = "dunn",
  min.pts = 5:50,
  min.prop = 0.1,
  max.prop = 0.5,
  n.test.cltr = 10,
  soft.K = 20,
  n.cores = 10,
  verbose = FALSE
)
}
\arguments{
\item{X}{A matrix of the data to be clustered. Each row represents an observation.}

\item{method}{A method (index) to be used for identifying the optimal number of clusters.
Default is 'dunn'. Other options: 'connectivity', 'cl0.size' and 'all'.}

\item{min.pts}{A vector of integers indicating the minimum cluster sizes to be evaluated.
Default is 5:50. If NULL, the function will generate values based on min.prop,
max.prop, and n.test.cltr.}

\item{min.prop}{The minimum proportion of nrow(X) to be used in test clusterings when min.pts is NULL.
Default is 0.1.}

\item{max.prop}{The maximum proportion of nrow(X) to be used in test clusterings when min.pts is NULL.
Default is 0.5.}

\item{n.test.cltr}{The number of test clusters when min.pts is NULL. Default is 10.}

\item{soft.K}{The number of nearest neighbors to consider when softening the cluster boundaries.
Default is 20.}

\item{n.cores}{The number of cores to use for parallel processing. Default is 10.}

\item{verbose}{A logical value indicating whether progress should be displayed. Default is FALSE.}
}
\value{
A list containing the details of the clustering for three different metrics:
\item{cl0.size}{Vector of sizes of cluster labeled as '0' (noise) for each min.pts value}
\item{n.cltrs}{Vector of number of clusters (excluding noise) for each min.pts value}
\item{cl0.cltr}{Cluster assignments using the min.pts that minimizes cl0.size}
\item{cl0.cltr.ext}{Extended cluster assignments after softening (cl0.size method)}
\item{cl0.opt.k}{Optimal min.pts value that minimizes cl0.size}
\item{cl0.cl0.size}{Size of cluster '0' for the cl0.size-optimal clustering}
\item{cl0.n.cltrs}{Number of clusters for the cl0.size-optimal clustering}
\item{cl0.cltr.freq}{Frequency table of clusters for cl0.size method}
\item{cl0.cltr.ext.freq}{Frequency table of extended clusters for cl0.size method}
\item{dunn.idx}{Vector of Dunn indices for each min.pts value}
\item{dunn.cltr}{Cluster assignments using the min.pts that maximizes Dunn index}
\item{dunn.cltr.ext}{Extended cluster assignments after softening (Dunn method)}
\item{dunn.opt.k}{Optimal min.pts value that maximizes Dunn index}
\item{dunn.cl0.size}{Size of cluster '0' for the Dunn-optimal clustering}
\item{dunn.n.cltrs}{Number of clusters for the Dunn-optimal clustering}
\item{dunn.cltr.freq}{Frequency table of clusters for Dunn method}
\item{dunn.cltr.ext.freq}{Frequency table of extended clusters for Dunn method}
\item{connectivity.idx}{Vector of connectivity indices for each min.pts value}
\item{connectivity.cltr}{Cluster assignments using the min.pts that minimizes connectivity}
\item{connectivity.cltr.ext}{Extended cluster assignments after softening (connectivity method)}
\item{connectivity.opt.k}{Optimal min.pts value that minimizes connectivity index}
\item{connectivity.cl0.size}{Size of cluster '0' for the connectivity-optimal clustering}
\item{connectivity.n.cltrs}{Number of clusters for the connectivity-optimal clustering}
\item{connectivity.cltr.freq}{Frequency table of clusters for connectivity method}
\item{connectivity.cltr.ext.freq}{Frequency table of extended clusters for connectivity method}
}
\description{
This function applies HDBSCAN clustering to a given dataset (expressed as a
matrix), and evaluates clustering results with different minimum cluster
sizes using dunn and connectivity indices.
}
\note{
This function requires the packages 'foreach', and 'doParallel'.

The Dunn and connectivity metrics are computed via the suggested package
'clValid'. If 'clValid' is not installed, use \code{method = "cl0.size"} (or avoid
\code{method = "dunn"}, \code{"connectivity"}, or \code{"all"}).

The HDBSCAN clustering is performed via the suggested package
'dbscan'. This function will error if 'dbscan' is not installed.
}
\examples{
\dontrun{
# Generate sample data
set.seed(123)
X <- rbind(
  matrix(rnorm(100, mean = 0), ncol = 2),
  matrix(rnorm(100, mean = 5), ncol = 2)
)

# Apply HDBSCAN clustering
result <- hdbscan.cltr(X, min.pts = 5:50, soft.K = 20, verbose = TRUE)

# View optimal clustering for Dunn index
table(result$dunn.cltr)
}

}
