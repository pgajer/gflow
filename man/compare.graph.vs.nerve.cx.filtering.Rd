% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/nerve_cx_spectral_filter.R
\name{compare.graph.vs.nerve.cx.filtering}
\alias{compare.graph.vs.nerve.cx.filtering}
\title{Compare Graph vs. Nerve Complex Spectral Filtering}
\usage{
compare.graph.vs.nerve.cx.filtering(
  complex,
  y,
  y.true = NULL,
  laplacian.type = "STANDARD",
  filter.type = "HEAT",
  laplacian.power = 1,
  dim.weights.complex = NULL,
  graph.only.weights = NULL,
  kernel.params = list(tau.factor = 0.01, radius.factor = 3),
  n.evectors = 100,
  n.candidates = 100,
  verbose = FALSE
)
}
\arguments{
\item{complex}{A nerve complex object created by \code{\link{create.nerve.complex}}.}

\item{y}{Numeric vector of observed function values at vertices.}

\item{y.true}{Optional numeric vector of true function values for MSE calculation.
If provided, must have the same length as \code{y}.}

\item{laplacian.type}{Character string specifying the Laplacian type.
See \code{\link{nerve.cx.spectral.filter}} for options.}

\item{filter.type}{Character string specifying the filter type.
See \code{\link{nerve.cx.spectral.filter}} for options.}

\item{laplacian.power}{Positive integer for the Laplacian power.}

\item{dim.weights.complex}{Numeric vector of dimension weights for complex filtering.
If \code{NULL}, uses exponentially decreasing weights.}

\item{graph.only.weights}{Numeric vector of dimension weights for graph filtering.
If \code{NULL}, uses weight 1 for dimension 0 and 0 for others.}

\item{kernel.params}{List of kernel parameters. See \code{\link{nerve.cx.spectral.filter}}.}

\item{n.evectors}{Number of eigenvectors to compute.}

\item{n.candidates}{Number of candidate parameter values to test.}

\item{verbose}{Logical indicating whether to print progress information.}
}
\value{
A list of class \code{nerve_cx_comparison} containing:
\item{graph_predictions}{Smoothed values using graph-only filtering}
\item{complex_predictions}{Smoothed values using full complex filtering}
\item{graph_gcv}{GCV score for graph-only filtering}
\item{complex_gcv}{GCV score for complex filtering}
\item{gcv_improvement_pct}{Percentage improvement in GCV score}
\item{mse_graph}{MSE for graph filtering (if \code{y.true} provided)}
\item{mse_complex}{MSE for complex filtering (if \code{y.true} provided)}
\item{mse_improvement_pct}{Percentage improvement in MSE (if \code{y.true} provided)}
\item{graph_result}{Full result object from graph filtering}
\item{complex_result}{Full result object from complex filtering}
}
\description{
Compares the performance of graph-based spectral filtering (using only the
1-skeleton) with nerve complex spectral filtering (incorporating higher-order
simplicial information). This function quantifies the improvement gained by
utilizing the full simplicial structure.
}
\details{
This comparison function runs two separate filtering operations:
\enumerate{
\item Graph-only filtering: Uses only the 1-skeleton (edges) of the complex
\item Full complex filtering: Incorporates all simplex dimensions
}

The improvement metrics help quantify the benefit of using higher-order
simplicial information. Positive improvement percentages indicate that
the complex filtering performs better than graph-only filtering.
}
\examples{
\dontrun{
# Generate test data
set.seed(123)
coords <- matrix(runif(200), ncol = 2)
f_true <- function(x) sin(2*pi*x[1]) * cos(2*pi*x[2])
y_true <- apply(coords, 1, f_true)
y_noisy <- y_true + rnorm(length(y_true), 0, 0.2)

# Create nerve complex
complex <- create.nerve.complex(coords, k = 8, max.dim = 2)
complex <- set.complex.function.values(complex, y_noisy)

# Compare filtering approaches
comparison <- compare.graph.vs.nerve.cx.filtering(
  complex, y_noisy, y_true,
  dim.weights.complex = c(1.0, 0.5, 0.25),
  verbose = TRUE
)

# Print improvement
cat("GCV improvement:", comparison$gcv_improvement_pct, "\%\n")
cat("MSE improvement:", comparison$mse_improvement_pct, "\%\n")
}

}
