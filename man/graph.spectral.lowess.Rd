% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/graph_spectral_lowess.R
\name{graph.spectral.lowess}
\alias{graph.spectral.lowess}
\title{Local Regression on Graphs Using Spectral Embedding}
\usage{
graph.spectral.lowess(
  adj.list,
  weight.list,
  y,
  n.evectors = 5,
  n.bws = 20,
  log.grid = TRUE,
  min.bw.factor = 0.05,
  max.bw.factor = 0.5,
  dist.normalization.factor = 1.1,
  kernel.type = 7L,
  precision = 0.001,
  n.cleveland.iterations = 1L,
  verbose = FALSE
)
}
\arguments{
\item{adj.list}{A list of integer vectors representing the adjacency list of the graph.
Each element \code{adj.list[[i]]} contains the indices of vertices adjacent to vertex i.}

\item{weight.list}{A list of numeric vectors with edge weights corresponding to adjacencies.
Each element \code{weight.list[[i]][j]} is the weight of the edge from vertex i to
\code{adj.list[[i]][j]}.}

\item{y}{A numeric vector of response values for each vertex in the graph.}

\item{n.evectors}{Integer specifying the number of eigenvectors to use in the spectral
embedding (default: 5).}

\item{n.bws}{Integer specifying the number of candidate bandwidths to evaluate (default: 10).}

\item{log.grid}{Logical indicating whether to use logarithmic spacing for bandwidth
grid (default: TRUE).}

\item{min.bw.factor}{Numeric value specifying the minimum bandwidth as a fraction of
graph diameter (default: 0.05).}

\item{max.bw.factor}{Numeric value specifying the maximum bandwidth as a fraction of
graph diameter (default: 0.25).}

\item{dist.normalization.factor}{Numeric factor for normalizing distances when calculating
kernel weights (default: 1.0).}

\item{kernel.type}{Integer specifying the kernel function for weighting vertices:
\itemize{
\item 1: Epanechnikov
\item 2: Triangular
\item 4: Laplace
\item 5: Normal
\item 6: Biweight
\item 7: Tricube (default)
}
Default is 7.}

\item{precision}{Numeric value specifying the precision tolerance for binary search and
optimization algorithms (default: 0.001).}

\item{n.cleveland.iterations}{Number of Cleveland's robustness iterations (default: 0)}

\item{verbose}{Logical indicating whether to display progress information (default: FALSE).}
}
\value{
A list containing:
\itemize{
\item \code{predictions}: Numeric vector of smoothed values for each vertex
\item \code{errors}: Numeric vector of leave-one-out cross-validation errors
\item \code{scale}: Numeric vector of optimal bandwidths (local scales) for each vertex
\item \code{graph.diameter}: Numeric scalar with computed graph diameter
}
}
\description{
Performs local regression on graph data using spectral embeddings
with adaptive bandwidth selection.
}
\details{
This function implements a graph-based extension of LOWESS (Locally
Weighted Scatterplot Smoothing) that uses spectral embedding to transform
graph distances into a Euclidean space suitable for local linear regression.
For each vertex, the function:
\enumerate{
\item Finds all vertices within the maximum bandwidth radius
\item Creates a local spectral embedding using graph Laplacian eigenvectors
\item Fits weighted linear models at multiple candidate bandwidths
\item Selects the optimal bandwidth based on leave-one-out cross-validation error
\item Computes smoothed predictions using the optimal model
}
}
\examples{
\dontrun{
# Create a simple graph with 100 vertices
n <- 100
set.seed(123)

# Create a ring graph
adj.list <- vector("list", n)
weight.list <- vector("list", n)

for (i in 1:n) {
  neighbors <- c(i-1, i+1)
  # Handle wrap-around for ring structure
  neighbors[neighbors == 0] <- n
  neighbors[neighbors == n+1] <- 1

  adj.list[[i]] <- neighbors
  weight.list[[i]] <- rep(1, length(neighbors))
}

# Generate response values with spatial pattern
y <- sin(2*pi*(1:n)/n) + rnorm(n, 0, 0.2)

# Apply spectral LOWESS
result <- graph.spectral.lowess(
  adj.list = adj.list,
  weight.list = weight.list,
  y = y,
  n.evectors = 5,
  verbose = TRUE
)

# Plot results
plot(y, type="l", col="gray", main="Graph Spectral LOWESS")
lines(result$predictions, col="red", lwd=2)
}

}
