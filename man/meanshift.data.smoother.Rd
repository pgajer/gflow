% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mean_shift_smoother.R
\name{meanshift.data.smoother}
\alias{meanshift.data.smoother}
\title{Mean Shift Data Smoother}
\usage{
meanshift.data.smoother(
  X,
  k,
  density.k = 1,
  n.steps = 10,
  step.size = 0.1,
  ikernel = 1,
  dist.normalization.factor = 1.01,
  method = "precomputed",
  momentum = 0.9,
  increase.factor = 1.2,
  decrease.factor = 0.5,
  average.direction.only = NULL
)
}
\arguments{
\item{X}{A numeric matrix or data frame where rows represent points and columns
represent features. Will be coerced to a matrix if necessary.}

\item{k}{An integer specifying the number of nearest neighbors to consider for
gradient estimation. Must be positive and less than the number of points.}

\item{density.k}{An integer specifying the number of nearest neighbors to consider
for density estimation. Must be positive and less than the number of points.
Default is 1.}

\item{n.steps}{An integer specifying the number of smoothing steps to perform.
Must be positive. Default is 10.}

\item{step.size}{A numeric value specifying the step size for updating point positions.
Should be between 0 and 1. Default is 0.1.}

\item{ikernel}{An integer specifying the kernel function to use:
\itemize{
\item 1: Epanechnikov kernel
\item 2: Triangular kernel
\item 3: Truncated Exponential kernel
\item 4: Normal (Gaussian) kernel
}
Default is 1.}

\item{dist.normalization.factor}{A numeric value specifying the scaling factor for
distance normalization. Should be greater than 1. Default is 1.01.}

\item{method}{A character string or integer specifying the smoothing method:
\describe{
\item{"basic" (0)}{Basic mean shift algorithm}
\item{"precomputed" (1)}{Mean shift with precomputed nearest neighbors (default)}
\item{"grad_field" (2)}{Mean shift with gradient field averaging}
\item{"grad_field_dir" (3)}{Mean shift with gradient field averaging (direction only)}
\item{"adaptive" (4)}{Adaptive mean shift}
\item{"adaptive_dir" (5)}{Adaptive mean shift (direction only)}
\item{"knn_adaptive" (6)}{KNN adaptive mean shift}
\item{"knn_adaptive_grad" (7)}{KNN adaptive with gradient field averaging}
\item{"knn_adaptive_grad_dir" (8)}{KNN adaptive with gradient field averaging (direction only)}
\item{"adaptive_momentum" (9)}{Adaptive with gradient field averaging and momentum}
\item{"adaptive_momentum_dir" (10)}{Adaptive with gradient field averaging and momentum (direction only)}
}
Default is "precomputed".}

\item{momentum}{A numeric value specifying the momentum factor for methods
"adaptive_momentum" and "adaptive_momentum_dir". Should be between 0 and 1.
Default is 0.9. Ignored for other methods.}

\item{increase.factor}{A numeric value specifying the factor by which to increase
the step size in adaptive methods. Should be greater than 1. Default is 1.2.
Only used for adaptive methods (4-10).}

\item{decrease.factor}{A numeric value specifying the factor by which to decrease
the step size in adaptive methods. Should be between 0 and 1. Default is 0.5.
Only used for adaptive methods (4-10).}

\item{average.direction.only}{A logical value indicating whether to average only the
directions of gradients (TRUE) or full gradient vectors (FALSE). If NULL (default),
this is automatically determined based on the method:
\itemize{
\item Methods ending in "_dir" use TRUE
\item Other methods use FALSE
}}
}
\value{
A list of class "MSD" containing:
\describe{
\item{X}{The original input dataset}
\item{X.traj}{A list of matrices, each representing the smoothed dataset at each step}
\item{median.kdistances}{A numeric vector of median k-distances for each step}
\item{opt.step}{The step number with minimum median k-distance}
\item{dX}{The smoothed dataset at the optimal step}
\item{method}{The method used (as a string)}
\item{params}{A list of all parameters used}
}
}
\description{
Performs mean shift smoothing on a dataset using various algorithms. Mean shift is a
non-parametric feature-space analysis technique for locating the maxima of a density
function. This implementation offers multiple variants including adaptive step sizes,
gradient field averaging, and momentum-based updates.
}
\details{
The mean shift algorithm iteratively moves each data point towards the mode of the
density estimated in its neighborhood. Different variants offer various improvements:

\itemize{
\item \strong{Basic/Precomputed}: Standard mean shift with optional nearest neighbor precomputation
\item \strong{Gradient Field}: Averages gradients across the dataset for smoother updates
\item \strong{Adaptive}: Dynamically adjusts step sizes based on convergence behavior
\item \strong{KNN Adaptive}: Uses k-nearest neighbors for adaptive bandwidth selection
\item \strong{Momentum}: Incorporates previous update directions for faster convergence
}

The "direction only" variants normalize gradient vectors before averaging, which can
be more robust to outliers but may converge more slowly.
}
\examples{
\dontrun{
# Generate sample data
set.seed(123)
X <- matrix(rnorm(200), ncol = 2)

# Basic mean shift smoothing
result1 <- meanshift.data.smoother(X, k = 5)

# Adaptive mean shift with gradient field averaging
result2 <- meanshift.data.smoother(X, k = 5, method = "adaptive")

# With momentum
result3 <- meanshift.data.smoother(X, k = 5, method = "adaptive_momentum",
                                  momentum = 0.95)

# Plot the trajectory
plot(result1$median.kdistances, type = 'l',
     xlab = 'Step', ylab = 'Median k-distance')
abline(v = result1$opt.step, col = 'red', lty = 2)

# Compare original and smoothed data
par(mfrow = c(1, 2))
plot(X, main = "Original", pch = 19, cex = 0.5)
plot(result1$dX, main = "Smoothed", pch = 19, cex = 0.5)
}

}
\references{
Comaniciu, D., & Meer, P. (2002). Mean shift: A robust approach toward feature
space analysis. IEEE Transactions on Pattern Analysis and Machine Intelligence,
24(5), 603-619.
}
\seealso{
\code{\link{plot.MSD}} for plotting the results
}
