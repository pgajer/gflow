% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/graph_diffusion_smoother.R
\name{ext.graph.diffusion.smoother}
\alias{ext.graph.diffusion.smoother}
\title{Extended Graph Diffusion Smoother}
\usage{
ext.graph.diffusion.smoother(
  graph,
  edge.lengths,
  y,
  weights = NULL,
  n.time.steps = 100,
  step.factor = 0.1,
  normalize = 0,
  preserve.local.maxima = FALSE,
  local.maximum.weight.factor = 1,
  preserve.local.extrema = FALSE,
  imputation.method = 0,
  max.iterations = 10,
  convergence.threshold = 1e-06,
  apply.binary.threshold = TRUE,
  binary.threshold = 0.5,
  kernel = 1,
  dist.normalization.factor = 1.01,
  n.CVs = 0,
  n.CV.folds = 10,
  epsilon = 1e-10,
  seed = 0,
  verbose = TRUE
)
}
\arguments{
\item{graph}{A list of integer vectors where each element contains the indices
of neighbors for the corresponding vertex (1-based indexing).}

\item{edge.lengths}{A list of numeric vectors where each element contains the
edge lengths corresponding to the neighbors in \code{graph}.}

\item{y}{A numeric vector of signal values at each vertex.}

\item{weights}{An optional numeric vector of weights for each vertex. If
\code{NULL}, all vertices are weighted equally. Default is \code{NULL}.}

\item{n.time.steps}{An integer specifying the number of diffusion steps.
Default is 100.}

\item{step.factor}{A numeric value between 0 and 1 controlling the magnitude
of each diffusion step. Smaller values lead to more gradual smoothing.
Default is 0.1.}

\item{normalize}{An integer (0, 1, or 2) specifying the normalization method:
\itemize{
\item 0: No normalization
\item 1: Range adjustment to \eqn{[0, 1]}
\item 2: Mean adjustment to preserve the mean of the signal
}
Default is 0.}

\item{preserve.local.maxima}{A logical value. If \code{TRUE}, local maxima are
preserved during diffusion by adjusting weights based on neighborhood values.
Default is \code{FALSE}.}

\item{local.maximum.weight.factor}{A numeric value between 0 and 1 controlling
the degree of preservation for local maxima. Default is 1.0.}

\item{preserve.local.extrema}{A logical value. If \code{TRUE}, both local
maxima and minima are preserved. Cannot be \code{TRUE} simultaneously with
\code{preserve.local.maxima}. Default is \code{FALSE}.}

\item{imputation.method}{An integer (0-4) specifying the imputation method:
\itemize{
\item 0: LOCAL_MEAN_THRESHOLD
\item 1: NEIGHBORHOOD_MATCHING
\item 2: ITERATIVE_NEIGHBORHOOD_MATCHING
\item 3: SUPPLIED_THRESHOLD
\item 4: GLOBAL_MEAN_THRESHOLD
}
Default is 0.}

\item{max.iterations}{A positive integer for the maximum number of iterations
in iterative imputation methods. Default is 10.}

\item{convergence.threshold}{A positive numeric value for convergence criteria.
Default is 1e-6.}

\item{apply.binary.threshold}{A logical value indicating whether to apply
binary thresholding to the output. Default is \code{TRUE}.}

\item{binary.threshold}{A numeric value between 0 and 1 for binary thresholding.
Default is 0.5.}

\item{kernel}{An integer (0-4) specifying the kernel type for distance weighting:
\itemize{
\item 0: Uniform kernel
\item 1: Gaussian kernel
\item 2: Laplacian kernel
\item 3: Exponential kernel
\item 4: Cauchy kernel
}
Default is 1.}

\item{dist.normalization.factor}{A numeric value >= 1 for distance normalization.
Default is 1.01.}

\item{n.CVs}{A non-negative integer for the number of cross-validation runs.
If 0, no cross-validation is performed. Default is 0.}

\item{n.CV.folds}{An integer > 1 for the number of folds in cross-validation.
Default is 10.}

\item{epsilon}{A positive numeric value for numerical stability. Default is 1e-10.}

\item{seed}{An integer for the random number generator seed. Default is 0.}

\item{verbose}{A logical value. If \code{TRUE}, prints progress information.
Default is \code{TRUE}.}
}
\value{
A list of class \code{"ext.gds"} containing:
\item{y.traj}{A matrix where each column represents the signal at a time step.}
\item{y.optimal}{The optimally smoothed signal (based on CV if performed).}
\item{cv.errors}{A matrix of cross-validation errors (rows: time steps,
columns: CV runs).}
\item{mean.cv.errors}{Mean CV errors across runs for each time step.}
\item{Rmean.cv.errors}{R-computed mean CV errors (for verification).}
\item{Rmedian.cv.errors}{Median CV errors across runs.}
\item{optimal.time.step}{The time step with minimum CV error.}
\item{min.cv.error}{The minimum mean CV error.}
}
\description{
Performs graph diffusion smoothing on a graph signal using an iterative diffusion
process. This method is useful for denoising graph signals, interpolating missing
values, and enhancing patterns in network data while preserving the underlying
graph structure.
}
\details{
The graph diffusion process iteratively updates vertex values based on their
neighbors' values, weighted by edge lengths and kernel functions. The algorithm
can preserve local extrema to maintain important features while smoothing noise.

Cross-validation uses a masking approach where test vertices don't influence
the diffusion but their values are predicted to evaluate performance.
}
\examples{
\dontrun{
# Create a simple chain graph
n <- 20
graph <- vector("list", n)
edge.lengths <- vector("list", n)
for(i in 1:(n-1)) {
  graph[[i]] <- c(graph[[i]], i+1)
  graph[[i+1]] <- c(graph[[i+1]], i)
  edge.lengths[[i]] <- c(edge.lengths[[i]], 1)
  edge.lengths[[i+1]] <- c(edge.lengths[[i+1]], 1)
}

# Create noisy signal
true.signal <- sin(seq(0, 2*pi, length.out = n))
y <- true.signal + rnorm(n, 0, 0.2)

# Apply diffusion smoothing
result <- ext.graph.diffusion.smoother(
  graph = graph,
  edge.lengths = edge.lengths,
  y = y,
  n.time.steps = 50,
  step.factor = 0.1,
  n.CVs = 5,
  verbose = TRUE
)

# Plot results
plot(y, type = "b", col = "red", main = "Graph Diffusion Smoothing")
lines(result$y.optimal, type = "b", col = "blue")
legend("topright", c("Original", "Smoothed"), col = c("red", "blue"), lty = 1)
}

}
\references{
Coifman, R. R., & Lafon, S. (2006). Diffusion maps. Applied and computational
harmonic analysis, 21(1), 5-30.
}
\seealso{
\code{\link{graph.diffusion.matrix.smoother}},
\code{\link{instrumented.gds}}
}
