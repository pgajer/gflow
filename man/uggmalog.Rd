% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/uggmalog.R
\name{uggmalog}
\alias{uggmalog}
\title{Uniform Grid Graph Model-Averaged LOGistic regression (UGGMALOG)}
\usage{
uggmalog(
  adj.list,
  weight.list,
  y,
  best.models.coverage.factor = 0.9,
  min.bw.factor = 0.05,
  max.bw.factor = 0.5,
  n.bws = 50L,
  grid.size = 100L,
  start.vertex = 1L,
  snap.tolerance = 0.1,
  dist.normalization.factor = 1.01,
  min.path.size = 5L,
  diff.threshold = 5L,
  kernel.type = 7L,
  fit.quadratic = FALSE,
  max.iterations = 100L,
  ridge.lambda = 0,
  tolerance = 1e-08,
  verbose = FALSE
)
}
\arguments{
\item{adj.list}{A list of integer vectors representing the adjacency list
of the graph. Each element \code{i} contains the indices of vertices
adjacent to vertex \code{i}. Uses 1-based indexing.}

\item{weight.list}{A list of numeric vectors representing the weights of
the edges. Must have the same structure as \code{adj.list}.}

\item{y}{A numeric vector of observations at each vertex. Length must
match the number of vertices in the graph.}

\item{best.models.coverage.factor}{Numeric scalar between 0.5 and 1.0.
Controls the proportion of best models used in model averaging.
Default: 0.9}

\item{min.bw.factor}{Numeric scalar. Minimum bandwidth factor relative
to graph diameter. Must be positive. Default: 0.05}

\item{max.bw.factor}{Numeric scalar. Maximum bandwidth factor relative
to graph diameter. Must be greater than \code{min.bw.factor}.
Default: 0.5}

\item{n.bws}{Positive integer. Number of bandwidths to test between
\code{min.bw.factor} and \code{max.bw.factor}. Default: 50}

\item{grid.size}{Positive integer. Size of the evaluation grid for
predictions. Default: 100}

\item{start.vertex}{Positive integer. Index of the starting vertex
(1-based). Must be between 1 and the number of vertices. Default: 1}

\item{snap.tolerance}{Positive numeric scalar. Tolerance for snapping
distances to grid points. Default: 0.1}

\item{dist.normalization.factor}{Numeric scalar greater than 1. Factor
for normalizing distances. Default: 1.01}

\item{min.path.size}{Positive integer. Minimum path size for distance
calculations. Default: 5}

\item{diff.threshold}{Non-negative integer. Threshold for difference in
path lengths. Default: 5}

\item{kernel.type}{Integer between 0 and 7. Type of kernel to use:
\itemize{
\item 0: Uniform kernel
\item 1: Triangular kernel
\item 2: Epanechnikov kernel
\item 3: Quartic (biweight) kernel
\item 4: Triweight kernel
\item 5: Tricube kernel
\item 6: Gaussian kernel
\item 7: Cosine kernel (default)
}}

\item{fit.quadratic}{Logical scalar. Whether to fit quadratic terms in
the local models. Default: FALSE}

\item{max.iterations}{Positive integer. Maximum number of iterations for
optimization. Default: 100}

\item{ridge.lambda}{Non-negative numeric scalar. Ridge regression
parameter. Default: 0.0}

\item{tolerance}{Positive numeric scalar. Convergence tolerance for
optimization. Default: 1e-8}

\item{verbose}{Logical scalar. Whether to print progress messages.
Default: FALSE}
}
\value{
A list with class \code{"uggmalog"} containing:
\item{candidate_bws}{Numeric vector of candidate bandwidths tested}
\item{bw_predictions}{Numeric matrix of predictions for each bandwidth
(rows: vertices, columns: bandwidths)}
\item{mean_errors}{Numeric vector of mean cross-validation errors for
each bandwidth}
\item{opt_bw_idx}{Integer scalar. Index of the optimal bandwidth
(1-based)}
\item{predictions}{Numeric vector of predictions using the optimal
bandwidth}
\item{graph_diameter}{Numeric scalar. Computed diameter of the graph}
}
\description{
Implements a sophisticated algorithm for analyzing weighted graphs using
local path logistic models with model averaging. The algorithm performs
the following main steps:
\enumerate{
\item Computes graph diameter and determines bandwidth range
\item Creates a uniform grid representation of the input graph
\item For each candidate bandwidth:
\itemize{
\item Processes paths through grid vertices
\item Fits local logistic models to path data
\item Computes weighted predictions and errors
}
\item Determines optimal bandwidth based on cross-validation errors
}

The algorithm uses weighted logistic regression on paths through the graph
to create local models, which are then combined using weighted averaging.
Model evaluation is performed using leave-one-out cross-validation with
Brier score errors.
}
\details{
The algorithm is particularly useful for prediction on graphs where local
structure is important. The model averaging approach helps to reduce
overfitting and provides more stable predictions.

The bandwidth selection is performed automatically using cross-validation,
choosing the bandwidth that minimizes the mean Brier score error.
}
\note{
This function requires compilation of C++ code. The adjacency list uses
R's standard 1-based indexing, which is internally converted to 0-based
indexing for the C++ implementation.
}
\examples{
\dontrun{
# Create a simple chain graph
n <- 10
adj <- vector("list", n)
weights <- vector("list", n)

# Build chain: 1 -- 2 -- 3 -- ... -- n
for (i in 1:n) {
  adj[[i]] <- integer(0)
  weights[[i]] <- numeric(0)

  if (i > 1) {
    adj[[i]] <- c(adj[[i]], i - 1)
    weights[[i]] <- c(weights[[i]], 1.0)
  }

  if (i < n) {
    adj[[i]] <- c(adj[[i]], i + 1)
    weights[[i]] <- c(weights[[i]], 1.0)
  }
}

# Generate some response data
set.seed(123)
y <- sin(seq(0, pi, length.out = n)) + rnorm(n, sd = 0.1)

# Run UGGMALOG
result <- uggmalog(adj, weights, y, verbose = TRUE)

# Print optimal bandwidth index
cat("Optimal bandwidth index:", result$opt_bw_idx, "\n")

# More complex example: Grid graph
# Create a 5x5 grid graph
grid_size <- 5
n <- grid_size^2
adj <- vector("list", n)
weights <- vector("list", n)

# Function to convert 2D coordinates to 1D index
coord_to_idx <- function(i, j) (i - 1) * grid_size + j

# Build grid adjacency
for (i in 1:grid_size) {
  for (j in 1:grid_size) {
    idx <- coord_to_idx(i, j)
    adj[[idx]] <- integer(0)
    weights[[idx]] <- numeric(0)

    # Add horizontal edges
    if (j > 1) {
      adj[[idx]] <- c(adj[[idx]], coord_to_idx(i, j - 1))
      weights[[idx]] <- c(weights[[idx]], 1.0)
    }
    if (j < grid_size) {
      adj[[idx]] <- c(adj[[idx]], coord_to_idx(i, j + 1))
      weights[[idx]] <- c(weights[[idx]], 1.0)
    }

    # Add vertical edges
    if (i > 1) {
      adj[[idx]] <- c(adj[[idx]], coord_to_idx(i - 1, j))
      weights[[idx]] <- c(weights[[idx]], 1.0)
    }
    if (i < grid_size) {
      adj[[idx]] <- c(adj[[idx]], coord_to_idx(i + 1, j))
      weights[[idx]] <- c(weights[[idx]], 1.0)
    }
  }
}

# Generate response based on distance from center
center <- (grid_size + 1) / 2
y <- numeric(n)
for (i in 1:grid_size) {
  for (j in 1:grid_size) {
    dist_from_center <- sqrt((i - center)^2 + (j - center)^2)
    y[coord_to_idx(i, j)] <- exp(-dist_from_center / 2) + rnorm(1, sd = 0.05)
  }
}

# Run UGGMALOG with custom parameters
result <- uggmalog(
  adj.list = adj,
  weight.list = weights,
  y = y,
  n.bws = 30,
  kernel.type = 5,  # Tricube kernel
  fit.quadratic = TRUE,
  verbose = TRUE
)
}

}
