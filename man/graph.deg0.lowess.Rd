% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/graph_deg0_lowess.R
\name{graph.deg0.lowess}
\alias{graph.deg0.lowess}
\title{Degree 0 LOWESS (Locally Weighted Average) on Graphs}
\usage{
graph.deg0.lowess(
  adj.list,
  weight.list,
  y,
  bandwidth,
  kernel.type = 7L,
  dist.normalization.factor = 1.1,
  verbose = FALSE
)
}
\arguments{
\item{adj.list}{A list of integer vectors representing the adjacency list of the graph.
Each element \code{adj.list[[i]]} contains the indices of vertices adjacent to vertex i.}

\item{weight.list}{A list of numeric vectors with edge weights corresponding to adjacencies.
Each element \code{weight.list[[i]][j]} is the weight of the edge from vertex i to
\code{adj.list[[i]][j]}.}

\item{y}{A numeric vector of response values for each vertex in the graph.}

\item{bandwidth}{A numeric value specifying the fixed bandwidth (radius) to use for
all local neighborhoods.}

\item{kernel.type}{Integer specifying the kernel function for weighting vertices:
\itemize{
\item 1: Epanechnikov
\item 2: Triangular
\item 4: Laplace
\item 5: Normal
\item 6: Biweight
\item 7: Tricube (default)
}}

\item{dist.normalization.factor}{Numeric factor for normalizing distances when calculating
kernel weights (default: 1.0).}

\item{verbose}{Logical indicating whether to display progress information (default: FALSE).}
}
\value{
A numeric vector of smoothed predictions for each vertex.
}
\description{
Performs local constant fitting (degree 0 LOWESS) on graph data
using a fixed bandwidth.
}
\details{
This function implements a simplified version of LOWESS for graph data
where only degree 0 local models (weighted averages) are fit. For each vertex,
the function:
\enumerate{
\item Finds all vertices within the specified bandwidth radius
\item Computes a weighted average of response values using kernel weights
\item Returns the smoothed prediction
}
}
\examples{
\dontrun{
# Create a simple ring graph
n <- 100
set.seed(123)

# Create a ring graph
adj.list <- vector("list", n)
weight.list <- vector("list", n)

for (i in 1:n) {
  neighbors <- c(i-1, i+1)
  # Handle wrap-around for ring structure
  neighbors[neighbors == 0] <- n
  neighbors[neighbors == n+1] <- 1

  adj.list[[i]] <- neighbors
  weight.list[[i]] <- rep(1, length(neighbors))
}

# Generate response values with spatial pattern plus noise
y <- sin(2*pi*(1:n)/n) + rnorm(n, 0, 0.2)

# Apply degree 0 LOWESS with different bandwidths
bw1 <- 5
bw2 <- 10
bw3 <- 20

result1 <- graph.deg0.lowess(adj.list, weight.list, y, bw1)
result2 <- graph.deg0.lowess(adj.list, weight.list, y, bw2)
result3 <- graph.deg0.lowess(adj.list, weight.list, y, bw3)

# Plot results
plot(y, type="p", col="gray", main="Graph Degree 0 LOWESS")
lines(result1, col="blue", lwd=2)
lines(result2, col="red", lwd=2)
lines(result3, col="green", lwd=2)
legend("topright", legend=c(paste0("BW=", bw1), 
                            paste0("BW=", bw2),
                            paste0("BW=", bw3)),
       col=c("blue", "red", "green"), lwd=2)
}

}
