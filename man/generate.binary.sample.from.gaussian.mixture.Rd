% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/synthetic_data_utils.R
\name{generate.binary.sample.from.gaussian.mixture}
\alias{generate.binary.sample.from.gaussian.mixture}
\title{Generate Binary Sample from Gaussian Mixture}
\usage{
generate.binary.sample.from.gaussian.mixture(
  gaussian.mixture.result,
  n.sample.points = 50,
  sample.method = c("uniform", "regular", "custom"),
  x.sample = NULL,
  use.true.y = TRUE,
  transform.method = c("logit", "direct"),
  logit.range = c(-3, 3),
  out.dir = NULL,
  verbose = FALSE,
  seed = NULL
)
}
\arguments{
\item{gaussian.mixture.result}{List or character. Either the result from
\code{generate.1d.gaussian.mixture} or \code{get.gaussian.mixture}, or a path
to a file containing such results.}

\item{n.sample.points}{Integer. Number of points to sample. Default is 50.}

\item{sample.method}{Character. Method for selecting sample points:
\itemize{
\item "uniform": Random uniform sampling within x range (default)
\item "regular": Equally spaced points
\item "custom": User-specified x locations (requires x.sample parameter)
}}

\item{x.sample}{Numeric vector. Custom x locations when sample.method = "custom".}

\item{use.true.y}{Logical. If TRUE, use y.true (without noise) if available.
Default is TRUE.}

\item{transform.method}{Character. Method to transform y values to probabilities:
\itemize{
\item "logit": Normalize to logit.range then apply inverse logit (default)
\item "direct": Normalize directly to \eqn{[0,1]}
}}

\item{logit.range}{Numeric vector of length 2. When transform.method = "logit",
the range to normalize y values before applying inverse logit. Default is c(-3, 3).}

\item{out.dir}{Character or NULL. Directory to save results. If NULL, results
are not saved. Default is NULL.}

\item{verbose}{Logical. Whether to print file path when saving. Default is FALSE.}

\item{seed}{Integer or NULL. Random seed for reproducibility. Default is NULL.}
}
\value{
A list containing:
\item{x}{Numeric vector. The x-coordinates of the sampled points.}
\item{y.binary}{Integer vector. The binary sample (0 or 1).}
\item{y.prob}{Numeric vector. The probability of Y=1 for each point.}
\item{y.smooth}{Numeric vector. The interpolated y values before transformation.}
\item{gaussian.mixture}{List. The original Gaussian mixture result.}
\item{params}{List. Parameters used for generation.}
}
\description{
Transforms a Gaussian mixture into a probability function using logistic transformation
and generates binary samples based on these probabilities. This is useful for creating
synthetic binary response data with complex non-linear relationships.
}
\details{
The function performs the following steps:
\enumerate{
\item Extracts the smooth function from the Gaussian mixture
\item Selects sample points according to sample.method
\item Interpolates y values at sample points
\item Transforms y values to probabilities using specified method
\item Generates binary outcomes using binomial sampling
}

For the logit transformation method, y values are first normalized to logit.range,
then the inverse logit function is applied: p = 1/(1 + exp(-y_normalized)).
This creates a smooth probability function that approaches 0 and 1 asymptotically.
}
\examples{
# First generate a Gaussian mixture
gm <- generate.1d.gaussian.mixture(
  x.knots = c(-2, 0, 2),
  y.knots = c(-1, 2, -1.5)
)

# Generate binary sample with default settings
binary.data <- generate.binary.sample.from.gaussian.mixture(gm)

# Plot the results
plot(gm$x, gm$y, type = 'l', col = 'blue',
     main = "Gaussian Mixture and Binary Sample")
points(binary.data$x, binary.data$y.binary, pch = 19,
       col = ifelse(binary.data$y.binary == 1, "green", "red"))
lines(binary.data$x, binary.data$y.prob, col = 'orange', lwd = 2)

# Generate regular grid sample with wider logit range
binary.regular <- generate.binary.sample.from.gaussian.mixture(
  gm,
  n.sample.points = 100,
  sample.method = "regular",
  logit.range = c(-5, 5)  # Steeper probability transitions
)

}
