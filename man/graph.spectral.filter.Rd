% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/graph_spectral_filter.R
\name{graph.spectral.filter}
\alias{graph.spectral.filter}
\title{Spectral Filtering for Graph Signals}
\usage{
graph.spectral.filter(
  adj.list,
  weight.list,
  y,
  laplacian.type = 4L,
  filter.type = 1L,
  laplacian.power = 3L,
  kernel.tau.factor = 0.05,
  kernel.radius.factor = 5,
  kernel.type = 0L,
  kernel.adaptive = FALSE,
  kernel.min.radius.factor = 0.05,
  kernel.max.radius.factor = 0.99,
  kernel.domain.min.size = 4L,
  kernel.precision = 1e-06,
  n.evectors.to.compute = min(c(20L, length(y) - 2L)),
  n.candidates = 200L,
  log.grid = TRUE,
  with.t.predictions = TRUE,
  verbose = FALSE
)
}
\arguments{
\item{adj.list}{A list of integer vectors representing the adjacency list of the graph. Each
element \code{adj.list[[i]]} contains the indices of vertices adjacent to vertex \code{i}.
Uses 1-based indexing. Must be non-empty.}

\item{weight.list}{A list of numeric vectors where \code{weight.list[[i]]} contains the edge
weights corresponding to the edges in \code{adj.list[[i]]}. Must have the same structure
as \code{adj.list}.}

\item{y}{Numeric vector of length equal to the number of vertices containing the signal values
to be filtered. NA values are not allowed.}

\item{laplacian.type}{Integer code specifying the type of graph Laplacian to use (default: 4).
Valid values are 0-11. See Details section for descriptions of each type.}

\item{filter.type}{Integer code specifying the type of spectral filter to apply (default: 1).
Valid values are 0-11. See Details section for descriptions of each type.}

\item{laplacian.power}{Positive integer specifying the power to which the Laplacian is raised
(default: 3). Higher powers provide smoother filtering.}

\item{kernel.tau.factor}{Positive numeric value in (0,1] determining kernel bandwidth as a
fraction of graph diameter (default: 0.05).}

\item{kernel.radius.factor}{Numeric value >= 1 multiplying the search radius when finding
vertices within kernel range (default: 5.0).}

\item{kernel.type}{Integer code (0-8) specifying the kernel function type (default: 0 for
Gaussian). See Details section.}

\item{kernel.adaptive}{Logical indicating whether to use locally adaptive kernel bandwidth
(default: FALSE).}

\item{kernel.min.radius.factor}{Minimum radius factor in (0,1) as fraction of graph diameter
(default: 0.05).}

\item{kernel.max.radius.factor}{Maximum radius factor in (0,1] as fraction of graph diameter
(default: 0.99).}

\item{kernel.domain.min.size}{Positive integer specifying minimum number of vertices required
within radius for kernel computations (default: 4).}

\item{kernel.precision}{Positive numeric value for radius determination precision (default: 1e-6).}

\item{n.evectors.to.compute}{Positive integer specifying number of Laplacian eigenpairs to
compute. Default is \code{min(20, length(y)-2)}.}

\item{n.candidates}{Positive integer specifying number of filter parameter values to evaluate
(default: 200).}

\item{log.grid}{Logical indicating whether to use logarithmically-spaced filter parameters
(default: TRUE).}

\item{with.t.predictions}{Logical indicating whether to return smoothed signals for all
parameter values (default: TRUE).}

\item{verbose}{Logical indicating whether to print progress information (default: FALSE).}
}
\value{
An object of class \code{"graph_spectral_filter"}, which is a list containing:
\describe{
\item{evalues}{Numeric vector of eigenvalues of the Laplacian operator}
\item{evectors}{Matrix of corresponding eigenvectors (columns)}
\item{candidate_ts}{Numeric vector of filter parameter values tested}
\item{gcv_scores}{Numeric vector of Generalized Cross-Validation scores}
\item{opt_t_idx}{Integer index of the optimal parameter value}
\item{predictions}{Numeric vector of smoothed signal at optimal parameter}
\item{t_predictions}{Matrix of smoothed signals at each parameter (if requested)}
\item{laplacian_type}{Factor indicating Laplacian type used}
\item{filter_type}{Factor indicating filter type applied}
\item{laplacian_power}{Integer power to which Laplacian was raised}
\item{kernel_params}{List of kernel parameters used}
\item{compute_time_ms}{Numeric computation time in milliseconds}
\item{gcv_min_score}{Numeric minimum GCV score achieved}
}
}
\description{
Implements a comprehensive framework for spectral filtering of signals defined on graph vertices.
Supports multiple types of graph Laplacians, spectral filters, and parameter configurations
to achieve different smoothing characteristics.
}
\details{
The general spectral filtering process follows these steps:
\enumerate{
\item Constructs a specific graph Laplacian operator based on the selected Laplacian type
\item Computes the eigendecomposition of this Laplacian (or its transformation)
\item Projects the signal onto the eigenbasis (Graph Fourier Transform)
\item Applies filter weights based on the eigenvalues and selected filter type
\item Reconstructs smoothed signals for a grid of filter parameter values
\item Selects the optimal parameter using Generalized Cross-Validation (GCV)
}

The function provides extensive flexibility through different Laplacian constructions,
various spectral filter types, and parameter controls for localization and smoothness.
}
\section{Laplacian Types}{

\describe{
\item{0 - STANDARD}{L = D - A, the combinatorial Laplacian. Provides basic smoothing that
minimizes first differences across edges. Best for general-purpose smoothing on regularly
structured graphs.}
\item{1 - NORMALIZED}{L_norm = D^(-1/2) L D^(-1/2), the normalized Laplacian. Accounts for
varying vertex degrees, giving more balanced smoothing on irregular graphs. Recommended
for graphs with highly variable connectivity.}
\item{2 - RANDOM_WALK}{L_rw = D^(-1) L, the random walk Laplacian. Similar to normalized
Laplacian but with asymmetric normalization. Useful when modeling diffusion processes.}
\item{3 - KERNEL}{L_kernel = D_kernel - W_kernel, a Laplacian constructed using distance-based
kernel weights rather than adjacency weights. Provides smoother spectral response,
especially on irregular or noisy graphs.}
\item{4 - NORMALIZED_KERNEL}{Normalized version of the kernel Laplacian. Combines benefits
of normalization and kernel-based edge weighting. Excellent for irregular graphs where
geometric relationships matter.}
\item{5 - ADAPTIVE_KERNEL}{Kernel Laplacian with locally adaptive bandwidth. Adjusts smoothing
automatically based on local graph density. Best for graphs with highly variable density.}
\item{6 - SHIFTED}{I - L, the shifted standard Laplacian. Inverts the spectrum to emphasize
smooth components. Particularly effective for chain graphs and 1D signals.}
\item{7 - SHIFTED_KERNEL}{I - L_kernel, the shifted kernel Laplacian. Combines kernel-based
edge weighting with spectral inversion.}
\item{8 - REGULARIZED}{L + \eqn{\epsilon}*I, adds small regularization to ensure positive definiteness.
Helps with numerical stability in filtering operations.}
\item{9 - REGULARIZED_KERNEL}{L_kernel + \eqn{\epsilon}*I, regularized version of kernel Laplacian.}
\item{10 - MULTI_SCALE}{Weighted combination of kernel Laplacians at different scales.
Captures both fine and coarse features simultaneously.}
\item{11 - PATH}{Path Laplacians for specialized graph structures.}
}
}

\section{Filter Types}{

\describe{
\item{0 - HEAT}{\eqn{\exp(-t \lambda)}, classic heat kernel filter. Provides smooth decay across
frequencies with more pronounced filtering at higher frequencies.}
\item{1 - GAUSSIAN}{\eqn{\exp(-t \lambda^2)}), Gaussian spectral filter. More aggressive decay at higher
frequencies than heat kernel. Produces very smooth results with minimal ringing.}
\item{2 - NON_NEGATIVE}{\eqn{\exp(-t \max(\lambda,0))}, truncated heat kernel that only attenuates
non-negative eigenvalues.}
\item{3 - CUBIC_SPLINE}{\eqn{1/(1+t \lambda^2)}, filter that mimics cubic spline behavior. Minimizes
second derivatives, producing the smoothest results while preserving linear trends.}
\item{4 - EXPONENTIAL}{\eqn{\exp(-t \sqrt(\lambda))}, less aggressive decay than heat kernel.}
\item{5 - MEXICAN_HAT}{\eqn{\lambda \exp(-t \lambda^2)}, band-pass filter that enhances mid-frequencies.}
\item{6 - IDEAL_LOW_PASS}{1 for \eqn{\lambda < t}, 0 otherwise. Sharp cutoff filter.}
\item{7 - BUTTERWORTH}{\eqn{1/(1+(\lambda/t)^(2n))}, smoother cutoff than ideal filter.}
\item{8 - TIKHONOV}{\eqn{1/(1+t\lambda)}, first-order smoothing filter.}
\item{9 - POLYNOMIAL}{\eqn{(1-\lambda/\lambda_{\max})^p} for \eqn{\lambda < \lambda_{\max}}, polynomial decay filter.}
\item{10 - INVERSE_COSINE}{\eqn{\cos(\pi \lambda/(2\lambda_{\max}))}, smooth filter with cosine profile.}
\item{11 - ADAPTIVE}{Data-driven filter that adapts to signal properties.}
}
}

\section{Kernel Types}{

\describe{
\item{0 - GAUSSIAN}{\eqn{\exp(-d^2/\tau^2)}, Classic bell curve, smooth decay from center}
\item{1 - EXPONENTIAL}{\eqn{\exp(-d/\tau)}, Sharper peak, heavier tails than Gaussian}
\item{2 - HEAT}{\eqn{\exp(\frac{-d^2}{4\tau})}, Similar to Gaussian but with different scaling}
\item{3 - TRICUBE}{\eqn{(1-(d/\tau)^3)^3} for \eqn{d < \tau}, Compact support, smooth transition to zero}
\item{4 - EPANECHNIKOV}{\eqn{1-(d/\tau)^2} for \eqn{d < \tau}, Parabolic shape, optimal in statistical sense}
\item{5 - UNIFORM}{1 for \eqn{d < \tau}, 0 otherwise, Equal weighting within radius}
\item{6 - TRIANGULAR}{\eqn{1-|d/\tau|} for \eqn{d < \tau}, Linear decay from center}
\item{7 - QUARTIC}{\eqn{(1-(d/\tau)^2)^2} for \eqn{d < \tau}, Similar to Gaussian but with compact support}
\item{8 - TRIWEIGHT}{\eqn{(1-(d/\tau)^2)^3} for \eqn{d < \tau}, Higher-order version of quartic}
}
}

\examples{
\dontrun{
# Create a simple chain graph with 30 vertices (for CRAN check timing)
n <- 30
adj_list <- vector("list", n)
weight_list <- vector("list", n)

# Build adjacency structure for chain
for (i in seq_len(n)) {
  adj_list[[i]] <- integer(0)
  weight_list[[i]] <- numeric(0)

  if (i > 1) {
    adj_list[[i]] <- c(adj_list[[i]], i - 1L)
    weight_list[[i]] <- c(weight_list[[i]], 1.0)
  }
  if (i < n) {
    adj_list[[i]] <- c(adj_list[[i]], i + 1L)
    weight_list[[i]] <- c(weight_list[[i]], 1.0)
  }
}

# Create a noisy signal
set.seed(123)
x <- seq(0, 1, length.out = n)
y <- sin(2 * pi * x) + rnorm(n, 0, 0.2)

# Standard Laplacian with heat kernel filter
result1 <- graph.spectral.filter(
  adj.list = adj_list,
  weight.list = weight_list,
  y = y,
  laplacian.type = 0L,    # STANDARD
  filter.type = 0L,       # HEAT
  laplacian.power = 1L,
  n.candidates = 50       # Reduced for faster execution
)

# Cubic spline-like smoothing
result2 <- graph.spectral.filter(
  adj.list = adj_list,
  weight.list = weight_list,
  y = y,
  laplacian.type = 0L,    # STANDARD
  filter.type = 3L,       # CUBIC_SPLINE
  laplacian.power = 2L,
  n.candidates = 50
)

# Compare results
plot(x, y, pch = 16, col = "gray", main = "Graph Spectral Filtering",
     xlab = "Position", ylab = "Value")
lines(x, result1$predictions, col = "blue", lwd = 2)
lines(x, result2$predictions, col = "red", lwd = 2)
legend("topright",
       legend = c("Noisy data", "Heat kernel", "Cubic spline"),
       pch = c(16, NA, NA),
       lty = c(NA, 1, 1),
       col = c("gray", "blue", "red"),
       lwd = c(NA, 2, 2))

# Print summary
summary(result1)
}

}
\references{
Shuman, D. I., Narang, S. K., Frossard, P., Ortega, A., & Vandergheynst, P. (2013).
The emerging field of signal processing on graphs: Extending high-dimensional data
analysis to networks and other irregular domains. IEEE Signal Processing Magazine,
30(3), 83-98.
}
\seealso{
\code{\link{plot.graph_spectral_filter}} for visualization,
\code{\link{predict.graph_spectral_filter}} for prediction
}
