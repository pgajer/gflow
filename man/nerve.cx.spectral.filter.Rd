% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/nerve_cx_spectral_filter.R
\name{nerve.cx.spectral.filter}
\alias{nerve.cx.spectral.filter}
\title{Apply Spectral Filtering to a Nerve Complex}
\usage{
nerve.cx.spectral.filter(
  complex,
  y,
  laplacian.type = "STANDARD",
  filter.type = "HEAT",
  laplacian.power = 1,
  dim.weights = NULL,
  kernel.params = list(tau.factor = 0.01, radius.factor = 3, kernel.type = 0),
  n.evectors = 100,
  n.candidates = 100,
  log.grid = TRUE,
  with.t.predictions = FALSE,
  verbose = FALSE
)
}
\arguments{
\item{complex}{A nerve complex object created by \code{\link{create.nerve.complex}}.
Must contain a valid complex pointer and dimension information.}

\item{y}{Numeric vector of function values at vertices of the complex. Length must
equal the number of vertices in the complex.}

\item{laplacian.type}{Character string specifying the type of Laplacian. One of:
\describe{
\item{\code{"STANDARD"}}{Standard combinatorial Laplacian (default)}
\item{\code{"NORMALIZED"}}{Normalized Laplacian}
\item{\code{"RANDOM_WALK"}}{Random walk Laplacian}
\item{\code{"SHIFTED"}}{Shifted Laplacian (I - L)}
\item{\code{"REGULARIZED"}}{Regularized Laplacian (L + epsilon*I)}
}}

\item{filter.type}{Character string specifying the type of spectral filter. One of:
\describe{
\item{\code{"HEAT"}}{Heat kernel filter \eqn{\exp(-t\lambda)} (default)}
\item{\code{"GAUSSIAN"}}{Gaussian filter \eqn{\exp(-t\lambda^2)}}
\item{\code{"NON_NEGATIVE"}}{Non-negative heat kernel filter}
\item{\code{"CUBIC_SPLINE"}}{Cubic spline filter \eqn{1/(1+t\lambda^2)}}
\item{\code{"EXPONENTIAL"}}{Exponential filter}
\item{\code{"MEXICAN_HAT"}}{Mexican hat wavelet filter}
\item{\code{"IDEAL_LOW_PASS"}}{Ideal low-pass filter}
\item{\code{"BUTTERWORTH"}}{Butterworth filter}
\item{\code{"TIKHONOV"}}{Tikhonov filter}
\item{\code{"POLYNOMIAL"}}{Polynomial filter}
\item{\code{"INVERSE_COSINE"}}{Inverse cosine filter}
\item{\code{"ADAPTIVE"}}{Adaptive filter}
}}

\item{laplacian.power}{Positive integer specifying the power to which the Laplacian
is raised. Default is 1. Higher powers produce smoother results.}

\item{dim.weights}{Numeric vector of non-negative weights for each dimension's
contribution to the full Laplacian. Length should be at least max.dimension + 1.
Default is a vector of 1s. The i-th element weights the i-1 dimensional simplices.}

\item{kernel.params}{Named list of kernel parameters used by certain Laplacian types:
\describe{
\item{\code{tau.factor}}{Factor for kernel bandwidth (0 < tau.factor <= 1)}
\item{\code{radius.factor}}{Factor for neighborhood radius (>= 1)}
\item{\code{kernel.type}}{Integer code for kernel type (0-8)}
}}

\item{n.evectors}{Positive integer specifying the number of eigenvectors to compute.
Default is 100. Set to 0 to compute all eigenvectors (may be slow for large complexes).}

\item{n.candidates}{Positive integer specifying the number of filter parameter values
to evaluate for automatic selection via GCV. Default is 100.}

\item{log.grid}{Logical indicating whether to use logarithmic spacing for the parameter
grid (TRUE, default) or linear spacing (FALSE).}

\item{with.t.predictions}{Logical indicating whether to return predictions for all
tested parameter values (TRUE) or only the optimal value (FALSE, default).}

\item{verbose}{Logical indicating whether to print progress information during
computation. Default is FALSE.}
}
\value{
An object of class \code{nerve_cx_spectral_filter} containing:
\item{predictions}{Numeric vector of smoothed function values at the optimal parameter}
\item{optimal_parameter}{The selected optimal filter parameter value}
\item{gcv_score}{The GCV score at the optimal parameter}
\item{all_parameters}{Vector of all tested parameter values}
\item{all_gcv_scores}{Vector of GCV scores for each parameter}
\item{compute_time_ms}{Computation time in milliseconds}
\item{method}{List containing the input method parameters}
\item{t_predictions}{(Optional) Matrix of predictions for all parameter values if
\code{with.t.predictions = TRUE}}
}
\description{
Performs spectral filtering on a signal defined on the vertices of a nerve complex.
This method extends graph spectral filtering to incorporate higher-order relationships
captured by the simplicial structure of the nerve complex. The filtering uses a full
Laplacian that combines information from all dimensions of simplices, weighted according
to the specified dimension weights.
}
\details{
The function implements a comprehensive framework for spectral filtering on nerve complexes.
The general process involves:
\enumerate{
\item Construction of a weighted Laplacian operator incorporating all simplex dimensions
\item Eigendecomposition of the Laplacian
\item Application of the specified spectral filter in the frequency domain
\item Automatic parameter selection using Generalized Cross-Validation (GCV)
}

The dimension weights allow flexible control over how much each simplex dimension
contributes to the overall smoothing. Setting higher weights for higher dimensions
incorporates more global structure into the filtering.
}
\section{Parameter Selection}{

The optimal filter parameter is selected automatically using leave-one-out
Generalized Cross-Validation (GCV). This avoids overfitting and typically produces
good results without manual tuning.
}

\examples{
\dontrun{
# Generate 2D points
set.seed(123)
coords <- matrix(runif(200), ncol = 2)

# Create a smooth function with noise
f_true <- function(x) sin(2*pi*x[1]) * cos(2*pi*x[2])
y_true <- apply(coords, 1, f_true)
y_noisy <- y_true + rnorm(length(y_true), 0, 0.2)

# Create nerve complex
complex <- create.nerve.complex(coords, k = 8, max.dim = 2)
complex <- set.complex.function.values(complex, y_noisy)

# Apply spectral filtering with default parameters
result <- nerve.cx.spectral.filter(complex, y_noisy)

# Apply with custom parameters emphasizing higher dimensions
result2 <- nerve.cx.spectral.filter(
  complex, y_noisy,
  laplacian.type = "NORMALIZED",
  filter.type = "GAUSSIAN",
  dim.weights = c(1.0, 0.5, 0.25),
  n.candidates = 150,
  verbose = TRUE
)

# Compare results
mse1 <- mean((result$predictions - y_true)^2)
mse2 <- mean((result2$predictions - y_true)^2)
cat("MSE (default):", mse1, "\n")
cat("MSE (custom):", mse2, "\n")
}

}
\seealso{
\code{\link{create.nerve.complex}} for creating nerve complexes,
\code{\link{set.complex.function.values}} for setting function values,
\code{\link{plot.nerve_cx_spectral_filter}} for visualization
}
