% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/graph_utils.R
\name{compute.local.distance.fidelity}
\alias{compute.local.distance.fidelity}
\title{Assess Fidelity of Graph-Based Geodesic Distances to Euclidean Geometry}
\usage{
compute.local.distance.fidelity(X, adj.list, weight.list, taus, max.k = 50)
}
\arguments{
\item{X}{A numeric matrix of shape \code{[n, d]}, where each row represents a data point in \code{d}-dimensional space.}

\item{adj.list}{A list of integer vectors of length \code{n}, giving the graph adjacency list. Each entry contains the 1-based indices of neighbors for that vertex.}

\item{weight.list}{A list of numeric vectors of same length as \code{adj.list}, where each element contains edge weights for the corresponding neighbors.}

\item{taus}{A numeric vector of radius values \eqn{\tau} used to define local neighborhoods around each point.}

\item{max.k}{Integer; the number of nearest neighbors to compute in the Euclidean space (used to approximate local neighborhoods).}
}
\value{
A named list of length equal to \code{length(taus)}. Each element is a list with:
\describe{
\item{\code{mean.jaccard}}{Mean Jaccard index over all data points for a given \eqn{\tau}.}
\item{\code{mean.mad}}{Mean absolute deviation in distances between Euclidean and graph metrics over intersecting neighbors.}
\item{\code{jaccard.vals}}{A numeric vector of Jaccard index values per vertex.}
\item{\code{mad.vals}}{A numeric vector of MAD values per vertex.}
}
}
\description{
This function compares local neighborhood structures defined by graph-based distances
to those defined in the original Euclidean space. It evaluates how well a given graph
preserves the local geometry of a dataset by computing two metrics for each data point:
}
\details{
\itemize{
\item \strong{Jaccard Index:} Measures the similarity between the sets of neighbors
within a radius \eqn{\tau} in both the Euclidean and graph-based spaces.
\item \strong{Mean Absolute Deviation (MAD):} Measures the distortion in local distances
over the intersection of the two neighborhood sets.
}

The graph is assumed to be provided as an adjacency list and a corresponding weight list.
Any duplicate edges (i.e., undirected edges appearing in both directions) are automatically deduplicated.
}
\examples{
\dontrun{
set.seed(1)
X <- matrix(rnorm(300 * 2), ncol = 2)
g <- build_graph(X)  # your function to generate adj.list and weight.list
taus <- seq(0.05, 0.2, by = 0.01)
fidelity <- compute.local.distance.fidelity(X, g$adj.list, g$weight.list, taus)
}

}
