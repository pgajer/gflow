% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/centered_paths.R
\name{get.path.data}
\alias{get.path.data}
\title{Compute Graph Path Data with Kernel Weights}
\usage{
get.path.data(
  adj.list,
  weight.list,
  y,
  ref.vertex,
  bandwidth,
  dist.normalization.factor = 1.01,
  min.path.size = 5L,
  diff.threshold = 5L,
  kernel.type = 7L,
  verbose = FALSE
)
}
\arguments{
\item{adj.list}{A list of integer vectors representing the graph's adjacency structure.
Each element \code{i} contains the vertices adjacent to vertex \code{i} (1-based indexing).}

\item{weight.list}{A list of numeric vectors containing edge weights.
Each element \code{i} contains weights corresponding to edges in \code{adj.list[[i]]}.}

\item{y}{A numeric vector of values associated with each vertex in the graph.}

\item{ref.vertex}{An integer specifying the reference vertex around which paths are constructed (1-based indexing).}

\item{bandwidth}{A positive numeric value specifying the maximum allowable path distance from the reference vertex.}

\item{dist.normalization.factor}{A numeric value between 0 and 1 for normalizing distances in kernel calculations (default: 1.01).}

\item{min.path.size}{An integer specifying the minimum number of vertices required in a valid path (default: 5).}

\item{diff.threshold}{An integer specifying the number of vertices after the ref vertex that two paths have to have different (set intersection is empty) to produce a composite path from these two paths. Default is 5. If out of valid range, will be auto-adjusted to the midpoint of the valid range.}

\item{kernel.type}{An integer specifying the kernel function type:
- 1: Epanechnikov
- 2: Triangular
- 4: Laplace
- 5: Normal
- 6: Biweight
- 7: Tricube (default)}

\item{verbose}{Logical indicating whether to print progress information. Default is FALSE.}
}
\value{
A list where each element represents a path and contains:
\item{vertices}{Integer vector of path vertices (1-based indices)}
\item{ref_vertex}{Integer indicating the reference vertex (1-based index)}
\item{rel_center_offset}{Numeric value indicating relative position of reference vertex (0 = center, 0.5 = endpoint)}
\item{total_weight}{Numeric value representing total path length}
\item{x_path}{Numeric vector of cumulative distances along path from start}
\item{w_path}{Numeric vector of kernel weights for each vertex}
\item{y_path}{Numeric vector of y-values for path vertices}
}
\description{
Analyzes paths in a graph centered around a reference vertex, computing distances,
kernel weights, and associated values along these paths. The function identifies
both single paths and composite paths that meet the minimum size requirement,
with the reference vertex serving as a central point in the path structure.
}
\note{
\itemize{
\item All vertex indices must be positive integers
\item Edge weights must be non-negative
\item The length of adj.list and weight.list must match
\item The reference vertex must exist in the graph
}
}
\examples{
\dontrun{
# Create a simple graph with 5 vertices
adj.list <- list(c(2,3), c(1,3,4), c(1,2,5), c(2), c(3))
weight.list <- list(c(1,1), c(1,1,1), c(1,1,1), c(1), c(1))
y <- c(1.5, 2.0, 0.5, 1.0, 1.5)

# Find paths centered around vertex 2
paths <- get.path.data(adj.list, weight.list, y,
                      ref.vertex = 2, bandwidth = 2)
}
}
\seealso{
The C++ implementation details can be found in the source code of S_get_path_data
}
