% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/random_sampling.R
\name{sample.from.1d.density}
\alias{sample.from.1d.density}
\title{Sample points from an empirical probability distribution}
\usage{
sample.from.1d.density(n, y, x = NULL)
}
\arguments{
\item{n}{Integer. Number of sample points to generate.}

\item{y}{Numeric vector. Non-negative values representing the density/histogram
heights at each grid point. Does not need to be normalized.}

\item{x}{Optional numeric vector. Grid points corresponding to y values.
Must be strictly increasing. If not provided, a uniform grid on \code{[0,1]}
is created with length(y) points.}
}
\value{
\if{html}{\out{<div class="sourceCode">}}\preformatted{ Numeric vector of length n containing samples from the distribution
         defined by the empirical density y over grid x.
}\if{html}{\out{</div>}}
}
\description{
This function generates random samples from a probability distribution defined by
discrete density values over a grid. It uses inverse transform sampling:
\enumerate{
\item Normalizes the input density values to create a proper PDF
\item Computes the cumulative distribution function (CDF)
\item Generates uniform random numbers
\item Uses inverse CDF method to transform uniform samples to the target distribution
}
}
\details{
The function performs the following steps:
\enumerate{
\item If x is not provided, creates a uniform grid on \code{[0,1]}
\item Normalizes y to create proper PDF by ensuring y*dx integrates to 1
\item Computes CDF through cumulative trapezoidal integration
\item Generates n uniform random numbers
\item Uses binary search to find inverse CDF values
}
}
