% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/parameterize_circular_graph.R
\name{parameterize.circular.graph}
\alias{parameterize.circular.graph}
\title{Parameterize a Circular Graph Structure for Biological Cycle Analysis}
\usage{
parameterize.circular.graph(adj.list, weight.list, use.edge.lengths = TRUE)
}
\arguments{
\item{adj.list}{A list of integer vectors representing the adjacency structure.
Each element \code{adj.list[[i]]} contains the indices of vertices adjacent
to vertex \code{i}. Uses 1-based indexing (R convention). In biological
applications, vertices might represent genes or cells with similar expression
patterns.}

\item{weight.list}{A list of numeric vectors containing edge weights. Each
element \code{weight.list[[i]]} contains the weights for edges from vertex
\code{i} to the vertices listed in \code{adj.list[[i]]}. Must have the same
structure as \code{adj.list}. Weights can represent similarity or distance
metrics between expression profiles.}

\item{use.edge.lengths}{Logical. If \code{TRUE}, edge weights from
\code{weight.list} are used in constructing the graph Laplacian. If
\code{FALSE}, all edges are treated as having unit weight. Default is
\code{TRUE}.}
}
\value{
A list of class \code{"circular_parameterization"} containing:
\describe{
\item{\code{angles}}{Numeric vector of angles in radians (range \eqn{[0, 2\pi]})
for each vertex, representing their position on the unit circle. In
cell cycle applications, these angles represent the inferred position
within the cycle.}
\item{\code{eig_vec2}}{Numeric vector containing the second eigenvector of
the graph Laplacian.}
\item{\code{eig_vec3}}{Numeric vector containing the third eigenvector of
the graph Laplacian.}
}
}
\description{
Applies spectral methods to parameterize a graph with a circular structure,
calculating the position of each vertex along a circle using eigenvectors of
the graph Laplacian. This function was motivated by the discovery that cell
cycle genes form a circular structure in high-dimensional expression space,
enabling cell cycle position assignment.
}
\details{
This function embeds a graph with circular topology onto a circle using the
second and third eigenvectors of the graph Laplacian matrix. The algorithm
computes an angle for each vertex, positioning it on the unit circle in a way
that preserves the graph structure.

The method is particularly useful for biological applications where the
underlying process has circular dynamics, such as the cell cycle. In such
cases, genes or cells can be ordered along a circle representing progression
through the cyclic process. The parameterization allows for synthetic
time-within-cycle assignment, where the computed angles represent positions
along the circular trajectory.

The graph Laplacian is constructed as L = D - W, where D is the degree matrix
and W is the weighted adjacency matrix. When \code{use.edge.lengths = TRUE},
edge weights are incorporated into the Laplacian construction. The method
works best for graphs with approximately circular connectivity patterns and
average vertex degree between 3 and 5.
}
\section{Note}{

The function internally converts R's 1-based indexing to 0-based indexing
before calling the underlying C++ implementation.
}

\examples{
# Example 1: Simple circular graph (like cell cycle progression)
n <- 8
adj.list <- lapply(seq_len(n), function(i) {
  c(if (i == n) 1 else i + 1,  # next vertex
    if (i == 1) n else i - 1)  # previous vertex
})
weight.list <- lapply(adj.list, function(adj) rep(1.0, length(adj)))

# Get circular parameterization
result <- parameterize.circular.graph(adj.list, weight.list, TRUE)

# Display angles (positions along the cycle)
print(round(result$angles, 2))

# Example 2: Biological application - genes with circular expression pattern
# Simulate a gene similarity network where genes are connected if their
# expression patterns are similar (simplified example)
n_genes <- 12
# Create connections based on proximity in the cycle
adj.list <- lapply(seq_len(n_genes), function(i) {
  # Connect to 2 neighbors on each side to simulate local similarity
  neighbors <- c((i - 2):(i - 1), (i + 1):(i + 2))
  neighbors <- ((neighbors - 1) \%\% n_genes) + 1
  neighbors[neighbors != i]  # Remove self-connections
})
# Weights decrease with distance in the cycle
weight.list <- lapply(seq_len(n_genes), function(i) {
  neighbors <- adj.list[[i]]
  weights <- sapply(neighbors, function(j) {
    dist <- min(abs(i - j), n_genes - abs(i - j))
    exp(-dist/2)  # Exponential decay
  })
  weights
})

result <- parameterize.circular.graph(adj.list, weight.list)

# Plot genes positioned by their inferred cycle position
plot(cos(result$angles), sin(result$angles),
     xlim = c(-1.2, 1.2), ylim = c(-1.2, 1.2),
     pch = 19, xlab = "x", ylab = "y", asp = 1,
     main = "Gene Positions in Expression Cycle")

# Add gene labels
text(1.1 * cos(result$angles), 1.1 * sin(result$angles),
     labels = paste0("G", seq_len(n_genes)), cex = 0.8)

# The angles can be interpreted as positions in the biological cycle
# For cell cycle: 0 = G1/S, pi/2 = S, pi = G2, 3*pi/2 = M phase

}
\references{
Zheng, S. C., Stein-O'Brien, G., Augustin, J. J., Slosberg, J., Carosso, G. A.,
Winer, B., ... & Hansen, K. D. (2022). Universal prediction of cell-cycle
position using transfer learning. Genome Biology, 23(1), 41.
\doi{10.1186/s13059-021-02581-y}
}
