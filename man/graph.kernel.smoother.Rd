% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/graph_kernel_smoother.R
\name{graph.kernel.smoother}
\alias{graph.kernel.smoother}
\title{Graph Kernel Smoother}
\usage{
graph.kernel.smoother(adj, w, y, bandwidth, with_details = FALSE)
}
\arguments{
\item{adj}{A list of integer vectors; the adjacency list of the graph.
Each element \code{adj[[i]]} contains the (1-based) neighbor indices of vertex \code{i}.}

\item{w}{A list of numeric vectors of the same shape as \code{adj}, or \code{NULL}.
If provided, \code{w[[i]]} must have length \code{length(adj[[i]])} and
contains edge weights for the neighbors of vertex \code{i}. Use \code{NULL}
for unweighted graphs (defaults to weight 1 per edge).}

\item{y}{A numeric vector of length \code{length(adj)}; the signal to be smoothed.}

\item{bandwidth}{Integer bandwidth (method-specific; typically controls kernel
neighborhood/scale). Must be \eqn{\ge 1}.}

\item{with_details}{Logical; if \code{TRUE}, include additional diagnostics
(e.g., per-vertex bandwidth usage, iteration counts). Defaults to \code{FALSE}.}
}
\value{
A named list with components:
\itemize{
\item \code{fitted} — numeric vector of length \code{length(y)} with smoothed values.
\item \code{bandwidth} — integer bandwidth actually used.
\item \code{details} — (optional) a list of diagnostics, present when \code{with_details = TRUE}.
}
}
\description{
Smooth a scalar signal on a graph using kernel weights along edges.
This is a thin user-facing wrapper that forwards to the Rcpp
implementation \code{Rcpp_graph_kernel_smoother()}.
}
\section{Input requirements}{

\itemize{
\item \code{adj} must be a list the same length as \code{y}; neighbors are 1-based indices.
\item If \code{w} is not \code{NULL}, it must be a list the same length as \code{adj} with
\code{length(w[[i]]) == length(adj[[i]])} for all \code{i}.
}
}

\section{Notes}{

This wrapper only orchestrates I/O and delegates computation to the Rcpp routine
\code{Rcpp_graph_kernel_smoother()}. For reproducibility, ensure any stochastic
components in the underlying method are deterministically seeded upstream.
}

\examples{
\dontrun{
# Tiny chain graph with unit weights
n <- 5L
adj <- vector("list", n)
for (i in seq_len(n)) {
  adj[[i]] <- unique(c(if (i > 1) i - 1L else integer(), if (i < n) i + 1L else integer()))
}
w <- lapply(adj, function(nei) rep(1, length(nei)))
y <- as.numeric(1:n)

fit <- graph.kernel.smoother(adj, w, y, bandwidth = 2L, with_details = FALSE)
str(fit)
}

}
