% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/find_shortest_paths_within_radius.R
\name{find.shortest.paths.within.radius}
\alias{find.shortest.paths.within.radius}
\title{Find All Shortest Paths Within a Radius}
\usage{
find.shortest.paths.within.radius(adj.list, weight.list, start, radius)
}
\arguments{
\item{adj.list}{A list of integer vectors, where each vector contains the indices
of vertices adjacent to the vertex at that position in the list.
For example, \code{adj.list[[1]]} contains the indices of vertices connected to vertex 1.}

\item{weight.list}{A list of numeric vectors containing the weights of edges in the
corresponding \code{adj.list}. \code{weight.list[[i]][j]} is the weight of the edge between
vertex i and vertex \code{adj.list[[i]][j]}.}

\item{start}{The index of the starting vertex (1-based indexing as is standard in R).}

\item{radius}{The maximum allowed distance for paths from the start vertex.
Paths with a total weight greater than this value will not be included in the results.}
}
\value{
A list containing:
\item{paths}{A list of integer vectors, where each vector represents a path from
the start vertex to another vertex in the graph. Each element of the vector
is a vertex index.}
\item{reachable.vertices}{An integer vector containing all vertices that are
reachable from the start vertex within the given radius.}
\item{vertex.to.path.map}{A matrix with three columns: "vertex", "path.index", and
"total.weight". Each row maps a reachable vertex to its corresponding path in
the paths list and includes the total weight (distance) to that vertex. This
provides efficient O(1) lookup for finding the shortest path to any specific vertex.}
}
\description{
Finds all shortest paths from a starting vertex to other vertices in a weighted graph,
limited by a maximum distance (radius). This function implements a modified version of
Dijkstra's algorithm optimized for local neighborhood exploration.
}
\details{
The function converts the R graph representation to a C++ graph, and then uses an efficient
implementation of a bounded Dijkstra's algorithm to find all shortest paths within the
specified radius. The algorithm works in two phases:
\enumerate{
\item A bounded Dijkstra's algorithm to find distances and predecessors
\item Path reconstruction to generate actual paths from the collected information
}

The resulting paths are sorted in descending order of their total weights.
}
\examples{
# Create a simple graph with 5 vertices
adj.list <- list(c(2, 3), c(1, 3, 4), c(1, 2, 5), c(2, 5), c(3, 4))
weight.list <- list(c(1, 2), c(1, 1, 3), c(2, 1, 2), c(3, 1), c(2, 1))

# Find all shortest paths within radius 3 from vertex 1
(res <- find.shortest.paths.within.radius(adj.list, weight.list, 1, 3))

}
\seealso{
For graph creation and manipulation, consider using the \code{igraph} package.
}
