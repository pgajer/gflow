##
## Geodesic distance, knn etc functions
##

#' Estimates the shortest paths distances between points of X.
#'
#' @param X      A matrix of points.
#'
#' @param K      The number of neighbors in edges.of.knn.graph() to build a knn graph. When
#'               k=1, the knn graph is the minimal spanning tree.
#'
#' @param G      A graph associated with X.
#'
#' @param method A method for building a graph distances within which are going
#'               to give shortest path distance estimates. This parameter is not used now,
#'               but in the nearest future I am envisioning other methods of constructing
#'               the graph. Methods: 'knn.graph', 'MST', 'runif-MST', 'kde'.
#'
#' @return       A distance matrix.
geodesic.dist <- function(X, K = 5, G = NULL, method="knn.graph")
{
    if ( is.null(G) ) {

        if ( K == 1 ) {
            A <- mstree.adj.mat(X)
        } else {
            E <- edges.of.knn.graph(X, k=K)
            A <- graph.adj.mat(X, E)
        }

        G <- graph.adjacency(A, mode="undirected", weighted=TRUE)
    }

    d <- distances(G)
    rownames(d) <- rownames(X)
    colnames(d) <- rownames(X)

    d
}

#' Estimate Geodesic Distances Between Points
#'
#' This function estimates the shortest path distances (geodesic distances) between points
#' in a given dataset. It can use either a k-nearest neighbors graph or a minimal spanning tree.
#'
#' @param points A matrix or data frame where each row represents a point in the feature space.
#' @param k Positive integer. The number of nearest neighbors to use when constructing the graph.
#'   When k=1 or method='mst', a minimal spanning tree is used instead. Default is 5.
#' @param graph An optional igraph object representing the graph structure of the points.
#'   If provided, this graph will be used instead of constructing a new one.
#' @param method Character string specifying the method to use for constructing the graph.
#'   Must be either "knn.graph" (default) or "mst" (minimal spanning tree).
#'
#' @return A distance matrix containing the estimated geodesic distances between all pairs of points.
#'
#' @examples
#' points <- matrix(rnorm(100), ncol = 2)
#' distances <- estimate.geodesic.distances(points, k = 3)
#' print(distances[1:5, 1:5])
#'
#' @importFrom igraph mst graph_from_adjacency_matrix graph_from_edgelist distances
#' @importFrom FNN get.knn
#' @importFrom stats dist
#'
#' @export
estimate.geodesic.distances <- function(points, k = 5, graph = NULL, method = "knn.graph") {

    ## Input validation
    if (!is.matrix(points) && !is.data.frame(points)) {
        stop("points must be a matrix or data frame.")
    }
    if (!is.numeric(k) || k < 1 || k != as.integer(k)) {
        stop("k must be a positive integer.")
    }
    if (!is.null(graph) && !inherits(graph, "igraph")) {
        stop("If provided, graph must be an igraph object.")
    }
    if (!method %in% c("knn.graph", "mst")) {
        stop("method must be either 'knn.graph' or 'mst'.")
    }

    ## Ensure required packages are available
    if (!requireNamespace("igraph", quietly = TRUE)) {
        stop("Package 'igraph' is required for this function to work. Please install it.")
    }
    if (!requireNamespace("FNN", quietly = TRUE)) {
        stop("Package 'FNN' is required for this function to work. Please install it.")
    }

    if (is.null(graph)) {
        if (method == "mst" || k == 1) {
            ## Minimal Spanning Tree
            dist.matrix <- as.matrix(dist(points))
            graph <- igraph::mst(igraph::graph.from.adjacency.matrix(dist.matrix, weighted = TRUE, mode = "undirected"))
        } else {
            ## K-Nearest Neighbors Graph
            nn <- FNN::get.knn(points, k = k)
            edges <- cbind(rep(1:nrow(points), each = k), as.vector(nn$nn.index))
            distances <- as.vector(nn$nn.dist)
            graph <- igraph::graph.from.edgelist(edges, directed = FALSE)
            igraph::E(graph)$weight <- distances
        }
    }

    ## Calculate geodesic distances
    geodesic.distances <- igraph::distances(graph)
    rownames(geodesic.distances) <- rownames(points)
    colnames(geodesic.distances) <- rownames(points)

    return(geodesic.distances)
}


#' Computes the inverse of a permutation vector generated by order()
#'
#' @param o A permutation vector generated by order().
o.inv.fn <- function(o)
{
    n <- length(o)
    o.inv <- numeric(n)
    for ( i in seq(n) )
    {
        o.inv[o[i]] <- i
    }

    o.inv
}

#' Producess k-NN distance and index matrices associated with a distance matrix.
#'
#' @param d   A distance matrix.
#' @param k   The number of nearest neighbors.
dist.to.knn <- function(d, k)
{
    stopifnot(isSymmetric(d))

    n <- nrow(d)
    nn.i <- matrix(0,nrow=n, ncol=k)
    nn.d <- matrix(0,nrow=n, ncol=k)
    for ( i in seq(n) )
    {
        x <- as.numeric(d[i,])
        o <- order(x)
        nn.i[i,] <- o[seq(k)]
        nn.d[i,] <- x[o[seq(k)]]
    }

    list(nn.i=nn.i,
         nn.d=nn.d)
}

#' Estimates geodesic (shortest path) nearest neighbors.
#'
#' @param X      A numeric matrix.
#' @param k      The number of nearest neighbors to be returned.
#' @param K    The number of neighbors in knn.graph() to build a knn graph. When
#'               k=1, the knn graph is the minimal spanning tree.
#'
#' @param G      A graph associated with X.
#'
#' @return       Returns two matrices nn.index and nn.dist as in get.knn()
geodesic.knn <- function(X, k, K=5, G=NULL) {

    if (!is.matrix(X)) {
        X <- try(as.matrix(X), silent = TRUE)
        if (inherits(X, "try-error")) {
            stop("X must be a matrix or coercible to a matrix")
        }
    }

    if (!is.numeric(X)) {
        stop("X must contain numeric values")
    }

    if (any(is.na(X)) || any(is.infinite(X))) {
        stop("X cannot contain NA, NaN, or Inf values")
    }

    stopifnot(k>0)

    ##d <- geodesic.dist(X, K, G)
    d <- estimate.geodesic.distances(X, K, G)

    r <- dist.to.knn(d, k)

    list(nn.index=r$nn.i,
         nn.dist=r$nn.d)
}

#' Estimates geodesic (shortest path) nearest neighbors of X.grid points in X.
#' That is for each point of X.grid the k-NN's within X are returned.
#'
#' @param X      A numeric matrix.
#' @param X.grid A grid associated with X.
#'
#' @param method A method for building a graph distances within which are going
#'               to give shortest path distance estimates. This parameter is not used now,
#'               but in the nearest future I am envisioning other methods of constructing
#'               the graph.
#'
#' @param K    The number of neighbors in knn.graph() to build a knn graph. When
#'               k=1, the knn graph is the minimal spanning tree.
#'
#' @param k      The number of nearest neighbors to be returned.
#'
#' @return       Returns two matrices nn.index and nn.dist as in get.knn()
geodesic.knnx <- function(X, X.grid, k, method="knn.graph", K=5) {

    if (!is.matrix(X)) {
        X <- try(as.matrix(X), silent = TRUE)
        if (inherits(X, "try-error")) {
            stop("X must be a matrix or coercible to a matrix")
        }
    }

    if (!is.numeric(X)) {
        stop("X must contain numeric values")
    }

    if (any(is.na(X)) || any(is.infinite(X))) {
        stop("X cannot contain NA, NaN, or Inf values")
    }

    stopifnot(k>0)

    n <- nrow(X)
    N <- nrow(X.grid)

    dimK <- 2 * ncol(X) # in dim 1 grid vertex has only 2 nbrs, in dim 2 - 4, in dim 3 - 6 etc
    nn <- get.knn(X.grid, k=dimK)

    E.grid <- matrix(nrow=dimK*N, ncol=2)
    ii <- seq(N)
    for ( i in seq(dimK) )
    {
        E.grid[ii,] <- cbind(seq(N), nn$nn.index[,i])
        ii <- ii + N
    }

    K <- 2^ncol(X)
    nn <- get.knnx(X.grid, X, k=K)
    nn.i <- nn$nn.index

    E <- matrix(nrow=K*n, ncol=2)
    l <- 1
    for ( i in seq(n) )
    {
        for ( j in seq(K) )
        {
            E[l,] <- c(i+N, nn.i[i,j])
            l <- l + 1
        }
    }

    V <- rbind(X.grid, X)
    E <- rbind(E.grid, E)

    A <- graph.adj.mat(V, E)
    G <- graph.adjacency(A, mode="undirected", weighted=TRUE)

    d <- distances(G)
    ## rownames(d) <- rownames(X)
    ## colnames(d) <- rownames(X)

    ## getting the largest distance that will be used for unreachable vertices for which graph distance is Inf
    dd <- as.numeric(d)
    dd <- dd[is.finite(dd)]
    max.d <- max(dd)

    ##r <- dist.to.knn(d, k)
    M <- nrow(d)
    nn.i <- matrix(0, nrow=N, ncol=k)
    nn.d <- matrix(0, nrow=N, ncol=k)
    for ( i in seq(N) )
    {
        x <- as.numeric(d[i,])
        o <- order(x)
        x <- x[o]
        ii <- o
        idx <- ii > N
        ii <- ii[idx] # selecting only indices of X
        x <- x[idx]
        x[!is.finite(x)] <- max.d
        nn.i[i,] <- ii[seq(k)] - N
        nn.d[i,] <- x[seq(k)]
    }

    list(V=V,
         E=E,
         nn.index=nn.i,
         nn.dist=nn.d)
}

#' Distances from the first vertex of a path to each consecutive vertex along
#' the given path normalized so that the total distance is 1.
#'
#' @param s        A sequences of vertex indices of the graph - the path.
#' @param V        A vertex positions matrix.
#' @param edge.col A color of the edges.
path.dist <- function(s, V, edge.col="gray")
{
    n <- length(s)
    d <- numeric(n)
    for ( i in 2:n )
    {
        M <- rbind(V[s[i-1],], V[s[i],])
        d[i] <- d[i - 1] + dist(M)[[1]]
    }

    d / d[n]
}

#' Computes the length of a path specified by a matrix X.
#'
#' @param X A matrix of points along a path.
path.length <- function(X)
{
    stopifnot(is.numeric(X))
    stopifnot(is.finite(X))
    nrX <- nrow(X)

    path.len <- 0
    for ( i in 2:nrX ) {
        path.len <- path.len + sqrt( sum ( (X[i,] - X[i-1,])^2 ) )
    }

    path.len
}

#' Smooths a piece-wise linear (PL) geodesic path
#'
#' @param S          A state space.
#' @param path.vs    A vector of indices of S constituting an geodesic path.
#' @param min.vs     The minimum number of vertices in path.vs for which a smoothing can be done. If |path.vs| < min.vs, then approx() is used to generate adj.n.vs vertices.
#' @param adj.n.vs   The number of vertices that is being created as the input for fb.rllm.1D() in case |path.vs| < min.vs.
#' @param grid.size  The number of grid points; A parameter passed to rllm.1D().
#' @param bw         The bandwidth of fb.rllm.1D().
#' @param fb.C       The number of bw's away from the boundary points of the domain of x that the adjusting of Eyg will take place, so that Eyg satisfies the boundary condition.
smooth.PL.geodesic <- function(S,
                              path.vs,
                              min.vs = 10,
                              adj.n.vs = 50,
                              grid.size = 200,
                              bw = grid.size * 3/200,
                              fb.C = 3)
{
    Epath <- c()
    X <- S[path.vs,]
    nrX <- nrow(X)

    if ( nrX < min.vs )
    {
        t <- seq(0, 1, length.out = nrX)
        x <- seq(0, 1, length.out = adj.n.vs)
        Y <- matrix(nrow = adj.n.vs, ncol = ncol(S))
        for ( i in seq(ncol(S)) ) {
            Y[,i] <- approx(t, X[,i], xout = x)$y
        }

        X <- Y
        nrX <- adj.n.vs
    }

    bws <- c()
    for ( colindex in seq(ncol(S)) )
    {
        r <- fb.rllm.1D(seq(nrX), X[,colindex], grid.size = grid.size, fb.C = fb.C, bw = bw)
        Epath <- cbind(Epath, r$Eyg)
        bws[colindex] <- r$bw
    }

    list(Epath = Epath,
         bws = bws)
}

## Prompt for chatGPT-4: Let path be a 100x3 matrix indicating a sequence of 100
## points in 3-dim space. The consecutive points can be connected by edges,
## which are line segments connecting these points. I want to find 500
## subdivision points on the edges of the path, so that the distance along the
## path between any two consecutive subdivision points is the same. Write a
## routine in R that takes as input a path matrix and the number of subdivision
## points and returns a matrix of subdivision points.

## Response

## To accomplish this, you can use the following algorithm:

## 1) Calculate the total length of the path by summing the Euclidean distances between consecutive points.
## 2) Determine the distance between consecutive subdivision points by dividing the total length by the number of subdivisions plus one.
## 3) Iterate through the edges of the path, adding subdivision points at equal distances along each edge.

## Here's a function in R that implements the algorithm:

## [pawel] There is an error in the subdivide_path routine that causes all points of output of this routine to be the same. Please fix it.

## [chatGPT] Apologies for the mistake. The issue was caused by not updating the remaining distance after finding a new subdivision point. Here's the corrected version of the subdivide_path() function:

## [pawel] I am still getting the same point being returned in the output of the routine. Please fix it.

## [chatGPT] Apologies again for the oversight. The issue was caused by not updating the current point after finding a new subdivision point when the remaining distance becomes zero. Here's the corrected version of the subdivide_path() function:

#' Function to calculate the Euclidean distance between two points
#'
#' @param p1 First point.
#' @param p2 Second point.
euclidean.distance <- function(p1, p2)
{
  return(sqrt(sum((p1 - p2) ^ 2)))
}

#' Subdivides a path of points in R^n into a uniform grid of points along the path.
#'
#' @param path               A matrix of consecutive path points in some state space.
#' @param n.subdivision.pts  The number of points in the grid.
subdivide.path <- function(path, n.subdivision.pts)
{
    n.pts <- dim(path)[1]
    edge.lengths <- sapply(seq(n.pts - 1), function(i) euclidean.distance(path[i,], path[i + 1,]))
    total.length <- sum(edge.lengths)
    subdiv.dist <- total.length / (n.subdivision.pts - 1)

    subdivision.pts <- matrix(nrow = n.subdivision.pts, ncol = ncol(path))

    start.offset <- 0           # When we reach edge.subdivision.dist:
                               # edge.subdivision.dist >= edge.length:
                               # start.offset <- edge.subdivision.dist - edge.length. Thus, start.offset is the distance from path[path.pt,], along the edge, of the first point on the new edge
                               # from which we start the process; Thus,
                               # path[path.pt,] is set to the points
                               # start.offset away from path[path.pt,] along he
                               # edge.
    subdiv.i <- 1

    for ( path.pt in 1:(n.pts-1) ) {

        edge.length <- edge.lengths[path.pt]

        if (start.offset > 0) # we need to update the path[path.pt,] to be start.offset away from it along the edge and then udpate
        {
            weight <- start.offset / edge.length
            path[path.pt,] <- path[path.pt,] + weight * (path[path.pt + 1,] - path[path.pt,])
            edge.length <- edge.length - start.offset
        }

        if ( edge.length > 0 ) {

            n.full.subdiv.intervals <- edge.length %/% subdiv.dist

            reminder.dist <- edge.length %% subdiv.dist

            edge.subdivision.dist <- 0 # the distance from the initial vertex of the given edge to the next subdivision point of the current edge

            for ( j in seq(n.full.subdiv.intervals + 1) ) {

                ## Calculate the new subdivision pt along the current edge
                weight <- edge.subdivision.dist / edge.length
                new.pt <- path[path.pt,] + weight * (path[path.pt + 1,] - path[path.pt,])

                if ( subdiv.i > n.subdivision.pts ) {
                    ## adding extra 100 rows to subdivision.pts
                    ##cat("k=",k," j=",j," k > n\n")
                    n.extra.rows <- 100
                    new.n <- nrow(subdivision.pts) + n.extra.rows
                    extra.pts <- matrix(nrow=new.n, ncol=ncol(subdivision.pts))
                    ##subdivision.pts <- suppressWarnings(matrix(subdivision.pts, nrow = new.n, ncol = ncol(subdivision.pts), byrow = FALSE))
                    subdivision.pts <- rbind(subdivision.pts, extra.pts)
                }

                subdivision.pts[subdiv.i,] <- new.pt
                subdiv.i <- subdiv.i + 1

                edge.subdivision.dist <- edge.subdivision.dist + subdiv.dist
            }

            start.offset <- subdiv.dist - reminder.dist
        } else {

            subdivision.pts[subdiv.i,] <- path[path.pt,]
            subdiv.i <- subdiv.i + 1
        }
    }

    ## detecting possible NA rows
    noneNA <- apply(subdivision.pts, 1, function(x) all(!is.na(x)))
    subdivision.pts <- subdivision.pts[noneNA,]

    return(subdivision.pts)
}


#' Subdivides a path of points in R^n into a uniform grid of points along the path.
#'
#' @param path               A matrix of consecutive path points in some state space.
#' @param n.subdivision.pts  The number of points in the grid.
subdivide.path.v1 <- function(path, n.subdivision.pts)
{
    n.pts <- dim(path)[1]
    edge.lengths <- sapply(seq(n.pts - 1), function(i) euclidean.distance(path[i,], path[i + 1,]))
    total.length <- sum(edge.lengths)
    subdiv.dist <- total.length / (n.subdivision.pts - 1)

    subdivision.pts <- matrix(nrow = n.subdivision.pts, ncol = ncol(path))

    path.pt <- 1                # the current path pooint
    edge.subdivision.dist <- 0  # the distance from the initial vertex of the given edge to the next subdivision point of the current edge

    start.offset <- 0           # When we reach edge.subdivision.dist:
                               # edge.subdivision.dist >= edge.length:
                               # start.offset <- edge.subdivision.dist - edge.length. Thus, start.offset is the distance from path[path.pt,], along the edge, of the first point on the new edge
                               # from which we start the process; Thus,
                               # path[path.pt,] is set to the points
                               # start.offset away from path[path.pt,] along he
                               # edge.
    subdiv.i <- 1

    while (subdiv.i <= n.subdivision.pts) {

        while (path.pt < n.pts && subdiv.i <= n.subdivision.pts) {

            edge.length <- edge.lengths[path.pt]

            if (start.offset > 0) # we need to update the path[path.pt,] to be start.offset away from it along the edge and then udpate
            {
                weight <- start.offset / edge.length
                path[path.pt,] <- path[path.pt,] + weight * (path[path.pt + 1,] - path[path.pt,])
                edge.length <- edge.length - start.offset
            }

            if (edge.subdivision.dist < edge.length) {

                ## Calculate the new subdivision pt along the current edge
                weight <- edge.subdivision.dist / edge.length
                new.pt <- path[path.pt,] + weight * (path[path.pt + 1,] - path[path.pt,])

                subdivision.pts[subdiv.i,] <- new.pt
                subdiv.i <- subdiv.i + 1

                ## Update the remaining dist for the next subdivision pt
                edge.subdivision.dist <- edge.subdivision.dist + subdiv.dist
                start.offset <- edge.subdivision.dist - edge.length

            } else {
                ## Move on to the next edge and update the remaining dist
                edge.subdivision.dist <- 0
                path.pt <- path.pt + 1
                start.offset <- edge.subdivision.dist - edge.length
                break
            }
        }
    }

    return(subdivision.pts)
}



#' Creates a tubular neighborhood of a geodesic
#'
#' @param smoothed.geodesic   A matrix of smoothed geodesic points in S.
#' @param S                A 3d model of a state space.
#' @param d.thld              A distance to the geodesic threshold. Set to 'auto' for automatic determination of the threshold.
#' @param dist.to.geodesic.q  The quantile of the distances to the geodesic to which the density function of the distances will be restricted to.
create.tubular.nbhd.of.a.geodesic <- function(smoothed.geodesic,
                                             S,
                                             d.thld="auto",
                                             dist.to.geodesic.q=0.25)
{
    nn <- get.knnx(smoothed.geodesic, S, k=1)
    nn.i <- nn$nn.index[,1]
    names(nn.i) <- rownames(S)

    dist.to.geodesic <- nn$nn.dist[,1]

    dd <- NULL
    if ( d.thld == "auto" ) {

        q <- quantile(dist.to.geodesic, prob=dist.to.geodesic.q)
        dd <- density(dist.to.geodesic[dist.to.geodesic < q], from=0)

        lmax.res <- loc.max.1D(dd$y)
        lmax <- dd$x[sort(lmax.res$locmax.idx)]

        lmin.res <- loc.max.1D(-dd$y)
        lmin <- dd$x[sort(lmin.res$locmax.idx)]
        d.thld <- lmin[lmin > lmax[1] & lmin < lmax[2]]
    }

    idx <- dist.to.geodesic < d.thld
    TN.geodesic <- S[idx,]
    TN.geodesic.samples <- rownames(TN.geodesic)

    dist.along.geodesic <- nn.i[TN.geodesic.samples]
    dist.along.geodesic <- dist.along.geodesic/max(dist.along.geodesic)

    o <- order(dist.along.geodesic)
    dist.along.geodesic <- dist.along.geodesic[o]
    TN.geodesic.samples <- TN.geodesic.samples[o]
    TN.geodesic <- TN.geodesic[o,]

    list(TN.geodesic=TN.geodesic,
         TN.geodesic.samples=TN.geodesic.samples,
         dist.along.geodesic=dist.along.geodesic,
         nn.i=nn.i,
         dist.to.geodesic=dist.to.geodesic,
         d.thld=d.thld,
         dd=dd)
}


#' Estimates and the mean prevalence of a factors along a geodesic.
#'
#' Given a list of subject-level factors, subj.factors, and IDs of the given
#' branch, bch.ids, as well as the distance along the geodesic, gamma, vector
#' and a file prefix, this routine estimates the mean prevalence of the given
#' factor, E_gamma_F, along the geodesic and saves the results of the estimates
#' to a file the given prefix and suffix: Fid.rda.
#'
#' @param subj.factors            A list of subject-level factors.
#' @param subjID                  A vector of subject IDs.
#' @param bch.ids                 Branch IDs.
#' @param dist.along.bch.geodesic A distance along the geodesic of the given branch.
#' @param file.prefix             The prefix of an rda file to which the results of E_gamma_F estimates will be save. Example: "~/projects/rllm/projects/ZB/data/asv_branches/Lc2Gv6_".
E.geodesic.F <- function(subj.factors,
                     subjID,
                     bch.ids,
                     dist.along.bch.geodesic,
                     file.prefix)
{
    save.files <- c()
    for ( Fid in names(subj.factors) )
    {
        rg.sample.ids <- bch.ids
        F <- subj.factors[[Fid]]
        F <- F[!is.na(F)]
        subj.ids <- names(F)
        n.subj <- length(subj.ids)
        ## Subjects detected within the given region
        rg.sample.to.subj.ids <- subjID[rg.sample.ids]
        rg.sample.to.subj.ids <- rg.sample.to.subj.ids[!is.na(rg.sample.to.subj.ids)]
        rg.subj.ids <- unique(rg.sample.to.subj.ids)
        rg.subj.ids <- intersect(rg.subj.ids, subj.ids)
        rg.n.subj <- length(rg.subj.ids)
        if ( rg.n.subj > 10 )
        {
            ## F restricted to the subjects of the region
            rg.F <- F[rg.subj.ids]
            rg.F <- rg.F[!is.na(rg.F)] # this is necessary as some subjects of the region may not be in the domain of F
            rg.F.freq <- table(rg.F)
            ##
            ## Extending F to samples
            ##
            sF <- c()
            cF <- as.character(F)
            names(cF) <- names(F)
            s <- subjID[rg.sample.ids]
            for ( subj.id in rg.subj.ids )
            {
                idx <- !is.na(s) & s == subj.id
                ids <- names(s)[idx]
                sF[ids] <- cF[subj.id]
            }
            if ( length(rg.F.freq) == 2 )
            {
                cat(Fid, "\n")
                y <- ifelse(sF=="Yes",1,0)
                x <- dist.along.bch.geodesic[names(sF)]
                delta1.res <- delta1.test(x, y, y.binary=TRUE)
                Fid2 <- gsub("\\.","_",Fid)
                file <- paste0(file.prefix,Fid2,".rda")
                save.files[Fid] <- file
                save(delta1.res, file=file)

            } else if ( length(rg.F.freq) > 2 ) {

                lvs <- names(rg.F.freq)
                k <- 1
                for ( lv in lvs )
                {
                    cat(Fid,"::",lv,"\n")
                    y <- ifelse(sF==lv, 1, 0)
                    x <- dist.along.bch.geodesic[names(sF)]
                    delta1.res <- delta1.test(x, y, y.binary=TRUE)
                    Fid2 <- gsub("\\.","_",Fid)
                    file <- paste0(file.prefix,Fid2,"_",k,".rda")
                    save.files[Fid] <- file
                    save(delta1.res, file=file)
                    k <- k + 1
                }
            }
        }
    }

    rlabs <- c()
    for ( Fid in names(subj.factors) )
    {
        subj.F <- subj.factors[[Fid]]
        subj.F <- subj.F[!is.na(subj.F)]
        f <- table(subj.F)
        Fid2 <- gsub("\\.","_",Fid)
        if ( length(f) == 2 ) {
            rlabs <- c(rlabs, Fid2)
        } else {
            rlabs <- c(rlabs, paste0(Fid2,"_",seq(f)))
        }
    }

    list(save.files=save.files,
         rlabs=rlabs)
}

#' Generates figures associated with E.geodesic.F estimates.
#'
#' @param save.file.prefix   A prefix of the save() files.
#' @param rlabs              Labels of the subject factors with levels.
#' @param pics.file.prefix   A prefix pdf output files.
fig.E.geodesic.F <- function(save.file.prefix, rlabs, pics.file.prefix)
{
    for ( lab in rlabs )
    {
        delta1.res <- NULL
        file <- paste0(save.file.prefix,lab,".rda")
        ## save(delta1.res, file=file)
        if ( file.exists(file) )
        {
            load(file)
            file <- paste0(pics.file.prefix,lab,"_Exy.pdf")
            pdf(file, width=6, height=6)
            op <- par(mar=c(3.75, 3.75, 1.5, 0.5), mgp=c(2.25,0.5,0), tcl = -0.3)
            plot.delta1.diag(delta1.res, plot="Exy", xlab="Distance along the geodesic", ylab="pr(F=1)", title=lab)
            par(op)
            dev.off()
            file <- paste0(pics.file.prefix,lab,"_delta1.pdf")
            pdf(file, width=6, height=6)
            op <- par(mar=c(3.75, 3.75, 0.5, 0.5), mgp=c(2.25,0.5,0), tcl = -0.3)
            plot.delta1.diag(delta1.res, plot="d1hist", xlab="delta 1")
            par(op)
            dev.off()
        }
    }
}


#' Sings of the derivatives of the E.geodesic.F porfiles.
#'
#' @param save.file.prefix   The prefix of the save() files.
#' @param rlabs              Labels of the subject factors with levels.
#' @param grid.size          Grid size in E.geodesic.F estimates.
subj.factor.signEy.profs <- function(save.file.prefix, rlabs, grid.size=400)
{
    subj.factor.signEy.profs <- matrix(nrow=length(rlabs), ncol=grid.size-1)
    rownames(subj.factor.signEy.profs) <- rlabs
    for ( lab in rlabs )
    {
        delta1.res <- NULL
        file <- paste0(save.file.prefix,lab,".rda")
        ## save(delta1.res, file=file)
        if ( file.exists(file) )
        {
            load(file)
            Ey.res <- delta1.res$Ey.res
            Ey <- Ey.res$Eyg
            dEy <- diff(Ey)
            subj.factor.signEy.profs[lab,] <- sign(dEy)
        }
    }

    subj.factor.signEy.profs
}

#' Generates a data frame of proportion plus/minus dE.geodesic.F profiles.
#'
#' @param subj.factor.signEy.profs  An output from subj.factor.signEy.profs().
#' @param rowInd             Row index permutation vector as returned by ‘order.dendrogram’.
#' @param rlabs              Labels of the subject factors with levels.
#' @param save.file.prefix   The prefix of the save() files.
#' @param N                  The number of +/0/- symbols in each profile.
subj.factor.ppmEy.profs.df <- function(subj.factor.signEy.profs, rowInd, rlabs, save.file.prefix, N=10)
{
    X <- subj.factor.signEy.profs[rev(rowInd),]
    ##rownames(X)

    pval <- c()
    for ( lab in rlabs )
    {
        delta1.res <- NULL
        file <- paste0(save.file.prefix,lab,".rda")
        ## save(delta1.res, file=file)
        if ( file.exists(file) )
        {
            load(file)
            pval[lab] <- delta1.res$p.value
        }
    }

    subj.factor.signEy.profs.df <- matrix(nrow=nrow(X), ncol=2)
    colnames(subj.factor.signEy.profs.df) <- c("Pattern","p-val")
    rownames(subj.factor.signEy.profs.df) <- rownames(X)
    subj.factor.signEy.profs.df <- as.data.frame(subj.factor.signEy.profs.df)
    subj.factor.signEy.profs.df[,1] <- as.character(subj.factor.signEy.profs.df[,1])
    subj.factor.signEy.profs.df[,2] <- as.numeric(subj.factor.signEy.profs.df[,2])
    for ( i in seq(nrow(X)) )
    {
        lab <- rownames(subj.factor.signEy.profs.df)[i]
        x <- subj.factor.signEy.profs[lab,]
        res <- ppm.pattern(x)
        subj.factor.signEy.profs.df[lab,1] <- str.ppm.pattern(res, N=N)
        subj.factor.signEy.profs.df[lab,2] <- pval[lab]
    }

    subj.factor.signEy.profs.df$qval <- p.adjust(subj.factor.signEy.profs.df[,2], method="fdr")
    colnames(subj.factor.signEy.profs.df)[3] <- "q-val"
    subj.factor.signEy.profs.df

    for (i in 2:3) {
        subj.factor.signEy.profs.df[,i] <- signif(subj.factor.signEy.profs.df[,i], digits=2)
    }
    subj.factor.signEy.profs.df

    for (i in seq(nrow(subj.factor.signEy.profs.df))) {
        subj.factor.signEy.profs.df[i,1] <- paste0("\\verb|",subj.factor.signEy.profs.df[i,1],"|")
    }

    ## rn <- rownames(subj.factor.signEy.profs.df)
    ## rn[rn=="BMI_cat_1"] <- paste0("BMI_cat_$",levels(BMI.cat.f)[1],"$")
    ## rn[rn=="BMI_cat_2"] <- paste0("BMI_cat_$",levels(BMI.cat.f)[2],"$")
    ## rn[rn=="BMI_cat_3"] <- paste0("BMI_cat_$",levels(BMI.cat.f)[3],"$")
    ## rownames(subj.factor.signEy.profs.df) <- rn

    subj.factor.signEy.profs.df
}

#' Estimates the mean abundance of the columns of X along a geodesic.
#'
#' Given a matrix, X, of covariates defined over a subset of sample of the state
#' space of which the strand is a part of, the script estimates the mean of each
#' column (as a function of the distance along the geodesics) meeting some
#' prevalence criteria and it will save the result in the supplied data
#' directory.
#'
#' @param X                           A matrix of covariates.
#' @param strand.ids                  The given strand sample IDs.
#' @param dist.along.strand.geodesic  A distance along the geodesic of the given branch.
#' @param data.dir                    A path to the data directory.
#' @param winsorize                   A logical parameter. Set to TRUE to perform right winsorization of the columns of X before the min-max normalization. Default is TRUE.
#' @param winsorize.p                 A proportion of values at the right tail of the distribution of each column that will be set to the corresponding quantile of that distribution. Default is 0.025. With that value all values above 1 - 0.025 quantile are set to the value of that quantile.
#' @param min.max.normalize           A logical parameter. Set to TRUE to min-max normalize each column of X. Default is TRUE.
#' @param prev.thld                   The prevalence theshold. Only clumns of X that are non-zero over at least prev.thld proportion of samples will be used in the analysis.
#' @param min.sample.count            Perform analyses only if the number of samples common to X and the given strand is at least min.sample.count.
#' @param rerun                       A logical value. Set to TRUE to rerun delta1.test().
#' @param n.partitions                The number of partitions of the index vector of the columns of the filtered X.
#' @param partition.i                 An index of a partition to run.
#' @param verbose                     A logical value indicating whether detailed output should be printed during the function's execution. If TRUE, the function will print out additional details about the calculations it's performing. Default is TRUE.
#'
#' @return
#' Returns a list with the following components:
#' \itemize{
#' \item{X}{The input matrix after sample and column filtering.}
#' \item{res.list}{A named list (with the names the simplified column names of X) of results of TAA.test() on each column as an outcome and the distance along the geodesic as a predictor.}
#' \item{save.files}{A character vector of file names for saved results of TAA.test().}
#' \item{name.tbl}{A character vector mapping simplified names to the original names.}
#' \item{Ey.df}{A matrix of the mean abundances along the geodesic for different columns of X (after filtering columns using prev.thld criterion).}
#' \item{dEy.df}{A matrix of the scaled derivative estimates estimated naively as diff(Ey). }
#' \item{sign.dEy.df}{A matrix of resulted from dEy.df by applying the signs function to the rows of dEy.df.}
#' }
#' @examples
#' \dontrun{
#' # Here's an example of how to use predict.rllm3D
#' result <- E.geodesic.X(S.mb, )
#'
#' }
E.geodesic.X <- function(X,
                        strand.ids,
                        dist.along.strand.geodesic,
                        data.dir,
                        winsorize = TRUE,
                        winsorize.p = 0.025,
                        min.max.normalize = TRUE,
                        prev.thld = 0.9,
                        min.sample.count = 40,
                        rerun = FALSE,
                        n.partitions = 1,
                        partition.i = 1,
                        verbose = TRUE)
{
    stopifnot(all(is.finite(X)))

    ## The samples common to X and the given strand
    comm.ids <- intersect(strand.ids, rownames(X))

    if ( length(comm.ids) < min.sample.count ) {
        stop("The number of samples common to X and the strand is less than the min.sample.count length(comm.ids): ", length(comm.ids))
    }

    n.comm.ids <- length(comm.ids)

    if ( verbose ) {
        cat("The number of samples in the strand: ", length(strand.ids), "\n")
        cat("The number of samples in X: ", nrow(X), "\n")
        cat("The number of samples common to X and the strand: ", n.comm.ids, "\n")
    }

    X <- X[comm.ids,]
    dist.along.strand.geodesic <- dist.along.strand.geodesic[comm.ids]

    ## filtering out the columns of X that do not have at least pref.thld non-zero values
    n.det <- apply(X, 2, function(x) sum(x != 0) )
    prev <- n.det / n.comm.ids
    idx <- prev >= prev.thld
    nc.X.before <- ncol(X)
    X <- X[,idx]

    min.winsorize.p <- 1 / n.comm.ids
    if ( winsorize.p < min.winsorize.p ) {
        cat("Adjusted winsorize.p to", min.winsorize.p, "\n")
        winsorize.p <- min.winsorize.p
    }

    if ( winsorize ) {
        X <- apply(X, 2, function(x) pplots::right.winsorize(x, p=winsorize.p))
    }

    y.binary <- FALSE
    if ( min.max.normalize ) {
        X <- apply(X, 2, min.max.norm)
        y.binary <- TRUE
    }

    if ( verbose ) {
        cat("The number of columns of X before prevalence filtering: ", nc.X.before, "\n")
        cat("The number of columns of X after prevalence filtering: ", ncol(X), "\n")
        ptm <- proc.time()
        cat("Calculating TAA statistics the columns of X ... \n")
    }

    one.column <- function(col.i)
    {
        cat("\r", col.i)
        col.id <- colnames(X)[col.i]
        standardized.id <- standardize.string(col.id) # removing special characters from the name
        file <- paste0(data.dir,"/",col.i,".rda")
        if ( !file.exists(file) || rerun )
        {
            y <- X[,col.i]
            x <- dist.along.strand.geodesic
            if ( !min.max.normalize ) {
                idx <- y > 0
                y <- y[idx]
                x <- x[idx]
            }
            delta1.res <- delta1.test(x, y, y.binary=y.binary, plot.it=FALSE, verbose=FALSE)
            ##save(delta1.res, file=file)
            Ey <- delta1.res$Ey
            pval <- delta1.res$p.value
            save(Ey, pval, file=file)
        }

        list(col.id=col.id,
             standardized.id=standardized.id,
             file=file)
    }

    save.files <- c()
    name.tbl <- c()

    if ( n.partitions == 1 )
    {
        for ( col.i in seq(ncol(X)) )
        {
            if ( verbose ) {
                res <- one.column(col.i)
                save.files[res$standardized.id] <- res$file
                name.tbl[res$standardized.id] <- res$col.id
            }
        }
    } else {

        spliced.loop <- function(n, i)
        {
            index.splits <- split(seq(ncol(X)), rep(1:n, length=ncol(X)))
            indices <- index.splits[[i]]

            save.files <- c()
            name.tbl <- c()

            for ( j in indices ) {
                res <- one.column(j)
                save.files[res$standardized.id] <- res$file
                name.tbl[res$standardized.id] <- res$col.id
            }

            list(save.files=save.files,
                 name.tbl=name.tbl)
        }

        if ( verbose ) {
            cat("Splitting the columns of X into", n.partitions, "partitions\n")
            cat("Processing partition:", partition.i, "\n")
        }

        res <- spliced.loop(n.partitions, partition.i)
        save.files <- res$save.files
        name.tbl <- res$name.tbl
    }


    if ( 0 ) {
        if ( verbose ) {
            elapsed.time(ptm)
            cat("Calculating derivatives of the columns's mean abundance profiles ... \n")
            ptm <- proc.time()
        }

        Ey <- delta1.res$Ey
        grid.size <- length(Ey)
        Ey.df <- matrix(nrow=ncol(X), ncol=grid.size)
        rownames(Ey.df) <- colnames(X)
        dEy.df <- matrix(nrow=ncol(X), ncol=grid.size)
        rownames(dEy.df) <- colnames(X)
        sign.dEy.df <- matrix(nrow=ncol(X), ncol=grid.size)
        rownames(sign.dEy.df) <- colnames(X)
        dx <- 1 / grid.size
        for ( i in seq(length(res.list)) ) {
            delta1.res <- res.list[[i]]
            Ey <- delta1.res$Ey
            Ey.df[i,] <- Ey
            ##dEy <- diff(Ey)
            dEy <- derivative.second.order.method(Ey, dx)
            dEy.df[i,] <- dEy
            sign.dEy.df[i,] <- sign(dEy)
        }

        if ( verbose ) {
            elapsed.time(ptm)
        }
    }

    list(X = X,
         dist.along.strand.geodesic=dist.along.strand.geodesic,
         data.dir = data.dir,
         save.files = save.files,
         name.tbl = name.tbl)
}


#' Given TA and TAA from E.geodesic.X(), this routine identifies variables monotonically associated with the distance along the geodesic
#'
#' @param X     A matrix of a data frame with TA and delta1 columns.
#' @param eps   The positive constant specifying the size of a neighborhood around the diagonal and anti-diagonal of the (TA, TAA) graph.
vars.approx.monotonically.assoc.with.geodesic <- function(X, eps = 0.4) {

    if (!is.matrix(X)) {
        X <- try(as.matrix(X), silent = TRUE)
        if (inherits(X, "try-error")) {
            stop("X must be a matrix or coercible to a matrix")
        }
    }

    if (!is.numeric(X)) {
        stop("X must contain numeric values")
    }

    if (any(is.na(X)) || any(is.infinite(X))) {
        stop("X cannot contain NA, NaN, or Inf values")
    }

    stopifnot(all(c("TA", "TAA") %in% colnames(X)))

    if ( !is.data.frame(X) ) {
        X <- as.data.frame(X)
    }

    TA <- X$TA
    TAA <- X$TAA

    ## Identifying variables approximately-monotonically-POSITIVELY-associated
    ## with the distance along the geodesic
    idx <- TA > 0
    var.names <- rownames(X)[idx]
    x <- log(TA[idx])
    y <- log(TAA[idx])
    idx <- y-x < eps
    pos.vars <- var.names[idx]

    ## Identifying variables approximately-monotonically-NEGATIVELY-associated
    ## with the distance along the geodesic
    idx <- TA < 0
    var.names <- rownames(X)[idx]
    x <- log(-TA[idx])
    y <- log(TAA[idx])
    idx <- y-x < eps
    neg.vars <- var.names[idx]

    list(pos.vars=pos.vars,
         neg.vars=neg.vars)
}

#' Estimates subject risk of a disease or adverse outcome, D, given the risk D over some state space.
#'
#' @param sID      A subject ID.
#' @param S     A state space.
#' @param G.S   A graph associated with S.
#' @param ED       An estimate of the risk of a disease or adverse outcome, D, over S.
#' @param subjID   A vector of subject IDs.
#' @param visit    A vector of visits.
subj.D.risk <- function(sID, S, G.S, ED, subjID, visit)
{
    ##
    ##  Getting subject visit IDs and indices
    ##
    subj.ids.res <- get.subj.ids(sID, S, subjID, visit)

    subj.ids <- subj.ids.res$ids
    subj.ii <- subj.ids.res$ii
    subj.sVisit <- subj.ids.res$sVisit

    ##
    ##  Gettting geodesic paths between visit states
    ##
    path1.vs <- shortest_paths(G.S, from=subj.ii[1], to=c(subj.ii[2]))[[1]][[1]]
    path1.vs <- as.integer(path1.vs)

    path2.vs <- shortest_paths(G.S, from=subj.ii[2], to=c(subj.ii[3]))[[1]][[1]]
    path2.vs <- as.integer(path2.vs)

    ##
    ##  Smoothing geodesic paths
    ##
    Epath1 <- smooth.PL.geodesic(S, path1.vs)
    Epath2 <- smooth.PL.geodesic(S, path2.vs)

    ##
    ##  Interpolating ED over the smoothed geodesic paths
    ##

    ## ED over Epath1
    ED.over.Epath1.itpt.res <- interpolate(S, ED, Epath1)
    ##str(ED.over.Epath1.itpt.res)
    ED.over.Epath1 <- ED.over.Epath1.itpt.res$y.pred

    ## ED over Epath2
    ED.over.Epath2.itpt.res <- interpolate(S, ED, Epath2)
    ##str(ED.over.Epath2.itpt.res)
    ED.over.Epath2 <- ED.over.Epath2.itpt.res$y.pred
    ##plot(ED.over.Epath2, type='l')

    ##
    ##  Estimating subject risk of D
    ##
    E.ED.over.Epath <- mean(c(ED.over.Epath1, ED.over.Epath2))
    Ep05.ED.over.Epath <- mean(c(ED.over.Epath1^0.5, ED.over.Epath2^0.5))
    Ep025.ED.over.Epath <- mean(c(ED.over.Epath1^0.25, ED.over.Epath2^0.25))

    list(subj.ids=subj.ids,
         subj.ii=subj.ii,
         subj.sVisit=subj.sVisit,
         path1.vs=path1.vs,
         path2.vs=path2.vs,
         Epath1=Epath1,
         Epath2=Epath2,
         ED.over.Epath1=ED.over.Epath1,
         ED.over.Epath2=ED.over.Epath2,
         E.ED.over.Epath=E.ED.over.Epath,
         Ep05.ED.over.Epath=Ep05.ED.over.Epath,
         Ep025.ED.over.Epath=Ep025.ED.over.Epath)
}


#' Compute the Shortest Smooth Geodesic Path in S(X)
#'
#' This function computes the shortest smooth path between two points in a dataset S(X)
#' based on a given density function \eqn{\rho}. It uses an elastic path algorithm
#' to iteratively refine the path according to the density characteristics of the space.
#'
#' @param X An n-by-d matrix representing the dataset S(X) in \eqn{\mathbb{R}^d}.
#' @param i0 The index of the first point in S(X).
#' @param i1 The index of the second point in S(X).
#' @param rho A function that estimates the density \eqn{\rho_{S(X)}} at any given
#'   point in \eqn{\mathbb{R}^d}. It should accept a single point (a vector of length d)
#'   and return a non-negative density value.
#' @param grid.size An optional integer specifying the number of points to discretize
#'   the path. Defaults to 400.
#'
#' @return A grid.size-by-d matrix \code{gamma}. Each row in \code{gamma} represents
#'   a point on the computed geodesic path in \eqn{\mathbb{R}^d}.
#'
#' @examples
#' X <- matrix(rnorm(100), nrow = 50, ncol = 2)
#' rho_function <- function(point) {
#'   dnorm(point[1]) * dnorm(point[2])
#' }
#' path <- smooth.geodesic(X, 1, 50, rho_function, grid.size = 100)
#' plot(X[, 1], X[, 2], main = "Smooth Geodesic Path")
#' lines(path[, 1], path[, 2], col = 'red', lwd = 2)
#'
#' @export
#' @importFrom stats dnorm
#' @importFrom graphics plot lines
#' @importFrom grDevices col2rgb
#'
#' @references
#' <Add any relevant references or citations related to the algorithm or method used>
#'
#' @note
#' The quality and behavior of the computed path heavily depend on the accuracy and
#' characteristics of the provided density function \eqn{\rho}.
#'
#' @seealso
#' <Other related functions or resources>
#'
#' @rdname smooth.geodesic
#' @aliases smooth.geodesic
#' @family <Optional: group related functions>
smooth.geodesic <- function(X, i0, i1, rho, grid.size = 400) {

  # Ensure that i0 and i1 are within the bounds of X
  if (i0 < 1 || i0 > nrow(X) || i1 < 1 || i1 > nrow(X)) {
    stop("Indices i0 and i1 must be within the row bounds of X.")
  }

  # Initialize the path gamma
  gamma <- matrix(0, nrow = grid.size, ncol = ncol(X))
  for (j in 1:ncol(X)) {
    gamma[, j] <- seq(X[i0, j], X[i1, j], length = grid.size)
  }

  # Iteratively update the path
  for (iteration in 1:1000) {  # Set a maximum number of iterations
    for (i in 2:(grid.size - 1)) {
      # Compute elastic force
      elastic_force <- (gamma[i - 1, ] - 2 * gamma[i, ] + gamma[i + 1, ]) * 0.1

      # Update the position of the point
      rho_value <- estimate_density(gamma[i, ], X)
      gamma[i, ] <- gamma[i, ] + elastic_force / rho_value
    }

    # Convergence check (can be refined)
    if (max(abs(elastic_force)) < 1e-6) {
      break
    }
  }

  return(gamma)
}

#' Define a function to estimate the density rho_S(X)
#'
#' This is a placeholder for a density estimation function. In practice, this
#' might use methods like kernel density estimation.
estimate_density <- function(point, X) {
    return(1)  # Returning a constant for simplicity.
}


#' Compute Shortest Smooth Geodesic Path in Multi-Omics Data
#'
#' This function computes the shortest smooth geodesic path between two points
#' in a high-dimensional space, specifically designed for multi-omics data analysis.
#' The algorithm operates in two phases: Path Shortening and Path Smoothing,
#' and is optimized for high-dimensional data spaces.
#'
#' @param X A matrix representing the multi-omics dataset.
#' @param i0 The index of the first point in the dataset.
#' @param i1 The index of the second point in the dataset.
#' @param k The number of nearest neighbors to consider in the k-NN graph.
#' @param grid.size The number of points for path smoothing.
#' @param n.iter Shortening and smoothing phase iteration counts as a list (c(shortening, smoothing)).
#' @param rho A function to estimate the density at any given point in the dataset.
#'
#' @return A list containing the smoothed path and its length.
#'
#' @examples
#' X <- matrix(rnorm(100), nrow = 50, ncol = 2)
#' rho_function <- function(point) { dnorm(point[1]) * dnorm(point[2]) }
#' path_info <- compute_geodesic_path(X, 1, 50, k = 5, grid.size = 100, n.iter = c(50, 50), rho = rho_function)
#'
#' @export
compute_geodesic_path <- function(X, i0, i1, k, grid.size, n.iter, rho) {
    ## Function implementation here
    ## Phase 1: Path Shortening
    ## Phase 2: Path Smoothing
    ## Return the path and its length

    ## Check input validity
    if (i0 < 1 || i0 > nrow(X) || i1 < 1 || i1 > nrow(X)) {
        stop("i0 and i1 must be within the bounds of X")
    }

    ## Phase 1: Path Shortening - Using kNN to initialize the path
    ## This is a placeholder for the kNN path initialization
    ## A complete implementation would find the shortest path in the k-NN graph
    path <- X[c(i0, i1), ]

    ## Path shortening iterations
    for (iter in 1:n.iter[1]) {
        ## Placeholder for gradient calculation and skewed sampling
        ## In practice, this would involve complex calculations and probabilistic sampling
    }

    ## Phase 2: Path Smoothing - Refining the path
    ## This is a simple linear interpolation. A complete implementation would involve more sophisticated smoothing
    smooth_path <- matrix(NA, nrow = grid.size, ncol = ncol(X))
    for (j in 1:ncol(X)) {
        smooth_path[, j] <- seq(from = path[1, j], to = path[2, j], length.out = grid.size)
    }

    ## Placeholder for the path length calculation
    path_length <- NA  ## Replace with actual path length calculation

    return(list(path = smooth_path, length = path_length))
}
